
{::nomarkdown}
<div class="lwarp-contents">
{% raw %}
<div class="hidden" >

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\mathllap }[2][]{{#1#2}}\)

\(\newcommand {\mathrlap }[2][]{{#1#2}}\)

\(\newcommand {\mathclap }[2][]{{#1#2}}\)

\(\newcommand {\mathmbox }[1]{#1}\)

\(\newcommand {\clap }[1]{#1}\)

\(\newcommand {\LWRmathmakebox }[2][]{#2}\)

\(\newcommand {\mathmakebox }[1][]{\LWRmathmakebox }\)

\(\newcommand {\cramped }[2][]{{#1#2}}\)

\(\newcommand {\crampedllap }[2][]{{#1#2}}\)

\(\newcommand {\crampedrlap }[2][]{{#1#2}}\)

\(\newcommand {\crampedclap }[2][]{{#1#2}}\)

\(\newenvironment {crampedsubarray}[1]{}{}\)

\(\newcommand {\crampedsubstack }{}\)

\(\newcommand {\smashoperator }[2][]{#2\limits }\)

\(\newcommand {\adjustlimits }{}\)

\(\newcommand {\SwapAboveDisplaySkip }{}\)

\(\require {extpfeil}\)

\(\Newextarrow \xleftrightarrow {10,10}{0x2194}\)

\(\Newextarrow \xLeftarrow {10,10}{0x21d0}\)

\(\Newextarrow \xhookleftarrow {10,10}{0x21a9}\)

\(\Newextarrow \xmapsto {10,10}{0x21a6}\)

\(\Newextarrow \xRightarrow {10,10}{0x21d2}\)

\(\Newextarrow \xLeftrightarrow {10,10}{0x21d4}\)

\(\Newextarrow \xhookrightarrow {10,10}{0x21aa}\)

\(\Newextarrow \xrightharpoondown {10,10}{0x21c1}\)

\(\Newextarrow \xleftharpoondown {10,10}{0x21bd}\)

\(\Newextarrow \xrightleftharpoons {10,10}{0x21cc}\)

\(\Newextarrow \xrightharpoonup {10,10}{0x21c0}\)

\(\Newextarrow \xleftharpoonup {10,10}{0x21bc}\)

\(\Newextarrow \xleftrightharpoons {10,10}{0x21cb}\)

\(\newcommand {\LWRdounderbracket }[3]{\underset {#3}{\underline {#1}}}\)

\(\newcommand {\LWRunderbracket }[2][]{\LWRdounderbracket {#2}}\)

\(\newcommand {\underbracket }[1][]{\LWRunderbracket }\)

\(\newcommand {\LWRdooverbracket }[3]{\overset {#3}{\overline {#1}}}\)

\(\newcommand {\LWRoverbracket }[2][]{\LWRdooverbracket {#2}}\)

\(\newcommand {\overbracket }[1][]{\LWRoverbracket }\)

\(\newcommand {\LaTeXunderbrace }[1]{\underbrace {#1}}\)

\(\newcommand {\LaTeXoverbrace }[1]{\overbrace {#1}}\)

\(\newenvironment {matrix*}[1][]{\begin {matrix}}{\end {matrix}}\)

\(\newenvironment {pmatrix*}[1][]{\begin {pmatrix}}{\end {pmatrix}}\)

\(\newenvironment {bmatrix*}[1][]{\begin {bmatrix}}{\end {bmatrix}}\)

\(\newenvironment {Bmatrix*}[1][]{\begin {Bmatrix}}{\end {Bmatrix}}\)

\(\newenvironment {vmatrix*}[1][]{\begin {vmatrix}}{\end {vmatrix}}\)

\(\newenvironment {Vmatrix*}[1][]{\begin {Vmatrix}}{\end {Vmatrix}}\)

\(\newenvironment {smallmatrix*}[1][]{\begin {matrix}}{\end {matrix}}\)

\(\newenvironment {psmallmatrix*}[1][]{\begin {pmatrix}}{\end {pmatrix}}\)

\(\newenvironment {bsmallmatrix*}[1][]{\begin {bmatrix}}{\end {bmatrix}}\)

\(\newenvironment {Bsmallmatrix*}[1][]{\begin {Bmatrix}}{\end {Bmatrix}}\)

\(\newenvironment {vsmallmatrix*}[1][]{\begin {vmatrix}}{\end {vmatrix}}\)

\(\newenvironment {Vsmallmatrix*}[1][]{\begin {Vmatrix}}{\end {Vmatrix}}\)

\(\newenvironment {psmallmatrix}[1][]{\begin {pmatrix}}{\end {pmatrix}}\)

\(\newenvironment {bsmallmatrix}[1][]{\begin {bmatrix}}{\end {bmatrix}}\)

\(\newenvironment {Bsmallmatrix}[1][]{\begin {Bmatrix}}{\end {Bmatrix}}\)

\(\newenvironment {vsmallmatrix}[1][]{\begin {vmatrix}}{\end {vmatrix}}\)

\(\newenvironment {Vsmallmatrix}[1][]{\begin {Vmatrix}}{\end {Vmatrix}}\)

\(\newcommand {\LWRmultlined }[1][]{\begin {multline*}}\)

\(\newenvironment {multlined}[1][]{\LWRmultlined }{\end {multline*}}\)

\(\let \LWRorigshoveleft \shoveleft \)

\(\renewcommand {\shoveleft }[1][]{\LWRorigshoveleft }\)

\(\let \LWRorigshoveright \shoveright \)

\(\renewcommand {\shoveright }[1][]{\LWRorigshoveright }\)

\(\newenvironment {dcases}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {dcases*}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {rcases}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {rcases*}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {drcases}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {drcases*}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {cases*}{\begin {cases}}{\end {cases}}\)

\(\newcommand {\MoveEqLeft }[1][]{}\)

\(\def \LWRAboxed #1&amp;#2&amp;#3!|!{\fbox {\(#1\)}&amp;\fbox {\(#2\)}} \newcommand {\Aboxed }[1]{\LWRAboxed #1&amp;&amp;!|!} \)

\( \newcommand {\LWRABLines }[1][\Updownarrow ]{#1 \notag \\}\newcommand {\ArrowBetweenLines }{\ifstar \LWRABLines \LWRABLines } \)

\(\newcommand {\shortintertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\vdotswithin }[1]{\hspace {.5em}\vdots }\)

\(\newcommand {\LWRshortvdotswithinstar }[1]{\vdots \hspace {.5em} &amp; \\}\)

\(\newcommand {\LWRshortvdotswithinnostar }[1]{&amp; \hspace {.5em}\vdots \\}\)

\(\newcommand {\shortvdotswithin }{\ifstar \LWRshortvdotswithinstar \LWRshortvdotswithinnostar }\)

\(\newcommand {\MTFlushSpaceAbove }{}\)

\(\newcommand {\MTFlushSpaceBelow }{\\}\)

\(\newcommand \lparen {(}\)

\(\newcommand \rparen {)}\)

\(\newcommand {\ordinarycolon }{:}\)

\(\newcommand {\vcentcolon }{\mathrel {\mathop \ordinarycolon }}\)

\(\newcommand \dblcolon {\vcentcolon \vcentcolon }\)

\(\newcommand \coloneqq {\vcentcolon =}\)

\(\newcommand \Coloneqq {\dblcolon =}\)

\(\newcommand \coloneq {\vcentcolon {-}}\)

\(\newcommand \Coloneq {\dblcolon {-}}\)

\(\newcommand \eqqcolon {=\vcentcolon }\)

\(\newcommand \Eqqcolon {=\dblcolon }\)

\(\newcommand \eqcolon {\mathrel {-}\vcentcolon }\)

\(\newcommand \Eqcolon {\mathrel {-}\dblcolon }\)

\(\newcommand \colonapprox {\vcentcolon \approx }\)

\(\newcommand \Colonapprox {\dblcolon \approx }\)

\(\newcommand \colonsim {\vcentcolon \sim }\)

\(\newcommand \Colonsim {\dblcolon \sim }\)

\(\newcommand {\nuparrow }{\mathrel {\cancel {\uparrow }}}\)

\(\newcommand {\ndownarrow }{\mathrel {\cancel {\downarrow }}}\)

\(\newcommand {\bigtimes }{\mathop {\Large \times }\limits }\)

\(\newcommand {\prescript }[3]{{}^{#1}_{#2}#3}\)

\(\newenvironment {lgathered}{\begin {gathered}}{\end {gathered}}\)

\(\newenvironment {rgathered}{\begin {gathered}}{\end {gathered}}\)

\(\newcommand {\splitfrac }[2]{{}^{#1}_{#2}}\)

\(\let \splitdfrac \splitfrac \)

\(\newcommand {\LWRoverlaysymbols }[2]{\mathord {\smash {\mathop {#2\strut }\limits ^{\smash {\lower 3ex{#1}}}}\strut }}\)

\(\newcommand{\alphaup}{\unicode{x03B1}}\)

\(\newcommand{\betaup}{\unicode{x03B2}}\)

\(\newcommand{\gammaup}{\unicode{x03B3}}\)

\(\newcommand{\digammaup}{\unicode{x03DD}}\)

\(\newcommand{\deltaup}{\unicode{x03B4}}\)

\(\newcommand{\epsilonup}{\unicode{x03F5}}\)

\(\newcommand{\varepsilonup}{\unicode{x03B5}}\)

\(\newcommand{\zetaup}{\unicode{x03B6}}\)

\(\newcommand{\etaup}{\unicode{x03B7}}\)

\(\newcommand{\thetaup}{\unicode{x03B8}}\)

\(\newcommand{\varthetaup}{\unicode{x03D1}}\)

\(\newcommand{\iotaup}{\unicode{x03B9}}\)

\(\newcommand{\kappaup}{\unicode{x03BA}}\)

\(\newcommand{\varkappaup}{\unicode{x03F0}}\)

\(\newcommand{\lambdaup}{\unicode{x03BB}}\)

\(\newcommand{\muup}{\unicode{x03BC}}\)

\(\newcommand{\nuup}{\unicode{x03BD}}\)

\(\newcommand{\xiup}{\unicode{x03BE}}\)

\(\newcommand{\omicronup}{\unicode{x03BF}}\)

\(\newcommand{\piup}{\unicode{x03C0}}\)

\(\newcommand{\varpiup}{\unicode{x03D6}}\)

\(\newcommand{\rhoup}{\unicode{x03C1}}\)

\(\newcommand{\varrhoup}{\unicode{x03F1}}\)

\(\newcommand{\sigmaup}{\unicode{x03C3}}\)

\(\newcommand{\varsigmaup}{\unicode{x03C2}}\)

\(\newcommand{\tauup}{\unicode{x03C4}}\)

\(\newcommand{\upsilonup}{\unicode{x03C5}}\)

\(\newcommand{\phiup}{\unicode{x03D5}}\)

\(\newcommand{\varphiup}{\unicode{x03C6}}\)

\(\newcommand{\chiup}{\unicode{x03C7}}\)

\(\newcommand{\psiup}{\unicode{x03C8}}\)

\(\newcommand{\omegaup}{\unicode{x03C9}}\)

\(\newcommand{\Alphaup}{\unicode{x0391}}\)

\(\newcommand{\Betaup}{\unicode{x0392}}\)

\(\newcommand{\Gammaup}{\unicode{x0393}}\)

\(\newcommand{\Digammaup}{\unicode{x03DC}}\)

\(\newcommand{\Deltaup}{\unicode{x0394}}\)

\(\newcommand{\Epsilonup}{\unicode{x0395}}\)

\(\newcommand{\Zetaup}{\unicode{x0396}}\)

\(\newcommand{\Etaup}{\unicode{x0397}}\)

\(\newcommand{\Thetaup}{\unicode{x0398}}\)

\(\newcommand{\Varthetaup}{\unicode{x03F4}}\)

\(\newcommand{\Iotaup}{\unicode{x0399}}\)

\(\newcommand{\Kappaup}{\unicode{x039A}}\)

\(\newcommand{\Lambdaup}{\unicode{x039B}}\)

\(\newcommand{\Muup}{\unicode{x039C}}\)

\(\newcommand{\Nuup}{\unicode{x039D}}\)

\(\newcommand{\Xiup}{\unicode{x039E}}\)

\(\newcommand{\Omicronup}{\unicode{x039F}}\)

\(\newcommand{\Piup}{\unicode{x03A0}}\)

\(\newcommand{\Varpiup}{\unicode{x03D6}}\)

\(\newcommand{\Rhoup}{\unicode{x03A1}}\)

\(\newcommand{\Sigmaup}{\unicode{x03A3}}\)

\(\newcommand{\Tauup}{\unicode{x03A4}}\)

\(\newcommand{\Upsilonup}{\unicode{x03A5}}\)

\(\newcommand{\Phiup}{\unicode{x03A6}}\)

\(\newcommand{\Chiup}{\unicode{x03A7}}\)

\(\newcommand{\Psiup}{\unicode{x03A8}}\)

\(\newcommand{\Omegaup}{\unicode{x03A9}}\)

\(\newcommand{\alphait}{\unicode{x1D6FC}}\)

\(\newcommand{\betait}{\unicode{x1D6FD}}\)

\(\newcommand{\gammait}{\unicode{x1D6FE}}\)

\(\newcommand{\digammait}{\mathit{\unicode{x03DD}}}\)

\(\newcommand{\deltait}{\unicode{x1D6FF}}\)

\(\newcommand{\epsilonit}{\unicode{x1D716}}\)

\(\newcommand{\varepsilonit}{\unicode{x1D700}}\)

\(\newcommand{\zetait}{\unicode{x1D701}}\)

\(\newcommand{\etait}{\unicode{x1D702}}\)

\(\newcommand{\thetait}{\unicode{x1D703}}\)

\(\newcommand{\varthetait}{\unicode{x1D717}}\)

\(\newcommand{\iotait}{\unicode{x1D704}}\)

\(\newcommand{\kappait}{\unicode{x1D705}}\)

\(\newcommand{\varkappait}{\unicode{x1D718}}\)

\(\newcommand{\lambdait}{\unicode{x1D706}}\)

\(\newcommand{\muit}{\unicode{x1D707}}\)

\(\newcommand{\nuit}{\unicode{x1D708}}\)

\(\newcommand{\xiit}{\unicode{x1D709}}\)

\(\newcommand{\omicronit}{\unicode{x1D70A}}\)

\(\newcommand{\piit}{\unicode{x1D70B}}\)

\(\newcommand{\varpiit}{\unicode{x1D71B}}\)

\(\newcommand{\rhoit}{\unicode{x1D70C}}\)

\(\newcommand{\varrhoit}{\unicode{x1D71A}}\)

\(\newcommand{\sigmait}{\unicode{x1D70E}}\)

\(\newcommand{\varsigmait}{\unicode{x1D70D}}\)

\(\newcommand{\tauit}{\unicode{x1D70F}}\)

\(\newcommand{\upsilonit}{\unicode{x1D710}}\)

\(\newcommand{\phiit}{\unicode{x1D719}}\)

\(\newcommand{\varphiit}{\unicode{x1D711}}\)

\(\newcommand{\chiit}{\unicode{x1D712}}\)

\(\newcommand{\psiit}{\unicode{x1D713}}\)

\(\newcommand{\omegait}{\unicode{x1D714}}\)

\(\newcommand{\Alphait}{\unicode{x1D6E2}}\)

\(\newcommand{\Betait}{\unicode{x1D6E3}}\)

\(\newcommand{\Gammait}{\unicode{x1D6E4}}\)

\(\newcommand{\Digammait}{\mathit{\unicode{x03DC}}}\)

\(\newcommand{\Deltait}{\unicode{x1D6E5}}\)

\(\newcommand{\Epsilonit}{\unicode{x1D6E6}}\)

\(\newcommand{\Zetait}{\unicode{x1D6E7}}\)

\(\newcommand{\Etait}{\unicode{x1D6E8}}\)

\(\newcommand{\Thetait}{\unicode{x1D6E9}}\)

\(\newcommand{\Varthetait}{\unicode{x1D6F3}}\)

\(\newcommand{\Iotait}{\unicode{x1D6EA}}\)

\(\newcommand{\Kappait}{\unicode{x1D6EB}}\)

\(\newcommand{\Lambdait}{\unicode{x1D6EC}}\)

\(\newcommand{\Muit}{\unicode{x1D6ED}}\)

\(\newcommand{\Nuit}{\unicode{x1D6EE}}\)

\(\newcommand{\Xiit}{\unicode{x1D6EF}}\)

\(\newcommand{\Omicronit}{\unicode{x1D6F0}}\)

\(\newcommand{\Piit}{\unicode{x1D6F1}}\)

\(\newcommand{\Rhoit}{\unicode{x1D6F2}}\)

\(\newcommand{\Sigmait}{\unicode{x1D6F4}}\)

\(\newcommand{\Tauit}{\unicode{x1D6F5}}\)

\(\newcommand{\Upsilonit}{\unicode{x1D6F6}}\)

\(\newcommand{\Phiit}{\unicode{x1D6F7}}\)

\(\newcommand{\Chiit}{\unicode{x1D6F8}}\)

\(\newcommand{\Psiit}{\unicode{x1D6F9}}\)

\(\newcommand{\Omegait}{\unicode{x1D6FA}}\)

\(\let \digammaup \Digammaup \)

\(\renewcommand {\digammait }{\mathit {\digammaup }}\)

\(\newcommand {\smallin }{\unicode {x220A}}\)

\(\newcommand {\smallowns }{\unicode {x220D}}\)

\(\newcommand {\notsmallin }{\LWRoverlaysymbols {/}{\unicode {x220A}}}\)

\(\newcommand {\notsmallowns }{\LWRoverlaysymbols {/}{\unicode {x220D}}}\)

\(\newcommand {\rightangle }{\unicode {x221F}}\)

\(\newcommand {\intclockwise }{\unicode {x2231}}\)

\(\newcommand {\ointclockwise }{\unicode {x2232}}\)

\(\newcommand {\ointctrclockwise }{\unicode {x2233}}\)

\(\newcommand {\oiint }{\unicode {x222F}}\)

\(\newcommand {\oiiint }{\unicode {x2230}}\)

\(\newcommand {\ddag }{\unicode {x2021}}\)

\(\newcommand {\P }{\unicode {x00B6}}\)

\(\newcommand {\copyright }{\unicode {x00A9}}\)

\(\newcommand {\dag }{\unicode {x2020}}\)

\(\newcommand {\pounds }{\unicode {x00A3}}\)

\(\newcommand {\iddots }{\unicode {x22F0}}\)

\(\newcommand {\utimes }{\overline {\times }}\)

\(\newcommand {\dtimes }{\underline {\times }}\)

\(\newcommand {\udtimes }{\overline {\underline {\times }}}\)

\(\newcommand {\leftwave }{\left \{}\)

\(\newcommand {\rightwave }{\right \}}\)

\(\newcommand {\toprule }[1][]{\hline }\)

\(\let \midrule \toprule \)

\(\let \bottomrule \toprule \)

\(\newcommand {\cmidrule }[2][]{}\)

\(\newcommand {\morecmidrules }{}\)

\(\newcommand {\specialrule }[3]{\hline }\)

\(\newcommand {\addlinespace }[1][]{}\)

\(\newcommand {\LWRsubmultirow }[2][]{#2}\)

\(\newcommand {\LWRmultirow }[2][]{\LWRsubmultirow }\)

\(\newcommand {\multirow }[2][]{\LWRmultirow }\)

\(\newcommand {\mrowcell }{}\)

\(\newcommand {\mcolrowcell }{}\)

\(\newcommand {\STneed }[1]{}\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\newcommand {\tothe }[1]{^{#1}}\)

\(\newcommand {\raiseto }[2]{{#2}^{#1}}\)

\(\newcommand {\ang }[2][]{(\mathrm {#2})\degree }\)

\(\newcommand {\num }[2][]{\mathrm {#2}}\)

\(\newcommand {\si }[2][]{\mathrm {#2}}\)

\(\newcommand {\LWRSI }[2][]{\mathrm {#1\LWRSInumber \,#2}}\)

\(\newcommand {\SI }[2][]{\def \LWRSInumber {#2}\LWRSI }\)

\(\newcommand {\numlist }[2][]{\mathrm {#2}}\)

\(\newcommand {\numrange }[3][]{\mathrm {#2\,\unicode {x2013}\,#3}}\)

\(\newcommand {\SIlist }[3][]{\mathrm {#2\,#3}}\)

\(\newcommand {\SIrange }[4][]{\mathrm {#2\,#4\,\unicode {x2013}\,#3\,#4}}\)

\(\newcommand {\tablenum }[2][]{\mathrm {#2}}\)

\(\newcommand {\ampere }{\mathrm {A}}\)

\(\newcommand {\candela }{\mathrm {cd}}\)

\(\newcommand {\kelvin }{\mathrm {K}}\)

\(\newcommand {\kilogram }{\mathrm {kg}}\)

\(\newcommand {\metre }{\mathrm {m}}\)

\(\newcommand {\mole }{\mathrm {mol}}\)

\(\newcommand {\second }{\mathrm {s}}\)

\(\newcommand {\becquerel }{\mathrm {Bq}}\)

\(\newcommand {\degreeCelsius }{\unicode {x2103}}\)

\(\newcommand {\coulomb }{\mathrm {C}}\)

\(\newcommand {\farad }{\mathrm {F}}\)

\(\newcommand {\gray }{\mathrm {Gy}}\)

\(\newcommand {\hertz }{\mathrm {Hz}}\)

\(\newcommand {\henry }{\mathrm {H}}\)

\(\newcommand {\joule }{\mathrm {J}}\)

\(\newcommand {\katal }{\mathrm {kat}}\)

\(\newcommand {\lumen }{\mathrm {lm}}\)

\(\newcommand {\lux }{\mathrm {lx}}\)

\(\newcommand {\newton }{\mathrm {N}}\)

\(\newcommand {\ohm }{\mathrm {\Omega }}\)

\(\newcommand {\pascal }{\mathrm {Pa}}\)

\(\newcommand {\radian }{\mathrm {rad}}\)

\(\newcommand {\siemens }{\mathrm {S}}\)

\(\newcommand {\sievert }{\mathrm {Sv}}\)

\(\newcommand {\steradian }{\mathrm {sr}}\)

\(\newcommand {\tesla }{\mathrm {T}}\)

\(\newcommand {\volt }{\mathrm {V}}\)

\(\newcommand {\watt }{\mathrm {W}}\)

\(\newcommand {\weber }{\mathrm {Wb}}\)

\(\newcommand {\day }{\mathrm {d}}\)

\(\newcommand {\degree }{\mathrm {^\circ }}\)

\(\newcommand {\hectare }{\mathrm {ha}}\)

\(\newcommand {\hour }{\mathrm {h}}\)

\(\newcommand {\litre }{\mathrm {l}}\)

\(\newcommand {\liter }{\mathrm {L}}\)

\(\newcommand {\arcminute }{^\prime }\)
\(\newcommand {\minute }{\mathrm {min}}\)

\(\newcommand {\arcsecond }{^{\prime \prime }}\)

\(\newcommand {\tonne }{\mathrm {t}}\)

\(\newcommand {\astronomicalunit }{au}\)

\(\newcommand {\atomicmassunit }{u}\)

\(\newcommand {\bohr }{\mathit {a}_0}\)

\(\newcommand {\clight }{\mathit {c}_0}\)

\(\newcommand {\dalton }{\mathrm {D}_\mathrm {a}}\)

\(\newcommand {\electronmass }{\mathit {m}_{\mathrm {e}}}\)

\(\newcommand {\electronvolt }{\mathrm {eV}}\)

\(\newcommand {\elementarycharge }{\mathit {e}}\)

\(\newcommand {\hartree }{\mathit {E}_{\mathrm {h}}}\)

\(\newcommand {\planckbar }{\mathit {\unicode {x210F}}}\)

\(\newcommand {\angstrom }{\mathrm {\unicode {x212B}}}\)

\(\let \LWRorigbar \bar \)

\(\newcommand {\bar }{\mathrm {bar}}\)

\(\newcommand {\barn }{\mathrm {b}}\)

\(\newcommand {\bel }{\mathrm {B}}\)

\(\newcommand {\decibel }{\mathrm {dB}}\)

\(\newcommand {\knot }{\mathrm {kn}}\)

\(\newcommand {\mmHg }{\mathrm {mmHg}}\)

\(\newcommand {\nauticalmile }{\mathrm {M}}\)

\(\newcommand {\neper }{\mathrm {Np}}\)

\(\newcommand {\yocto }{\mathrm {y}}\)

\(\newcommand {\zepto }{\mathrm {z}}\)

\(\newcommand {\atto }{\mathrm {a}}\)

\(\newcommand {\femto }{\mathrm {f}}\)

\(\newcommand {\pico }{\mathrm {p}}\)

\(\newcommand {\nano }{\mathrm {n}}\)

\(\newcommand {\micro }{\mathrm {\unicode {x00B5}}}\)

\(\newcommand {\milli }{\mathrm {m}}\)

\(\newcommand {\centi }{\mathrm {c}}\)

\(\newcommand {\deci }{\mathrm {d}}\)

\(\newcommand {\deca }{\mathrm {da}}\)

\(\newcommand {\hecto }{\mathrm {h}}\)

\(\newcommand {\kilo }{\mathrm {k}}\)

\(\newcommand {\mega }{\mathrm {M}}\)

\(\newcommand {\giga }{\mathrm {G}}\)

\(\newcommand {\tera }{\mathrm {T}}\)

\(\newcommand {\peta }{\mathrm {P}}\)

\(\newcommand {\exa }{\mathrm {E}}\)

\(\newcommand {\zetta }{\mathrm {Z}}\)

\(\newcommand {\yotta }{\mathrm {Y}}\)

\(\newcommand {\percent }{\mathrm {\%}}\)

\(\newcommand {\meter }{\mathrm {m}}\)

\(\newcommand {\metre }{\mathrm {m}}\)

\(\newcommand {\gram }{\mathrm {g}}\)

\(\newcommand {\kg }{\kilo \gram }\)

\(\newcommand {\of }[1]{_{\mathrm {#1}}}\)

\(\newcommand {\squared }{^2}\)

\(\newcommand {\square }[1]{\mathrm {#1}^2}\)

\(\newcommand {\cubed }{^3}\)

\(\newcommand {\cubic }[1]{\mathrm {#1}^3}\)

\(\newcommand {\per }{/}\)

\(\newcommand {\celsius }{\unicode {x2103}}\)

\(\newcommand {\fg }{\femto \gram }\)

\(\newcommand {\pg }{\pico \gram }\)

\(\newcommand {\ng }{\nano \gram }\)

\(\newcommand {\ug }{\micro \gram }\)

\(\newcommand {\mg }{\milli \gram }\)

\(\newcommand {\g }{\gram }\)

\(\newcommand {\kg }{\kilo \gram }\)

\(\newcommand {\amu }{\mathrm {u}}\)

\(\newcommand {\nm }{\nano \metre }\)

\(\newcommand {\um }{\micro \metre }\)

\(\newcommand {\mm }{\milli \metre }\)

\(\newcommand {\cm }{\centi \metre }\)

\(\newcommand {\dm }{\deci \metre }\)

\(\newcommand {\m }{\metre }\)

\(\newcommand {\km }{\kilo \metre }\)

\(\newcommand {\as }{\atto \second }\)

\(\newcommand {\fs }{\femto \second }\)

\(\newcommand {\ps }{\pico \second }\)

\(\newcommand {\ns }{\nano \second }\)

\(\newcommand {\us }{\micro \second }\)

\(\newcommand {\ms }{\milli \second }\)

\(\newcommand {\s }{\second }\)

\(\newcommand {\fmol }{\femto \mol }\)

\(\newcommand {\pmol }{\pico \mol }\)

\(\newcommand {\nmol }{\nano \mol }\)

\(\newcommand {\umol }{\micro \mol }\)

\(\newcommand {\mmol }{\milli \mol }\)

\(\newcommand {\mol }{\mol }\)

\(\newcommand {\kmol }{\kilo \mol }\)

\(\newcommand {\pA }{\pico \ampere }\)

\(\newcommand {\nA }{\nano \ampere }\)

\(\newcommand {\uA }{\micro \ampere }\)

\(\newcommand {\mA }{\milli \ampere }\)

\(\newcommand {\A }{\ampere }\)

\(\newcommand {\kA }{\kilo \ampere }\)

\(\newcommand {\ul }{\micro \litre }\)

\(\newcommand {\ml }{\milli \litre }\)

\(\newcommand {\l }{\litre }\)

\(\newcommand {\hl }{\hecto \litre }\)

\(\newcommand {\uL }{\micro \liter }\)

\(\newcommand {\mL }{\milli \liter }\)

\(\newcommand {\L }{\liter }\)

\(\newcommand {\hL }{\hecto \liter }\)

\(\newcommand {\mHz }{\milli \hertz }\)

\(\newcommand {\Hz }{\hertz }\)

\(\newcommand {\kHz }{\kilo \hertz }\)

\(\newcommand {\MHz }{\mega \hertz }\)

\(\newcommand {\GHz }{\giga \hertz }\)

\(\newcommand {\THz }{\tera \hertz }\)

\(\newcommand {\mN }{\milli \newton }\)

\(\newcommand {\N }{\newton }\)

\(\newcommand {\kN }{\kilo \newton }\)

\(\newcommand {\MN }{\mega \newton }\)

\(\newcommand {\Pa }{\pascal }\)

\(\newcommand {\kPa }{\kilo \pascal }\)

\(\newcommand {\MPa }{\mega \pascal }\)

\(\newcommand {\GPa }{\giga \pascal }\)

\(\newcommand {\mohm }{\milli \ohm }\)

\(\newcommand {\kohm }{\kilo \ohm }\)

\(\newcommand {\Mohm }{\mega \ohm }\)

\(\newcommand {\pV }{\pico \volt }\)

\(\newcommand {\nV }{\nano \volt }\)

\(\newcommand {\uV }{\micro \volt }\)

\(\newcommand {\mV }{\milli \volt }\)

\(\newcommand {\V }{\volt }\)

\(\newcommand {\kV }{\kilo \volt }\)

\(\newcommand {\W }{\watt }\)

\(\newcommand {\uW }{\micro \watt }\)

\(\newcommand {\mW }{\milli \watt }\)

\(\newcommand {\kW }{\kilo \watt }\)

\(\newcommand {\MW }{\mega \watt }\)

\(\newcommand {\GW }{\giga \watt }\)

\(\newcommand {\J }{\joule }\)

\(\newcommand {\uJ }{\micro \joule }\)

\(\newcommand {\mJ }{\milli \joule }\)

\(\newcommand {\kJ }{\kilo \joule }\)

\(\newcommand {\eV }{\electronvolt }\)

\(\newcommand {\meV }{\milli \electronvolt }\)

\(\newcommand {\keV }{\kilo \electronvolt }\)

\(\newcommand {\MeV }{\mega \electronvolt }\)

\(\newcommand {\GeV }{\giga \electronvolt }\)

\(\newcommand {\TeV }{\tera \electronvolt }\)

\(\newcommand {\kWh }{\kilo \watt \hour }\)

\(\newcommand {\F }{\farad }\)

\(\newcommand {\fF }{\femto \farad }\)

\(\newcommand {\pF }{\pico \farad }\)

\(\newcommand {\K }{\mathrm {K}}\)

\(\newcommand {\dB }{\mathrm {dB}}\)

\(\newcommand {\kibi }{\mathrm {Ki}}\)

\(\newcommand {\mebi }{\mathrm {Mi}}\)

\(\newcommand {\gibi }{\mathrm {Gi}}\)

\(\newcommand {\tebi }{\mathrm {Ti}}\)

\(\newcommand {\pebi }{\mathrm {Pi}}\)

\(\newcommand {\exbi }{\mathrm {Ei}}\)

\(\newcommand {\zebi }{\mathrm {Zi}}\)

\(\newcommand {\yobi }{\mathrm {Yi}}\)

\(\require {mhchem}\)

\(\require {cancel}\)

\(\newcommand {\fint }{âĺŊ}\)

\(\newcommand {\hdots }{\cdots }\)

\(\newcommand {\mathnormal }[1]{#1}\)

\(\newcommand {\vecs }[2]{\vec {#1}_{#2}}\)

\(\newcommand {\Start }{\ensuremath {\text {Start}}}\)

\(\newcommand {\Accept }{\ensuremath {\text {Accept}}}\)

\(\newcommand {\kod }[1]{\ensuremath {\left \langle #1\right \rangle }}\)

\(\newcommand {\TM }{\ensuremath {\text {TM}}}\)

\(\newcommand {\bb }{\ensuremath {\text {bb}}}\)

\(\newcommand {\pb }{\ensuremath {\text {pb}}}\)

\(\renewcommand {\succ }{\ensuremath {\text {succ}}}\)

\(\newcommand {\pr }{\ensuremath {\mathbb {P}}}\)

\(\newcommand {\rec }{\ensuremath {\text {rec}}}\)

\(\newcommand {\IMP }{\ensuremath {\text {IMP}}}\)

\(\newcommand {\true }{\ensuremath {\text {true}}}\)

\(\newcommand {\false }{\ensuremath {\text {false}}}\)

\(\newcommand {\Loc }{\ensuremath {\text {Loc}}}\)

\(\newcommand {\Aexp }{\ensuremath {\text {Aexp}}}\)

\(\newcommand {\Bexp }{\ensuremath {\text {Bexp}}}\)

\(\newcommand {\Cmd }{\ensuremath {\text {Cmd}}}\)

\(\newcommand {\dollar }{\ensuremath {\$}}\)

\(\newcommand {\var }{\ensuremath {\text {var}}}\)

\(\newcommand {\frei }{\ensuremath {\text {frei}}}\)

\(\newcommand {\add }{\ensuremath {\text {add}}}\)

\(\newcommand {\Conf }{\ensuremath {\text {Conf}}}\)

\(\newcommand {\TAUT }{\ensuremath {\text {TAUT}}}\)

\(\newcommand {\opt }{\ensuremath {\text {opt}}}\)

\(\newcommand {\Var }{\ensuremath {\text {Var}}}\)

\(\newcommand {\SAT }{\ensuremath {\text {SAT}}}\)

\(\newcommand {\kSAT }[1]{\ensuremath {#1\text {-SAT}}}\)

\(\newcommand {\KNF }{\ensuremath {\text {KNF}}}\)

\(\newcommand {\kKNF }[1]{\ensuremath {#1\text {-KNF}}}\)

\(\newcommand {\DNF }{\ensuremath {\text {DNF}}}\)

\(\newcommand {\HORN }{\ensuremath {\text {HORN}}}\)

\(\newcommand {\HORNSAT }{\ensuremath {\text {HORNSAT}}}\)

\(\newcommand {\DTIME }{\ensuremath {\mathbf {DTIME}}}\)

\(\newcommand {\NTIME }{\ensuremath {\mathbf {NTIME}}}\)

\(\newcommand {\XTIME }{\ensuremath {\mathbf {XTIME}}}\)

\(\newcommand {\DSPACE }{\ensuremath {\mathbf {DSPACE}}}\)

\(\newcommand {\NSPACE }{\ensuremath {\mathbf {NSPACE}}}\)

\(\newcommand {\XSPACE }{\ensuremath {\mathbf {XSPACE}}}\)

\(\newcommand {\Co }{\ensuremath {\mathbf {Co}}}\)

\(\renewcommand {\L }{\ensuremath {\mathbf {L}}}\)

\(\newcommand {\NL }{\ensuremath {\mathbf {NL}}}\)

\(\renewcommand {\P }{\ensuremath {\mathbf {P}}}\)

\(\newcommand {\NP }{\ensuremath {\mathbf {NP}}}\)

\(\newcommand {\PSPACE }{\ensuremath {\mathbf {PSPACE}}}\)

\(\newcommand {\NPSPACE }{\ensuremath {\mathbf {NPSPACE}}}\)

\(\newcommand {\CS }{\ensuremath {\mathbf {CS}}}\)

\(\newcommand {\LBA }{\ensuremath {\mathbf {LBA}}}\)

\(\newcommand {\LinProg }{\ensuremath {\text {LinProg}}}\)

\(\newcommand {\VC }{\ensuremath {\text {VC}}}\)

\(\newcommand {\NAE }{\ensuremath {\text {NAE}}}\)

\(\newcommand {\NAESAT }{\ensuremath {\text {NAE-SAT}}}\)

\(\newcommand {\NAEkSAT }[1]{\ensuremath {\text {NAE-}#1\text {-SAT}}}\)

\(\newcommand {\kFaerbbarkeit }[1]{\ensuremath {#1\text {-Färbbarkeit}}}\)

\(\newcommand {\red }{\ensuremath {\text {r}}}\)

\(\newcommand {\green }{\ensuremath {\text {g}}}\)

\(\newcommand {\blue }{\ensuremath {\text {b}}}\)

\(\newcommand {\Rucksack }{\ensuremath {\text {Rucksack}}}\)

\(\newcommand {\SubsetSum }{\ensuremath {\text {Subset-Sum}}}\)

\(\newcommand {\QBF }{\ensuremath {\text {QBF}}}\)

\(\renewcommand {\A }{\ensuremath {\mathcal {A}}}\)

\(\newcommand {\B }{\ensuremath {\mathbb {B}}}\)

\(\renewcommand {\C }{\ensuremath {\mathcal {C}}}\)

\(\renewcommand {\F }{\ensuremath {\mathcal {F}}}\)

\(\newcommand {\I }{\ensuremath {\mathcal {I}}}\)

\(\renewcommand {\O }{\ensuremath {\mathcal {O}}}\)

\(\newcommand {\PS }{\ensuremath {\mathcal {P}}}\)

\(\newcommand {\R }{\ensuremath {\mathcal {R}}}\)

\(\renewcommand {\V }{\ensuremath {\mathbb {V}}}\)

\(\newcommand {\FOR }{\ensuremath {\mathbf {for}\;}}\)

\(\newcommand {\FORALL }{\ensuremath {\mathbf {forall}\;}}\)

\(\newcommand {\WHILE }{\ensuremath {\mathbf {while}\;}}\)

\(\newcommand {\UNTIL }{\ensuremath {\mathbf {until}\;}}\)

\(\newcommand {\OR }{\ensuremath {\mathbf {or}\;}}\)

\(\newcommand {\IF }{\ensuremath {\mathbf {if}\;}}\)

\(\newcommand {\THEN }{\ensuremath {\mathbf {then}\;}}\)

\(\newcommand {\ELSE }{\ensuremath {\mathbf {else}\;}}\)

\(\newcommand {\END }{\ensuremath {\mathbf {end}\;}}\)

\(\newcommand {\TO }{\ensuremath {\mathbf {to}\;}}\)

\(\newcommand {\DO }{\ensuremath {\mathbf {do}\;}}\)

\(\newcommand {\RETURN }{\ensuremath {\mathbf {return}\;}}\)

\(\newcommand {\TRUE }{\ensuremath {\mathbf {true}}}\)

\(\newcommand {\FALSE }{\ensuremath {\mathbf {false}}}\)

\(\newcommand {\name }[1]{\textsc {#1}}\)

\(\newcommand {\smallpmatrix }[1]{\left (\begin {smallmatrix}#1\end {smallmatrix}\right )}\)

\(\newcommand {\matlab }{{\fontfamily {bch}\scshape \selectfont {}Matlab}}\)

\(\newcommand {\innerproduct }[1]{\left \langle {#1}\right \rangle }\)

\(\newcommand {\norm }[1]{\left \Vert {#1}\right \Vert }\)

\(\renewcommand {\natural }{\mathbb {N}}\)

\(\newcommand {\integer }{\mathbb {Z}}\)

\(\newcommand {\rational }{\mathbb {Q}}\)

\(\newcommand {\real }{\mathbb {R}}\)

\(\newcommand {\complex }{\mathbb {C}}\)

\(\renewcommand {\d }{\mathop {}\!\mathrm {d}}\)

\(\newcommand {\dr }{\d {}r}\)

\(\newcommand {\ds }{\d {}s}\)

\(\newcommand {\dt }{\d {}t}\)

\(\newcommand {\du }{\d {}u}\)

\(\newcommand {\dv }{\d {}v}\)

\(\newcommand {\dw }{\d {}w}\)

\(\newcommand {\dx }{\d {}x}\)

\(\newcommand {\dy }{\d {}y}\)

\(\newcommand {\dz }{\d {}z}\)

\(\newcommand {\dsigma }{\d {}\sigma }\)

\(\newcommand {\dphi }{\d {}\phi }\)

\(\newcommand {\dvarphi }{\d {}\varphi }\)

\(\newcommand {\dtau }{\d {}\tau }\)

\(\newcommand {\dxi }{\d {}\xi }\)

\(\newcommand {\dtheta }{\d {}\theta }\)

\(\newcommand {\tp }{\mathrm {T}}\)

</div>

<style type="text/css">
.lwarp-contents li.list-item-f0::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f1::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f2::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f3::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f4::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f5::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f6::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f7::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f8::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f9::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f10::marker {
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f11::marker {
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f12::marker {
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f13::marker {
  content:'(4)\00a0\00a0';
}
.lwarp-contents li.list-item-f14::marker {
  content:'(5)\00a0\00a0';
}
.lwarp-contents li.list-item-f15::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f16::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f17::marker {
  content:'–\00a0\00a0';
}
.lwarp-contents li.list-item-f18::marker {
  content:'–\00a0\00a0';
}
.lwarp-contents li.list-item-f19::marker {
  content:'–\00a0\00a0';
}
.lwarp-contents li.list-item-f20::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f21::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f22::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f23::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f24::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f25::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f26::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f27::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f28::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f29::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f30::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f31::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f32::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f33::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f34::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f35::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f36::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f37::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f38::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f39::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f40::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f41::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f42::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f43::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f44::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f45::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f46::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f47::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f48::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f49::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f50::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f51::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f52::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f53::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f54::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f55::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f56::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f57::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f58::marker {
  content:'•\00a0\00a0';
}
</style>
<p>

</p>



<h2 id="turingmaschinen"><span style="font-variant: small-caps;">Turing</span>maschinen</h2>

</p>


<p>
<b>Einband-<span class="textsc" >Turing</span>maschine</b>:&#x2003; Eine <em><span class="dashuline" >(nicht-deterministische) Einband-<span class="textsc" >Turing</span>maschine<br />
(TM)</span></em> ist ein \(7\)-Tupel \(M = (Q, \Sigma , \Gamma , \delta , q_0, F, \Box )\), wobei
</p>
<ul style="list-style-type:none">

<li class="list-item-f0"><p>\(Q\) eine endliche, nicht-leere Menge (die Menge der <em><span class="dashuline" >Zusta&#x0308;nde</span></em>),
</p>
</li>
<li class="list-item-f1"><p>\(\Sigma \) eine endliche, nicht-leere Menge mit \(Q \cap \Sigma = \emptyset \) (das <em><span class="dashuline" >Eingabealphabet</span></em>),
</p>
</li>
<li class="list-item-f2"><p>\(\Gamma \supset \Sigma \) eine endliche, nicht-leere Menge mit \(Q \cap \Gamma = \emptyset \) (das <em><span class="dashuline" >Bandalphabet</span></em>),
</p>
</li>
<li class="list-item-f3"><p>\(\delta \subset Q \times \Gamma \times Q \times \Gamma \times \{L, R, N\}\) (die <em><span class="dashuline" >U&#x0308;bergangsrelation</span></em>),
</p>
</li>
<li class="list-item-f4"><p>\(q_0 \in Q\) (der <em><span class="dashuline" >Startzustand</span></em>),
</p>
</li>
<li class="list-item-f5"><p>\(F \subset Q\) (die <em><span class="dashuline" >akzeptierenden Endzusta&#x0308;nde</span></em>) und
</p>
</li>
<li class="list-item-f6"><p>\(\Box \in \Gamma \setminus \Sigma \) (das <em><span class="dashuline" >Blanksymbol</span></em>) ist.
</p>
</li>
</ul>

<p>
Die TM heißt <em><span class="dashuline" >deterministisch</span></em>, falls aus \((p, a, q, b, D) \in \delta \) und \((p, a, q’, b’, D’) \in \delta \) stets folgt, dass \((q, b, D) = (q’, b’, D’)\). In diesem
Fall ist \(\delta \colon Q \times \Gamma \rightarrow _p Q \times \Gamma \times \{L, R, N\}\) eine partiell definierte <em><span class="dashuline" >U&#x0308;bergangsfunktion</span></em>.
</p>

<p>
<b>Mehrband-<span class="textsc" >Turing</span>maschine</b>:&#x2003; Eine <em><span class="dashuline" >(nicht-deterministische) Mehrband-<span class="textsc" >Turing</span>maschine (TM) mit \(k\)
Arbeitsba&#x0308;ndern</span></em> ist ein \(7\)-Tupel \(M = (Q, \Sigma , \Gamma , \delta , q_0, F, \Box )\), wobei \(Q\), \(\Sigma \), \(\Gamma \), \(q_0\), \(F\) und \(\Box \) wie bei einer Einband-TM definiert
sind und fu&#x0308;r die <em><span class="dashuline" >U&#x0308;bergangsrelation</span></em><br />
\(\delta \subset Q \times (\Sigma \cup \{\Box \}) \times \Gamma ^k \times Q \times \Gamma ^k \times \{L, R, N\}^{k+1}\) gilt.<br />
Die TM heißt <em><span class="dashuline" >deterministisch</span></em>, falls aus \((p, a, b, q, c, D) \in \delta \) und \((p, a, b, q’, c’, D’) \in \delta \) stets folgt, dass \((q, c, D) = (q’, c’, D’)\). In
diesem Fall ist \(\delta \colon Q \times (\Sigma \cup \{\Box \}) \times \Gamma ^k \rightarrow _p Q \times \Gamma ^k \times \{L, R, N\}^{k+1}\) eine partiell definierte <em><span class="dashuline"
>U&#x0308;bergangsfunktion</span></em>.<br />
Soll \(M\) eine Funktion berechnen, so hat \(M\) zusa&#x0308;tzlich ein Ausgabealphabet \(\Sigma ’\) und fu&#x0308;r \(\delta \) gilt \(\delta \subset Q \times (\Sigma \cup \{\Box \}) \times \Gamma ^k \times Q
\times \Gamma ^k \times \{L, R, N\}^{k+1} \times (\Sigma ’ \cup \{\varepsilon \})\) bzw.<br />
\(\delta \colon Q \times (\Sigma \cup \{\Box \}) \times \Gamma ^k \rightarrow _p Q \times \Gamma ^k \times \{L, R, N\}^{k+1} \times (\Sigma ’ \cup \{\varepsilon \})\).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Konfiguration einer Einband-TM</b>:&#x2003; Eine <em><span class="dashuline" >Konfiguration</span></em> \(\alpha \) einer Einband-TM<br />
\(M = (Q, \Sigma , \Gamma , \delta , q_0, F, \Box )\) ist \(\alpha = uqv \in \Gamma ^\ast Q \Gamma ^+\) (\(q\) aktueller Zustand von \(M\), \(uv\) Bandinhalt und Lese-/Schreibkopf steht auf dem ersten Buchstaben
von \(v\)).<br />
Die <em><span class="dashuline" >La&#x0308;nge</span></em> von \(\alpha \) ist \(|\alpha | := |uv|\).
</p>

<p>
<b>Konfiguration einer Mehrband-TM</b>:&#x2003; Eine <em><span class="dashuline" >Konfiguration</span></em> \(\alpha \) einer<br />
Mehrband-TM \(M = (Q, \Sigma , \Gamma , \delta , q_0, F, \Box )\) mit \(k\) Arbeitsba&#x0308;ndern ist ein Tupel<br />
\(\alpha = (q, u_0, v_0, u_1, v_1, \dotsc , u_k, v_k)\) mit
</p>
<ul style="list-style-type:none">

<li class="list-item-f7"><p>\(q \in Q\) (dem aktuellen Zustand der TM),
</p>
</li>
<li class="list-item-f8"><p>\(u_0 v_0 = w \Box \), \(|v_0| \ge 1\) (der Lesekopf fu&#x0308;r das Eingabeband steht auf dem ersten Buchstaben von \(v_0\)) und
</p>
</li>
<li class="list-item-f9"><p>\(u_i \in \Gamma ^\ast \), \(v_i \in \Gamma ^+\) fu&#x0308;r \(i = 1, \dotsc , k\) (das \(i\)-te Arbeitsband hat den Inhalt \(u_i v_i \Box \dotsb \) und der \(i\)-te Schreib-/Lesekopf steht auf dem ersten
Buchstaben von \(v_i\)).
</p>
</li>
</ul>

<p>
Die <em><span class="dashuline" >La&#x0308;nge</span></em> von \(\alpha \) ist \(|\alpha | := \max _{i = 1, \dotsc , k} |u_i v_i|\).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Startkonfiguration</b>:&#x2003; Fu&#x0308;r die Eingabe \(w \in \Sigma ^\ast \) ist \(\Start (w) := q_0 w \Box \) fu&#x0308;r Einband- und<br />
\(\Start (w) := (q_0, \varepsilon , w\Box , \varepsilon , \Box , \dotsc , \varepsilon , \Box )\) fu&#x0308;r Mehrband-TM die zugeho&#x0308;rige <em><span class="dashuline"
>Startkonfiguration</span></em>.
</p>

<p>
<b>akzeptierende Konfiguration</b>:&#x2003;<br />
\(\Accept \) ist die Menge der <em><span class="dashuline" >akzeptierenden Konfigurationen</span></em>, d.&#x202f;h. der aktuelle Zustand ist aus \(F\).
</p>

<p>
<b>U&#x0308;bergang</b>:&#x2003; Seien \(\alpha \) und \(\beta \) Konfigurationen. Man schreibt \(\alpha \vdash \beta \), falls es einen U&#x0308;bergang \(d \in \delta \) gibt, sodass \(\alpha \) in \(\beta \)
u&#x0308;berfu&#x0308;hrt werden kann. Eine Sonderregel sorgt dafu&#x0308;r, dass links und rechts auf den Ba&#x0308;ndern beliebig viele Leerzeichen \(\Box \) erzeugt werden ko&#x0308;nnen. Mit \(\vdash ^\ast \)
bezeichnet man den reflexiven und transitiven Abschluss von \(\vdash \).
</p>

<p>
<b>Rechnung</b>:&#x2003; Eine <em><span class="dashuline" >Rechnung</span></em> von \(M\) bei Eingabe \(w\) ist eine Folge von Konfigurationen<br />
\((\alpha _0, \dotsc , \alpha _m)\) mit \(\alpha _0 = \Start (w)\) und \(\alpha _{i-1} \vdash \alpha _i\) fu&#x0308;r \(i = 1, \dotsc , m\). Die Berechnung ist <em><span class="dashuline"
>erfolgreich</span></em>, falls \(\alpha _m \in \Accept \).
</p>

<p>
<b>Zeitbedarf</b>:&#x2003; Der <em><span class="dashuline" >Zeitbedarf</span></em> der Berechnung \((\alpha _0, \dotsc , \alpha _m)\) ist \(m\).
</p>

<p>
<b>Platzbedarf</b>:&#x2003; Der <em><span class="dashuline" >Platzbedarf</span></em> der Berechnung \((\alpha _0, \dotsc , \alpha _m)\) ist \(\max _{i = 0, \dotsc , m} |\alpha _i|\).
</p>

<p>
<b>akzeptierte Sprache</b>:&#x2003; Die <em><span class="dashuline" >akzeptierte Sprache</span></em> einer Einband-TM ist<br />
\(L(M) := \{w \in \Sigma ^\ast \;|\; \exists _{u \in \Gamma ^\ast ,\; q_f \in F,\; v \in \Gamma ^+}\; \Start (w) \vdash ^\ast u q_f v\}\).<br />
Allgemein ist \(L(M) := \{w \in \Sigma ^\ast \;|\; \exists \text {erfolgreiche Berechnung von } M \text { bei Eingabe } w\}\).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >A&#x0308;quivalenz von Einband- und Mehrband-TM</span>):</span><br />
Jede Mehrband-TM kann durch eine Einband-TM simuliert werden.
</p>

<p>
<b>Beweis</b>: Man benutzt Spurtechnik, d.&#x202f;h. man unterteilt das Arbeitsband der Einband-TM in \(2k\) Spuren (wenn die Mehrband-TM \(k\) Ba&#x0308;ndern besitzt). Auf den ungeraden Spuren stehen die Inhalte der
verschiedenen Ba&#x0308;nder. Auf den geraden Spuren stehen an den entsprechenden Stellen spezielle Symbole (z.&#x202f;B. Sterne), um die aktuelle Position des \(k\)-ten Schreib-/Lesekopfs zu speichern. Durch eine
genu&#x0308;gend hohe Zahl von Zusta&#x0308;nden kann sich die TM „merken“, welcher \(\delta \)-U&#x0308;bergang anzuwenden ist, nachdem sie alle Sterne von links nach rechts gelesen hat. &#x2003;&#x2003;
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >A&#x0308;quivalenz von nicht-det. und det. TM</span>):</span><br />
Jede nicht-deterministische TM kann durch eine deterministische TM simuliert werden.
</p>

<p>
<b>Beweis</b>: Die deterministische TM fu&#x0308;hrt eine Breitensuche im Graphen der mo&#x0308;glichen Konfigurationen der nicht-deterministischen TM durch. Die Wurzel ist \(\Start (w)\), die Knotenmenge ist \(K =
\{uqv \;|\; u \in \Gamma ^\ast ,\; q \in Q,\; v \in \Gamma ^+\}\) (i.&#x202f;A. unendlich) und die Kantenmenge \(E = \{\alpha \vdash \beta \;|\; \alpha , \beta \in K\}\) entspricht den
Einschrittu&#x0308;berga&#x0308;ngen. Es gilt \(w \in L(M)\) genau dann, wenn es einen Weg von der Wurzel \(\Start (w)\) zum einer akzeptierenden Konfiguration gibt, d.&#x202f;h. \(\Start (w) \vdash ^\ast \alpha
\in \Accept \). In diesem Fall akzeptiert die deterministische TM in endlicher Zeit, andernfalls terminiert sie nicht. &#x2003;&#x2003;
</p>



<h2 id="berechenbarkeit-und-entscheidbarkeit">Berechenbarkeit und Entscheidbarkeit</h2>

</p>


<p>
<b>(intuitiv) berechenbar</b>:&#x2003; Sei \(f\colon T \subset \natural ^k \rightarrow \natural \) eine Funktion.<br />
Ein Algorithmus \(P\) <em><span class="dashuline" >berechnet</span></em> die Funktion \(f\), falls \(P\) bei Eingabe von beliebigen \((n_1, \dotsc , n_k) \in T\) nach einer endlichen Zahl von Schritten den Wert
\(f(n_1, \dotsc , n_k)\) ausgibt und bei Eingabe von \((n_1, \dotsc , n_k) \in \natural ^k \setminus T\) nicht terminiert.<br />
Die Funktion \(f\) heißt <em><span class="dashuline" >berechenbar</span></em>, falls es einen Algorithmus \(P\) gibt, der \(f\) berechnet.
</p>

<p>
<em>Beispiel</em>: Ein Algorithmus, der unabha&#x0308;ngig von der Eingabe sofort in eine Endlosschleife geht, berechnet die total undefinierte Funktion.<br />
Die Funktion \(f(n) = 1\) fu&#x0308;r „\(n\) ist Beginn der Dezimalentwicklung von \(\pi \)“ und \(f(n) = 0\) sonst ist berechenbar, da es Na&#x0308;herungsverfahren fu&#x0308;r die Zahl \(\pi \) gibt, die \(\pi \)
beliebig genau ausrechnen ko&#x0308;nnen (geben beliebig, aber endlich viele Dezimalstellen von \(\pi \) aus).<br />
Die Funktion \(g(n) = 1\) fu&#x0308;r „\(n\) kommt in der Dezimalentwicklung von \(\pi \) vor“ und \(g(n) = 0\) sonst ist evtl. nicht berechenbar, da man zu wenig u&#x0308;ber die Verteilung von Ziffern in \(\pi \)
weiß.<br />
Die Funktion \(h(n) = 1\) fu&#x0308;r „\(7 \dotsb 7\) (\(n\)-mal) kommt in der Dezimalentwicklung von \(\pi \) vor“ und \(g(n) = 0\) sonst ist dagegen berechenbar: Entweder es gibt beliebig lange \(7\)-er-Folgen in der
Dezimalentwicklung von \(\pi \) (dann ist die Funktion konstant 1, also berechenbar) oder es gibt \(7\)-er-Folgen bis zur La&#x0308;nge \(n_0\), aber keine la&#x0308;ngeren (dann ist \(h(n) = 1\) fu&#x0308;r \(n \le
n_0\) und \(h(n) = 0\) fu&#x0308;r \(n &gt; n_0\) berechenbar). Die Definition von Berechenbarkeit verlangt nicht die explizite Angabe eines Algorithmus.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Kodierung</b>:&#x2003; Eine <em><span class="dashuline" >(Bina&#x0308;r-)Kodierung</span></em> einer Menge \(T\) ist eine injektive Abbildung<br />
\(c\colon T \rightarrow \{0, 1\}^\ast \). Fu&#x0308;r ein Element \(x \in T\) schreibt man auch \(\kod {x} := c(x)\).
</p>

<p>
<b><span class="textsc" >Turing</span>-berechenbar</b>:&#x2003;<br />
Eine Funktion \(f\colon \natural ^k \rightarrow \natural \) heißt <em><span class="dashuline" ><span class="textsc" >Turing</span>-berechenbar</span></em>, falls es eine TM \(M\) gibt, sodass<br />
\(f(n_1, \dotsc , n_k) = m \iff q_0 \kod {n_1} \# \kod {n_2} \# \dotsb \# \kod {n_k} \vdash ^\ast \Box \dotsb \Box q_f \kod {m} \Box \dotsb \Box \)<br />
mit \(q_f \in F\) fu&#x0308;r alle \(n_1, \dotsc , n_k, m \in \natural \).<br />
Eine Funktion \(f\colon \Sigma ^\ast \rightarrow \Sigma ^\ast \) heißt <em><span class="dashuline" ><span class="textsc" >Turing</span>-berechenbar</span></em>, falls es eine TM \(M\) gibt, sodass<br />
\(f(x) = y \iff q_0 x \vdash ^\ast \Box \dotsb \Box q_f y \Box \dotsb \Box \) mit \(q_f \in F\) fu&#x0308;r alle \(x, y \in \Sigma ^\ast \).<br />
Bei partiell definierten Funktionen soll die TM fu&#x0308;r undefinierte Werte in eine Endlosschleife u&#x0308;bergehen.
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" ><span class="textsc" >Church</span>sche These</span>):</span> Die Klasse der intuitiv berechenbaren Funktionen stimmt genau mit der Klasse der
Turing-berechenbaren Funktionen u&#x0308;berein.
</p>

<p>
<em>Bemerkung</em>: Die Churchsche These la&#x0308;sst sich nicht beweisen, da nicht exakt bestimmt ist, was ein Algorithmus oder intuitive Berechenbarkeit ist. Vielmehr besagt sie, dass bisher niemand einen allgemeineren
Berechenbarkeitsbegriff beno&#x0308;tigt hat.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>entscheidbar</b>:&#x2003; Eine Sprache \(A \subset \Sigma ^\ast \) heißt <em><span class="dashuline" >entscheidbar</span></em>, falls die charakteristische Funktion von \(A\), d.&#x202f;h. \(\chi _A\colon
\Sigma ^\ast \rightarrow \{0, 1\}\) mit \(\chi _A(w) := [w \in A]\), berechenbar ist.<br />
Dabei gilt fu&#x0308;r eine Aussage \(S\), dass \([S] := 1\) fu&#x0308;r \(S\) wahr und \([S] := 0\) fu&#x0308;r \(S\) falsch.<br />
Man kann die Definition auf Mengen \(A \subset \natural \) u&#x0308;bertragen.
</p>

<p>
<b>semi-entscheidbar</b>:&#x2003; Eine Sprache \(A \subset \Sigma ^\ast \) heißt <em><span class="dashuline" >semi-entscheidbar</span></em>, falls \(\chi _A’\colon \Sigma ^\ast \rightarrow _p \{0, 1\}\)
mit \(\chi _A’(w) := 1\) fu&#x0308;r \(w \in A\) und \(\chi _A’(w)\) undefiniert fu&#x0308;r \(w \notin A\) berechenbar ist.<br />
Man kann die Definition auf Mengen \(A \subset \natural \) u&#x0308;bertragen.
</p>

<p>
<b>rekursiv aufza&#x0308;hlbar</b>:&#x2003; Eine Sprache \(A \subset \Sigma ^\ast \) heißt <em><span class="dashuline" >rekursiv aufza&#x0308;hlbar</span></em>, falls \(A = \emptyset \) oder falls es eine
u&#x0308;berall definierte, berechenbare Funktion \(f\colon \natural \rightarrow \Sigma ^\ast \) gibt mit \(A = \{f(1), f(2), f(3), \dotsc \}\), d.&#x202f;h. <em><span class="dashuline" >\(f\) za&#x0308;hlt
\(A\) auf</span></em>.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >A&#x0308;quivalenz fu&#x0308;r semi-entscheidbar</span>):</span> Sei \(A \subset \Sigma ^\ast \) eine Sprache.<br />
Dann sind die folgenden Bedingungen a&#x0308;quivalent:
</p>
<ul style="list-style-type:none">

<li class="list-item-f10"><p>\(A\) ist semi-entscheidbar.
</p>
</li>
<li class="list-item-f11"><p>\(A\) ist rekursiv aufza&#x0308;hlbar.
</p>
</li>
<li class="list-item-f12"><p>Es gibt eine TM \(M\) mit \(T(M) = A\).
</p>
</li>
<li class="list-item-f13"><p>\(A\) ist vom Typ 0.
</p>
</li>
<li class="list-item-f14"><p>Es gibt eine TM \(M\) mit \(A = \{w \in \Sigma ^\ast \;|\; M \text { hält auf } w\}\).
</p>
</li>
</ul>

<p>
<b>Beweis</b>: \((3) \iff (4)\) wurde bereits fru&#x0308;her gezeigt.<br />
\((3) \iff (5)\) ist klar, da man die TM \(M\) mit \(T(M) = A\) leicht so umprogrammieren kann, dass sie in eine Endlosschleife geht, wenn \(M\) auf \(w\) ha&#x0308;lt, aber \(w\) nicht akzeptiert. In der anderen Richtung muss
man bei Halt auf \(w\) in einen Endzustand u&#x0308;bergehen.<br />
\((1) \iff (5)\) ist ebenfalls einfach, denn aus der Semi-Entscheidbarkeit von \(A\) folgt die Berechenbarkeit von \(\chi _A’\), d.&#x202f;h. es gibt eine TM \(M\), die terminiert genau dann, wenn \(w \in A\). Andersherum
muss eine TM \(M\) mit \(A = \{w \in \Sigma ^\ast \;|\; M \text { hält auf } w\}\) nur \(1\) ausgeben, wenn \(M\) auf \(w\) ha&#x0308;lt, damit sie \(\chi _A’\) entscheidet.<br />
\((1) \iff (2)\) geht folgendermaßen: Sei \(A\) rekursiv aufza&#x0308;hlbar mittels der berechenbaren Funktion \(f\). Konstruiere eine TM, die \(A\) semi-entscheidet, wie folgt: In einer Schleife von \(n = 1, 2, \dotsc \)
berechne \(f(n)\). Falls \(f(n)\) gleich der Eingabe \(w\) ist, so terminiere und gib \(1\) aus. Diese TM terminiert genau dann, wenn \(w \in A\).<br />
Sei nun \(A \not = \emptyset \) semi-entscheidbar, etwa mittels einer TM \(M\). Man konstruiert eine berechenbare Funktion \(f\), die \(A\) aufza&#x0308;hlt, wie folgt: Sei \(a_0 \in A\) fest. Die Eingabe \(n \in \natural
\) wird interpretiert als Paar von natu&#x0308;rlichen Zahlen \((k, \ell ) \in \natural \times \natural \) (geht durch eine Abza&#x0308;hlung von \(\natural \times \natural \)). \(k\) wird wiederum interpretiert
als Kodierung eines Wortes \(x \in \Sigma ^\ast \). Gibt es kein \(x \in \Sigma ^\ast \) mit \(\kod {x} = k\), so setzt man \(x = \varepsilon \). Die TM, die \(f\) berechnet, fu&#x0308;hrt nun die TM \(M\) mit
Eingabe \(x\) aus, aber la&#x0308;sst sie nur ho&#x0308;chstens \(\ell \) viele Schritte rechnen (um zu verhindern, dass nicht terminiert wird). Hat \(M\) die Eingabe \(x\) erkannt (d.&#x202f;h. \(1\) ausgegeben), so gebe
\(x\) aus, ansonsten das feste Wort \(a_0\). So wird sichergestellt, dass einerseits jedes Wort \(x \in A\) einmal ausgegeben wird, andererseits, dass die TM stets terminiert und in diesem Fall ein Dummy-Wort aus \(A\) ausgibt.
&#x2003;&#x2003;
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >A&#x0308;quivalenz fu&#x0308;r entscheidbar</span>):</span> Eine Sprache \(A \subset \Sigma ^\ast \) ist entscheidbar genau dann, wenn \(A\) und
\(\Sigma ^\ast \setminus A\) semi-entscheidbar sind.
</p>

<p>
<b>Beweis</b>: Sei \(A \subset \Sigma ^\ast \) entscheidbar. Dann ist \(A\) auch semi-entscheidbar (falls eine \(0\) ausgegeben wird, wechselt man in eine Endlosschleife). Analog ist \(\Sigma ^\ast \setminus A\)
semi-entscheidbar (hier, falls \(1\) ausgegeben wird, andernfalls gibt man statt der \(0\) eine \(1\) aus).<br />
Seien \(A\) und \(\Sigma ^\ast \setminus A\) semi-entscheidbar. Dann gibt es zwei TM \(M_1\) und \(M_2\) mit \(L(M_1) = A\) und \(L(M_2) = \Sigma ^\ast \setminus A\). Definiere \(L(M, k) := \{w \in \Sigma
^\ast \;|\; |w| \le k,\; M \text { akzeptiert } w \text { in} \le k \text { Schritten}\}\) fu&#x0308;r eine TM \(M\) und \(k \in \natural \). \(L(M, k)\) ist endlich und effektiv berechenbar. Konstruiere jetzt
eine TM, die \(A\) entscheidet, wie folgt: Stelle in einer Schleife u&#x0308;ber \(k = 1, 2, \dotsc \) fest, ob \(w \in L(M_1, k)\) oder \(w \in L(M_2, k)\). In diesem Fall gebe \(1\) bzw. \(0\) aus. &#x2003;&#x2003;
</p>

<p>
<em>Beispiel</em>: Die Sprache \(L_\pi = \{w \in \{0, \dotsc , 9\}^\ast \;|\; w \text { erscheint in der Dezimalentwicklung von } \pi \}\) ist semi-entscheidbar. Ob \(L_{\pi ^\infty } = \{w \in \{0,
\dotsc , 9\}^\ast \;|\; w \text { erscheint in der Dezimalentwicklung }\) \(\text {von } \pi \text { unendlich oft}\}\) semi-entscheidbar ist, weiß man nicht<br />
(man vermutet \(L_\pi = L_{\pi ^\infty } = \{0, \dotsc , 9\}^\ast \) regula&#x0308;r).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >universelle <span class="textsc" >Turing</span>maschine</span>):</span> Sei \(L_U := \{\kod {M, w} \;|\; M \text { TM},\; w \in L(M)\}
\subset \{0, 1\}^\ast \) mit \(\kod {M, w}\) einer fest gewa&#x0308;hlten Standardkodierung von Paaren \((M, w) \in \TM \times \Sigma ^\ast \).<br />
Dann gibt es eine TM \(U\) mit \(L(U) = L_U\). \(U\) heißt <em><span class="dashuline" >universelle <span class="textsc" >Turing</span>maschine</span></em>.<br />
Zusa&#x0308;tzlich ist \(L_U\) unentscheidbar und \(\{0, 1\}^\ast \setminus L_U\) ist nicht rekursiv aufza&#x0308;hlbar.
</p>



<h2 id="reduktionen">Reduktionen</h2>

</p>


<p>
<b>Reduktion</b>:&#x2003; Seien \(A \subset \Sigma ^\ast \) und \(B \subset \Sigma ’^\ast \) Sprachen. Dann heißt eine u&#x0308;berall definierte, berechenbare Abbildung \(f\colon \Sigma ^\ast \rightarrow
\Sigma ’^\ast \) <em><span class="dashuline" >Reduktion</span></em> von \(A\) auf \(B\), falls \(x \in A \iff f(x) \in B\) fu&#x0308;r alle \(x \in \Sigma ^\ast \). \(A\) heißt auf \(B\) <em><span
class="dashuline" >reduzierbar</span></em> (\(A \le B\)), falls es eine Reduktion von \(A\) auf \(B\) gibt.
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >U&#x0308;bertragbarkeit bei Reduktionen</span>):</span> Seien \(A \subset \Sigma ^\ast \) und \(B \subset \Sigma ’^\ast \) Sprachen mit \(A \le
B\).<br />
Wenn \(B\) (semi-)entscheidbar ist, dann ist auch \(A\) (semi-)entscheidbar.<br />
Insbesondere gilt \(B\) unentscheidbar, wenn \(A\) unentscheidbar.
</p>

<p>
<b>Beweis</b>: Sei \(B\) (semi-)entscheidbar und \(f\) eine Reduktion von \(A\) auf \(B\). Konstruiere eine TM \(M\), die \(A\) (semi-)entscheidet, wie folgt: Fu&#x0308;r ein \(x \in \Sigma ^\ast \) berechne durch \(f\)
(berechenbar) das Bild \(f(x)\). Da \(B\) (semi-)entscheidbar ist, gibt es eine andere TM, die in endlicher Zeit entscheidet, ob \(f(x) \in B\) (bzw. fu&#x0308;r \(B\) semi-entscheidbar in eine Endlosschleife geht, wenn \(f(x)
\notin B\)). Da dies der Fall ist genau dann, wenn \(x \in A\), ist die Frage \(x \in A?\) (semi-)entschieden. &#x2003;&#x2003;
</p>



<h2 id="die-saetze-von-rice">Die Sätze von <span style="font-variant: small-caps;">Rice</span></h2>

</p>


<p>
<b>Eigenschaft</b>:&#x2003; Eine <em><span class="dashuline" >Eigenschaft</span></em> ist eine Abbildung \(S\colon \PS (\Sigma ^\ast ) \rightarrow \{0, 1\}\).<br />
Die Eigenschaft <em><span class="dashuline" >gilt</span></em> fu&#x0308;r eine Sprache \(L \subset \Sigma ^\ast \), falls \(S(L) = 1\).<br />
Eine Eigenschaft heißt <em><span class="dashuline" >nicht-trivial</span></em>, falls es \(L_0, L_1 \subset \Sigma ^\ast \) gibt mit \(S(L_0) = 0\) und \(S(L_1) = 1\).<br />
Eine <em><span class="dashuline" >Eigenschaft einer bestimmten Sprachklasse</span></em> ist eine Eigenschaft eingeschra&#x0308;nkt auf diese Sprachklasse.
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >Satz von &#x202f;<span class="textsc" >Rice</span></span>):</span><br />
Jede nicht-triviale Eigenschaft rekursiv aufza&#x0308;hlbarer Sprachen ist unentscheidbar.
</p>

<p>
<b>Beweis</b>: OBdA kann man annehmen, dass \(S(\emptyset ) = 0\) (andernfalls komplementiert man die Eigenschaft, dies hat keine Auswirkungen auf die Entscheidbarkeit). Da \(S\) nicht-trivial ist, gibt es ein \(L_1 =
L(M_1)\) mit \(S(L_1) = 1\).<br />
Sei \(M\) eine feste TM, sodass \(L(M)\) nicht entscheidbar ist (es gibt semi-entscheidbare, unentscheidbare Sprachen, z.&#x202f;B. das Halteproblem).<br />
Fu&#x0308;r ein Wort \(w\) konstruiere eine TM \(f(w)\) wie folgt: Bei einer Eingabe \(v\) simuliert sie zuna&#x0308;chst \(M\) auf \(w\). Falls \(w\) dabei akzeptiert wird, simuliert sie danach \(M_1\) auf \(v\), andernfalls geht
\(f(w)\) in eine Endlosschleife. Es gilt \(w \in L(M) \iff S(L(f(w))) = 1\):<br />
Fu&#x0308;r \(w \in L(M)\) simuliert \(f(w)\) bei jeder Eingabe \(v\) die TM \(M_1\) auf \(v\). Also gilt \(L(f(w)) = L(M_1)\) und es gilt \(S(L(f(w))) = S(L(M_1)) = 1\).<br />
Fu&#x0308;r \(w \notin L(M)\) ist \(L(f(w)) = \emptyset \), da \(f(w)\) in eine Endlosschleife geht, wenn \(M\) die Eingabe \(w\) nicht erkennt. Nach Voraussetzung gilt \(S(L(f(w))) = 0\).<br />
Man erha&#x0308;lt also eine Reduktion von \(L(M)\) auf \(\{w \in \Sigma ^\ast \;|\; S(L(f(w))) = 1\}\).<br />
\(S(L(f(M, w))) = 1?\) ist entscheidbar, wenn \(S\) eine entscheidbare Eigenschaft wa&#x0308;re. Damit wa&#x0308;re auch \(w \in L(M)?\) entscheidbar, ein Widerspruch. &#x2003;&#x2003;
</p>

<p>
<em>Beispiel</em>: Ein Beispiel fu&#x0308;r eine solche unentscheidbare Eigenschaft ist \(S(L) := [L \not = \emptyset ]\).<br />
Andere Beispiele sind \([L(M) \text { regulär}]\), \([|L(M)| &lt; \infty ]\) und \([w_0 \in L(M)]\).
</p>

<p>
<em>Bemerkung</em>: Anschaulich gesagt besagt der Satz, dass es nicht mo&#x0308;glich ist, das Verhalten einer Turingmaschine zu analysieren, ohne sie auszufu&#x0308;hren (d.&#x202f;h. nur durch Betrachten des Aufbaus).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >Satz von <span class="textsc" >Rice</span> fu&#x0308;r semi-entscheidbare Eigenschaften</span>):</span> Sei \(S\) eine Eigenschaft rekursiv
aufza&#x0308;hlbarer Sprachen. Dann sind die folgenden Bedingungen a&#x0308;quivalent:
</p>
<ul style="list-style-type:none">

<li class="list-item-f15"><p>\(S\) ist <em><span class="dashuline" >semi-entscheidbar</span></em>, d.&#x202f;h. \(\{\kod {M} \;|\; S(L(M)) = 1\}\) ist semi-entscheidbar.
</p>
</li>
<li class="list-item-f16"><p>Es gelten die folgenden drei Bedingungen:
</p>
<ul style="list-style-type:none">

<li class="list-item-f17"><p>Fu&#x0308;r alle \(L \subset \Sigma ^\ast \) mit \(S(L) = 1\) gibt es ein \(K \subset L\) endlich mit \(S(K) = 1\).
</p>
</li>
<li class="list-item-f18"><p>Die Menge \(\{K_1, K_2, \dotsc \;|\; K_i \text { endlich},\; S(K_i) = 1\}\) ist semi-entscheidbar.
</p>
</li>
<li class="list-item-f19"><p>Die Eigenschaft \(S\) ist <em><span class="dashuline" >monoton</span></em>, d.&#x202f;h. aus \(L \subset L’\) folgt \(S(L) \le S(L’)\).
</p>
</li>
</ul>
</li>
</ul>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<em>Bemerkung</em>: Der Satz von Rice fu&#x0308;r semi-entscheidbare Eigenschaften impliziert den Satz von Rice: Sei \(S\) eine entscheidbare Eigenschaft rekursiv aufza&#x0308;hlbarer Sprachen. Dann ist \(S\) insbesondere
semi-entscheidbar. Aufgrund des Satzes von Rice fu&#x0308;r semi-entscheidbare Eigenschaften ist \(S\) monoton. Es gilt \(S(\emptyset ) = 0\) oder \(S(\emptyset ) = 1\).<br />
Fu&#x0308;r \(S(\emptyset ) = 1\) gilt \(S(L) \equiv 1\) fu&#x0308;r alle \(L \subset \Sigma ^\ast \) wegen der Monotonie, d.&#x202f;h. \(S\) ist trivial.<br />
Fu&#x0308;r \(S(\emptyset ) = 0\) betrachte die Komplementeigenschaft \(\overline {S}(L) := 1 - S(L)\) (\(\overline {S}\) ist ebenfalls entscheidbar, also wie eben monoton). Dann gilt \(\overline {S}(\emptyset )
= 1\) und es folgt \(S(L) \equiv 0\) fu&#x0308;r alle \(L \subset \Sigma ^\ast \), d.&#x202f;h. \(S\) ist trivial.<br />
In beiden Fa&#x0308;llen ist \(S\) trivial, was die Aussage des Satzes von Rice ist.
</p>

<p>
<em>Beispiel</em>: Definiere \(W_i := \{\kod {w, G} \;|\; G \text { Typ } i,\; w \in L(G)\} \subset \{0, 1\}^\ast \) (<em><span class="dashuline" >Wortproblem</span></em>).<br />
\(W_2\) ist polynomiell entscheidbar mithilfe des CYK-Algorithmus.<br />
\(W_1\) ist entscheidbar (kontextsensitive Regeln sind nicht-verku&#x0308;rzend), aber es ist unbekannt, ob \(W_1\) sogar polynomiell entscheidbar ist.<br />
\(W_0\) ist unentscheidbar (Halteproblem der TM), aber immerhin rekursiv aufza&#x0308;hlbar – daraus folgt nach obigem Satz, dass das Komplement \(\{0, 1\}^\ast \setminus W_0\) nicht rekursiv aufza&#x0308;hlbar ist.
</p>

<p>
<em>Beispiel</em>: Definiere \(P_i := \{\kod {G} \;|\; G \text { Typ } i,\; L(G) = \Sigma ^\ast \} \subset \{0, 1\}^\ast \) (<em><span class="dashuline" >Totalita&#x0308;tsproblem</span></em>).<br />
\(P_0\) ist ein Beispiel fu&#x0308;r eine Sprache, die nicht rekursiv aufza&#x0308;hlbar ist, aber auch deren Komplement nicht. Betrachtet man das <em><span class="dashuline" >Leerheitsproblem</span></em> \(P_i’ :=
\{\kod {G} \;|\; G \text { Typ } i,\; L(G) = \emptyset \} \subset \{0, 1\}^\ast \), dann kann man \(P_3\) lo&#x0308;sen durch Umformung von \(G\) in ein NEA, anschließende Potenzmengenkonstruktion, um
einen DEA zu erhalten, Vertauschung von Start- und Endzusta&#x0308;nde des DEA und schließlich Lo&#x0308;sen von \(P_3’\) bei der entstehenden komplementa&#x0308;ren Sprache. Dieses Problem ist na&#x0308;mlich
einfach entscheidbar (gibt es einen Pfad von einem Start- zu einem Endzustand?).
</p>



<h2 id="das-halteproblem">Das Halteproblem</h2>

</p>


<p>
<em>Bemerkung</em>: Im Folgenden sei eine bina&#x0308;re Kodierung von Turingmaschinen gegeben, d.&#x202f;h. fu&#x0308;r jede Turingmaschine \(M\) gibt es ein \(w \in \{0, 1\}^\ast \) mit \(\kod {M_w} = w\) und
\(M_w := M\).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>spezielles Halteproblem</b>:&#x2003; Das <em><span class="dashuline" >spezielle Halteproblem</span></em> oder das <em><span class="dashuline" >Selbstanwendungsproblem</span></em> ist \(K := \{w \in \{0,
1\}^\ast \;|\; M_w \text { hält auf Eingabe } w\}\).
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >spez. Halteproblem unent.</span>):</span> Das spezielle Halteproblem \(K\) ist nicht entscheidbar.
</p>

<p>
<b>Beweis</b>: Angenommen, \(K\) sei entscheidbar. Dann ist \(\chi _K\) berechenbar mittels einer TM \(M\). Konstruiere eine TM \(M’\), die zuna&#x0308;chst \(M\) auf der Eingabe von \(M’\) ausfu&#x0308;hrt. Falls \(M\)
eine Eins zuru&#x0308;ckgibt, geht sie in eine Endlosschleife, andernfalls terminiert \(M’\).<br />
Sei \(M’ = M_{w’}\) fu&#x0308;r ein Wort \(w’ \in \{0, 1\}^\ast \). Dann gilt:<br />
\(M’\) ha&#x0308;lt auf Eingabe \(w’\) \(\iff \) \(M\) gibt auf Eingabe \(w’\) Null aus \(\iff \) \(\chi _K(w’) = 0\) \(\iff \) \(w’ \notin K\) \(\iff \) \(M’ = M_{w’}\) ha&#x0308;lt nicht auf Eingabe \(w’\), ein
Widerspruch. &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Halteproblem</b>:&#x2003; Das <em><span class="dashuline" >(allgemeine) Halteproblem</span></em> ist<br />
\(H := \{w\# x \in \{0, 1\}^\ast \# \{0, 1\}^\ast \;|\; M_w \text { hält auf Eingabe } x\}\).
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >Halteproblem unentscheidbar</span>):</span> Das Halteproblem \(H\) ist nicht entscheidbar.
</p>

<p>
<b>Beweis</b>: Es wird eine Reduktion \(K \le H\) konstruiert.<br />
Sei \(f\colon \{0, 1\}^\ast \rightarrow \{0, 1\}^\ast \) mit \(f(w) := w\# w\).<br />
Dann gilt \(w \in K\) \(\iff \) \(M_w\) ha&#x0308;lt auf Eingabe \(w\) \(\iff \) \(w\# w = f(w) \in H\).<br />
Weil \(K\) nicht entscheidbar ist, ist auch \(H\) nicht entscheidbar. &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Halteproblem auf leerem Band</b>:&#x2003; Das <em><span class="dashuline" >Halteproblem auf leerem Band</span></em> ist<br />
\(H_0 := \{w \in \{0, 1\}^\ast \;|\; M_w \text { hält auf leerem Band}\}\).
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >Halteproblem auf leerem Band unentscheidbar</span>):</span><br />
Das Halteproblem auf leerem Band \(H_0\) ist nicht entscheidbar.
</p>

<p>
<b>Beweis</b>: Es wird eine Reduktion \(H \le H_0\) konstruiert. Sei ein Wort \(w\# x \in \{0, 1\}^\ast \# \{0, 1\}^\ast \) gegeben. Einem solchen Wort kann man eine TM \(M\) zuordnen, die bei leerer Eingabe \(M_w\)
auf \(x\) ausfu&#x0308;hrt. Bei nicht-leerer Eingabe ist das Verhalten von \(M\) egal.<br />
Sei \(f\colon \{0, 1\}^\ast \# \{0, 1\}^\ast \rightarrow \{0, 1\}^\ast \) mit \(f(w\# x) := \kod {M}\). Dann gilt:<br />
\(w\# x \in H\) \(\iff \) \(M_w\) ha&#x0308;lt auf Eingabe \(x\) \(\iff \) \(M\) ha&#x0308;lt auf leerem Band<br />
\(\iff \) \(f(w\# x) = \kod {M} \in H_0\). Weil \(H\) nicht entscheidbar ist, ist auch \(H_0\) nicht entscheidbar. &#x2003;&#x2003;
</p>



<h2 id="das-postsche-korrespondenzproblem">Das <span style="font-variant: small-caps;">Post</span>sche Korrespondenzproblem</h2>

</p>


<p>
<b><span class="textsc" >Post</span>sches Korrespondenzproblem</b>:&#x2003; Das <em><span class="dashuline" ><span class="textsc" >Post</span>sche Korrespondenzproblem (PKP)</span></em>
entha&#x0308;lt die folgende Fragestellung: Seien \(\Sigma \) ein Alphabet und \(k\) Wortpaare \((x_1, y_1), \dotsc , (x_k, y_k)\) mit \(x_i, y_i \in \Sigma ^+\) gegeben. Gesucht ist eine Folge von Indizes \(i_1,
\dotsc , i_n \in \{1, \dotsc , k\}\) mit \(n \in \natural \), sodass \(x_{i_1} \dotsb x_{i_n} = y_{i_1} \dotsb y_{i_n}\). In diesem Fall heißt \(i_1, \dotsc , i_n\) eine <em><span class="dashuline"
>Lo&#x0308;sung</span></em> des Korrespondenzproblems \((x_1, y_1), \dotsc ,\)<br />
\((x_k, y_k)\).
</p>

<p>
<em>Beispiel</em>: Das PKP \(((1, 101), (10, 00), (011, 11))\) besitzt die Lo&#x0308;sung \((1, 3, 2, 3)\), da \(x_1 x_3 x_2 x_3 = 101110011 = y_1 y_3 y_2 y_3\).
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >Satz von &#x202f;<span class="textsc" >Post</span></span>):</span> \(\{\kod {K} \;|\; K \text { ist lösbares PKP}\}\) ist unentscheidbar.
</p>

<p>
<em>Bemerkung</em>: Das PKP ist semi-entscheidbar mittels Brute-Force, d.&#x202f;h. die lo&#x0308;sbaren PKP sind aufza&#x0308;hlbar.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<em>Bemerkung</em>: Alternativ kann man das PKP auch algebraisch formulieren. Seien zwei Abbildungen \(f, g\colon \{1, \dotsc , k\} \rightarrow \Sigma ^\ast \) mit \(f(j) = u_j\) und \(g(j) = v_j\) gegeben.
Diese ko&#x0308;nnen eindeutig zu Homomorphismen \(f, g\colon \{1, \dotsc , k\}^\ast \rightarrow \Sigma ^\ast \) fortgesetzt werden.<br />
Gesucht ist ein \(w \in \{1, \dotsc , k\}^\ast \) mit \(f(w) = g(w)\) und \(f(w) \in \Sigma ^+\). A&#x0308;quivalent kann man sagen:<br />
Gibt es \(w \in \{1, \dotsc , k\}^\ast \), \(z \in \Sigma ^\ast \) und \(a \in \Sigma \) mit \(f(w) = g(w) = az\)?
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >Totalita&#x0308;tsproblem fu&#x0308;r kf. Sprachen unentscheidbar</span>):</span><br />
Das Totalita&#x0308;tsproblem \(L(G) = \Sigma ^\ast ?\) ist fu&#x0308;r kontextfreie Grammatiken \(G\) unentscheidbar.
</p>

<p>
<b>Beweis</b>: Sei ein beliebiges PKP gegeben. Dann kann man kontextfreie Grammatiken \(G_1\) und \(G_2\) wie folgt definieren: \(L(G_1) = \{i_m \dotsb i_1 \dollar u_{i_1} \dotsb u_{i_m} \;|\; m \in \natural
,\; i_1, \dotsc , i_m \in \{1, \dotsc , k\}\}\) und<br />
\(L(G_2) = \{i_m \dotsb i_1 \dollar v_{i_1} \dotsb v_{i_m} \;|\; m \in \natural ,\; i_1, \dotsc , i_m \in \{1, \dotsc , k\}\}\).<br />
Das PKP hat eine Lo&#x0308;sung \(\iff \) \(L(G_1) \cap L(G_2) \not = \emptyset \) \(\iff \) \(\overline {L(G_1)} \cup \overline {L(G_2)} \not = \Sigma ^\ast \).<br />
Die Klasse der kontextfreien Sprachen ist zwar nicht unter Komplement abgeschlossen, aber da man zeigen kann, dass \(\overline {L(G_1)}\) und \(\overline {L(G_2)}\) sogar deterministisch kontextfrei sind (die det. kf.
Sprachen sind unter Komplement abgeschlossen), und weil die kontextfreien Sprachen unter Vereinigung abgeschlossen sind, ist \(\overline {L(G_1)} \cup \overline {L(G_2)}\) wieder kontextfrei.<br />
Wa&#x0308;re nun das Totalita&#x0308;tsproblem fu&#x0308;r kontextfreie Sprachen entscheidbar, dann ko&#x0308;nnte man \(\overline {L(G_1)} \cup \overline {L(G_2)} \not = \Sigma ^\ast ?\) entscheiden und
somit wa&#x0308;re die Lo&#x0308;sbarkeit von jedem PKP entscheidbar, was aber nicht stimmt. Also ist das Totalita&#x0308;tsproblem fu&#x0308;r kf. Sprachen unentscheidbar. &#x2003;&#x2003;
</p>



<h2 id="fleissige-biber">Fleißige Biber</h2>

</p>


<p>
<b>Biber</b>:&#x2003; Ein <em><span class="dashuline" >Biber</span></em> ist eine deterministische TM \(B = (Q, \Sigma , \Gamma , \delta , q_0, \emptyset , \Box )\) mit \(\Sigma = \{|\}\) und \(\Gamma =
\{|, \Box \}\), wobei nur solche Zustandsu&#x0308;berga&#x0308;nge zugelassen sind, bei denen die TM den Lese-/<br />
Schreibkopf nach links oder nach rechts bewegt.
</p>

<p>
<b>Biber-Funktion</b>:&#x2003; Ein Biber \(B\) berechnet eine partiell definierte <em><span class="dashuline" >Biber-Funktion</span></em> \(f_B\colon \natural \rightarrow _p \natural \). \(f_B(n)\) ist definiert,
falls \(B\) fu&#x0308;r die Eingabe \(|^n\) ha&#x0308;lt. In diesem Fall sei \(f_B(n)\) die Anzahl der \(|\), die auf dem Band stehen.
</p>

<p>
<b>Fleißiger-Biber-Funktion</b>:&#x2003; Die <em><span class="dashuline" >Fleißiger-Biber-Funktion</span></em> \(\bb \) ist fu&#x0308;r \(n \in \natural \) definiert durch \(\bb (n) := \text {BusyBeaver}(n)
:= \max \{f_B(0) \;|\; B \text { Biber mit} \le n \text { Zuständen},\; f_B(0) \text { definiert}\}\).<br />
Ein Biber mit \(\le n\) Zusta&#x0308;nden, sodass \(\bb (n) = f_B(0)\) gilt, heißt <em><span class="dashuline" >fleißiger Biber</span></em>.
</p>

<p>
<em>Bemerkung</em>: Fleißige Biber sind spezielle TM, die mit einer vorgegebenen Anzahl an Zusta&#x0308;nden ohne Eingabe mo&#x0308;glichst viel Zeichen auf das Ausgabeband schreiben, ohne in eine Endlosschleife zu
geraten. Mittels der Fleißiger-Biber-Funktion la&#x0308;sst sich daher der maximale Komplexita&#x0308;tsgrad von Turingmaschinen abscha&#x0308;tzen.<br />
Die Fleißiger-Biber-Funktion ist eine unglaublich schnell wachsende Funktion. Sie wa&#x0308;chst so schnell, dass nur vier Werte bekannt sind, fu&#x0308;r zwei weitere Abscha&#x0308;tzungen existieren und alle anderen Werte
unbekannt sind:
</p>
<table>

<tr class="tbrule">
<td class="tdp">

<p>
<b>\(n\)</b>
</p>
</td>
<td class="tdp">

<p>
\(1\)
</p>
</td>
<td class="tdp">

<p>
\(2\)
</p>
</td>
<td class="tdp">

<p>
\(3\)
</p>
</td>
<td class="tdp">

<p>
\(4\)
</p>
</td>
<td class="tdp">

<p>
\(5\)
</p>
</td>
<td class="tdp">

<p>
\(6\)
</p>
</td>
<td class="tdp">

<p>
\(\ge 7\)
</p>
</td>
</tr>


<tr>
<td class="tdp">

<p>
<b>\(\bb (n)\)</b>
</p>
</td>
<td class="tdp">

<p>
\(1\)
</p>
</td>
<td class="tdp">

<p>
\(4\)
</p>
</td>
<td class="tdp">

<p>
\(6\)
</p>
</td>
<td class="tdp">

<p>
\(13\)
</p>
</td>
<td class="tdp">

<p>
\(\ge 4098\)
</p>
</td>
<td class="tdp">

<p>
\(\ge 3{,}5 \cdot 10^{18267}\)
</p>
</td>
<td class="tdp">

<p>
unbekannt
</p>
</td>
</tr>


<tr class="tbrule">
<td class="tdp">

</td>
<td class="tdp">

</td>
<td class="tdp">

</td>
<td class="tdp">

</td>
<td class="tdp">

</td>
<td class="tdp">

</td>
<td class="tdp">

</td>
<td class="tdp">

</td>
</tr>

</table>

<p>
Weil die Anzahl an Bibern mit \(\le n\) Zusta&#x0308;nden endlich ist, existiert \(\bb (n)\) als Maximum einer endlichen Teilmenge von \(\natural \). \(\bb (n)\) ist offensichtlich monoton wachsend.
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >\(\bb \) schneller wachsend als jede berechenbare Funktion</span>):</span><br />
Sei \(f\colon \natural \rightarrow \natural \) berechenbar und u&#x0308;berall definiert.<br />
Dann ist \(f(n) &lt; \bb (n)\) fu&#x0308;r fast alle \(n \in \natural \). Insbesondere ist \(\bb \) nicht berechenbar.
</p>

<p>
<b>Beweis</b>: Sei \(M\) eine Turingmaschine, die \(f\) berechnet und nur \(\{0, 1, \Box \}\) als Bandalphabet benutzt. \(M\) kann durch einen Biber simuliert werden, d.&#x202f;h. es gibt einen Biber \(B\), sodass<br />
\(f(n) = f_B(n)\) fu&#x0308;r alle \(n \in \natural \). Fu&#x0308;r jedes \(n \in \natural \) gibt es einen Biber \(B_n\) mit \(f_{B_n}(0) = n\), der ho&#x0308;chstens \(\O (\log n)\) viele Zusta&#x0308;nde hat.
Fu&#x0308;r jedes \(n \in \natural \) gibt es wiederum einen Biber \(C_n = B \circ B_n\) mit \(f_{C_n}(0) = f_B(f_{B_n}(0)) = f_B(n) = f(n)\). Definiere nun \(C_n’ = \succ \circ C_n\) mit \(f_{C_n’}(0) =
f(n) + 1\). \(C_n’\) hat immer noch ho&#x0308;chstens \(\O (\log n)\) viele Zusta&#x0308;nde.<br />
Damit gilt \(f(n) &lt; f(n) + 1 \le \bb (n)\) fu&#x0308;r fast alle \(n \in \natural \), denn es gibt Biber \(C_n’\) mit \(f_{C_n’}(0) = f(n) + 1\). Fu&#x0308;r fast alle \(n \in \natural \) hat \(C_n’\)
ho&#x0308;chstens \(n\) Zusta&#x0308;nde (da \(C_n’\) \(\O (\log n)\) viele Zusta&#x0308;nde hat), d.&#x202f;h. fu&#x0308;r diese \(n\) gilt \(f_{C_n’}(0) \le \bb (n)\). &#x2003;&#x2003;
</p>



<h2 id="primitive-biber-und-primitiv-rekursive-funktionen">Primitive Biber und primitiv-rekursive Funktionen</h2>

</p>


<p>
<em>Bemerkung</em>: Etwa zeitgleich zum Begriff der Turingmaschine und der Turing-Berechenbarkeit wurde der Begriff der primitiv-rekursiven Funktionen entwickelt. David Hilbert vermutete, dass jede berechenbare Funktion
primitv-rekursiv ist, was aber u.&#x202f;a. durch seinen Schu&#x0308;ler Wilhelm Ackermann mit der Ackermann-Funktion widerlegt werden konnte.<br />
Alternativ kann man dies mit den sog. primitven Bibern zeigen. Dafu&#x0308;r sei in diesem Abschnitt die \(0\) in \(\natural \) enthalten.
</p>

<p>
<b>primitiv-rekursive Funktion</b>:&#x2003; Die Klasse \(\pr \) der <em><span class="dashuline" >primitiv-rekursiven Funktionen</span></em> ist eine Teilmenge der Funktionen \(\natural ^k \rightarrow \natural
\) mit \(k \in \natural \), die wie folgt definiert ist:
</p>
<ul style="list-style-type:none">

<li class="list-item-f20"><p>Die Nullfunktion \(0\colon \natural ^0 \rightarrow \natural \), \(() \mapsto 0\), ist primitiv-rekursiv.
</p>
</li>
<li class="list-item-f21"><p>Die Nachfolgerfunktion \(\succ \colon \natural ^1 \rightarrow \natural \), \(n \mapsto n + 1\), ist primitv-rekursiv.
</p>
</li>
<li class="list-item-f22"><p>Die Projektion \(\pi _{i,k}\colon \natural ^k \rightarrow \natural \), \((n_1, \dotsc , n_k) \mapsto n_i\), ist primitiv-rekursiv.
</p>
</li>
<li class="list-item-f23"><p>Die Komposition \(h(g_1, \dotsc , g_k)\colon \natural ^\ell \rightarrow \natural \), \(n = (n_1, \dotsc , n_\ell ) \mapsto h(g_1(n), \dotsc , g_k(n))\),<br />
ist primitiv-rekursiv, falls \((h\colon \natural ^k \rightarrow \natural ) \in \pr \) und \((g_i\colon \natural ^\ell \rightarrow \natural ) \in \pr \) fu&#x0308;r \(i = 1, \dotsc , k\).
</p>
</li>
<li class="list-item-f24"><p>\(f = \rec (g, h)\colon \natural ^{k+1} \rightarrow \natural \), \((0, n_1, \dotsc , n_k) \mapsto g(n_1, \dotsc , n_k)\),<br />
\((n + 1, n_1, \dotsc , n_k) \mapsto h(f(n, n_1, \dotsc , n_k), n, n_1, \dotsc , n_k)\), ist primitiv-rekursiv,<br />
falls \((g\colon \natural ^k \rightarrow \natural ) \in \pr \) und \((h\colon \natural ^{k+2} \rightarrow \natural ) \in \pr \) (<em><span class="dashuline" >Schema der primitiven
Rekursion</span></em>).
</p>
</li>
</ul>

<p>
<b>Komplexita&#x0308;t von primitv-rekursiven Funktionen</b>:&#x2003; Setze \(\norm {0} := 1\), \(\norm {\succ } := 1\),<br />
\(\norm {\pi _{i,k}} := k\), \(\norm {h(g_1, \dotsc , g_k)} := \norm {h} + \norm {g_1} + \dotsb + \norm {g_k}\) und \(\norm {\rec (g, h)} := \norm {g} + \norm {h}\).
</p>

<p>
<b>Primitiver-Biber-Funktion</b>:&#x2003; Sei \(\pr _k := \{f \in \pr \;|\; \norm {f} \le k\}\). Die <em><span class="dashuline" >Primitive-Biber-Funktion</span></em> \(\pb \) ist fu&#x0308;r \(k, n \in
\natural \) definiert durch \(\pb (k, n) := \max \{f(n) \;|\; f \in \pr _k\}\) bzw. \(\pb (n) := \pb (n, n)\).<br />
Definiere zusa&#x0308;tzlich \(p_k\colon \natural \rightarrow \natural \), \(p_k(n) := \pb (k, n)\).
</p>

<p>
<em>Bemerkung</em>: \(\pr _k\) ist endlich mit \(|\pr _k| \in 2^{\O (k)}\).
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >\(\pb (k, n)\) fu&#x0308;r festes \(k\) primitiv-rekursiv</span>):</span> Es gilt \(p_k \in \pr \) fu&#x0308;r alle \(k \in \natural \).
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >\(\pb \) schneller wachsend als jede primitiv-rekursive Funktion</span>):</span><br />
Sei \(f\colon \natural \rightarrow \natural \) primitiv-rekursiv und u&#x0308;berall definiert.<br />
Dann ist \(f(n) &lt; \pb (n)\) fu&#x0308;r fast alle \(n \in \natural \). Insbesondere ist \(\pb \) nicht primitiv-rekursiv.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b><span class="textsc" >Ackermann</span>-Funktion</b>:&#x2003; Die <em><span class="dashuline" ><span class="textsc" >Ackermann</span>-Funktion</span></em> \(a\colon \natural _0 \times
\natural _0 \rightarrow \natural \) ist definiert durch<br />
\(a(0, y) := y + 1\), \(a(x + 1, 0) := a(x, 1)\) und \(a(x + 1, y + 1) := a(x, a(x + 1, y))\)
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" ><span class="textsc" >Ackermann</span>-Funktion nicht primitiv-rekursiv</span>):</span> \(a(x, y)\) ist nicht primitiv-rekursiv, insbesondere ist die
Klasse der primitiv-rekursiven Funktionen nicht gleich der Klasse der Turing-berechenbaren Funktionen.
</p>



<h2 id="die-sprachen-imp-while-und-loop">Die Sprachen IMP, WHILE und LOOP</h2>

</p>


<p>
<em>Bemerkung</em>: Im Folgenden wird eine formale Programmiersprache IMP definiert (imperative Sprache).
</p>

<p>
<b>Grundbereiche</b>:&#x2003; Die in \(\IMP \) verwendeten <em><span class="dashuline" >Grundbereiche</span></em> sind \(\natural _0\) fu&#x0308;r natu&#x0308;rliche Zahlen, \(\B = \{\true , \false \} =
\{1, 0\}\) fu&#x0308;r Wahrheitswerte, \(\V = \{X_1, X_2, \dotsc ,\}\) fu&#x0308;r Variablen, \(\Loc \subset \V \) fu&#x0308;r die benutzten Variablen und \(\Sigma = \{\sigma \colon \Loc \rightarrow
\natural _0\}\) fu&#x0308;r Speicherzusta&#x0308;nde.
</p>

<p>
<em>Bemerkung</em>: Man kann \(\Sigma \) fu&#x0308;r \(\Loc = \{X_1, \dotsc , X_n\}\) mit \(\natural _0^n\) identifizieren (falls \(\Loc \) implizit geordnet ist durch z.&#x202f;B. \(X_1 &lt; \dotsb &lt; X_n\)).
In diesem Fall bedeutet \((x_1, \dotsc , x_n) \in \Loc \) der Speicherzustand \(\sigma \in \Sigma \) mit \(\sigma (X_k) = x_k\) fu&#x0308;r \(k = 1, \dotsc , n\).
</p>

<p>
<b>arithmetische Ausdru&#x0308;cke</b>:&#x2003; Die Menge \(\Aexp \) der <em><span class="dashuline" >arithmetischen Ausdru&#x0308;cke</span></em> ist definiert durch \(a ::= n \;|\; X \;|\; (a_1 + a_2)
\;|\; (a_1 - a_2) \;|\; (a_1 \cdot a_2)\) mit \(n \in \natural _0\) und \(X \in \V \). Die Klammern ko&#x0308;nnen weggelassen werden, wenn klar ist, was geklammert ist.<br />
Arithmetische Ausdru&#x0308;cke ko&#x0308;nnen zusammen mit einem Speicherzustand zu einer natu&#x0308;rlichen Zahl ausgewertet werden, d.&#x202f;h. die Auswertung ist eine Funktion \(\Aexp \times \Sigma
\rightarrow \natural _0\) mit<br />
\((n, \sigma ) \mapsto n\), \((X, \sigma ) \mapsto \sigma (X)\), \(((a_1 + a_2), \sigma ) \mapsto n_1 + n_2\), \(((a_1 - a_2), \sigma ) \mapsto \max \{n_1 - n_2, 0\}\) (<em><span class="dashuline"
>modifizierte Subtraktion</span></em>) und \(((a_1 \cdot a_2), \sigma ) \mapsto n_1 \cdot n_2\), wobei \(n \in \natural _0\), \(\sigma \in \Sigma \), \(X \in \Loc \) und \(a_i \in \Aexp \) mit \((a_i,
\sigma ) \mapsto n_i\) fu&#x0308;r \(i = 1, 2\).<br />
Man kann die Auswertung auch als Funktion \(\mathcal {A}\colon \Aexp \rightarrow (\Sigma \rightarrow \natural _0)\) auffassen, d.&#x202f;h. jeder arithmetische Ausdruck \(a \in \Aexp \) definiert eine Abbildung
von den Speicherzusta&#x0308;nden in die natu&#x0308;rlichen Zahlen. Man kann \((a, \sigma ) \mapsto n\) deswegen auch als \((\mathcal {A}(a))(\sigma ) = n\) schreiben.
</p>

<p>
<b><span class="textsc" >Boole</span>sche Ausdru&#x0308;cke</b>:&#x2003; Die Menge \(\Bexp \) der <em><span class="dashuline" ><span class="textsc" >Boole</span>schen
Ausdru&#x0308;cke</span></em> ist definiert durch \(b ::= \true \;|\; \false \;|\; (a_1 = a_2) \;|\; (a_1 &lt; a_2) \;|\; (a_1 &gt; a_2) \;|\; (a_1 \not = a_2) \;|\; (\lnot b) \;|\; (b_1 \land b_2)
\;|\; (b_1 \lor b_2) \;|\;\)<br />
\((b_1 \Rightarrow b_2) \;|\; (b_1 \Leftrightarrow b_2)\) mit \(a_1, a_2 \in \Aexp \) und \(b, b_1, b_2 \in \Bexp \). Die Klammern ko&#x0308;nnen weggelassen werden, wenn klar ist, was geklammert ist.<br
/>
Boolesche Ausdru&#x0308;cke ko&#x0308;nnen ebenfalls zusammen mit einem Speicherzustand zu einem Wahrheitswert \(t \in \B \) ausgewertet werden, d.&#x202f;h. die Auswertung ist eine Funktion \(\Bexp \times
\Sigma \rightarrow \B \), die wie u&#x0308;blich definiert ist. Wiederum kann man die Auswertung als Funktion \(\mathcal {B}\colon \Bexp \rightarrow (\Sigma \rightarrow \B )\) auffassen, wobei man fu&#x0308;r
\((b, \sigma ) \mapsto t\) auch \((\mathcal {B}(b))(\sigma ) = t\) schreiben kann (mit \(b \in \Bexp \), \(\sigma \in \Sigma \) und \(t \in \B \)).
</p>

<p>
<b>\(\IMP \)-Programme</b>:&#x2003; Die Menge \(\IMP = \Cmd \) der <em><span class="dashuline" >IMP-Programme</span></em> ist definiert durch<br />
\(c ::= \text {skip} \;|\; X := a \;|\; c_1;\; c_2 \;|\; \text {if } b \text { then } c_1 \text { else } c_2 \text { fi} \;|\; \text {while } b \text { do } c \text { od}\)<br />
mit \(X \in \V \), \(a \in \Aexp \), \(b \in \Bexp \) und \(c, c_1, c_2 \in \Cmd \).<br />
Einem gegebenen Programm \(c \in \Cmd \) und einem Speicherzustand \(\sigma \in \Sigma \) wird ein neuer Speicherzustand \(\sigma ’ \in \Sigma \) zugeordnet durch eine intuitiv definierte Abbildung \(\Cmd \times
\Sigma \rightarrow _p \Sigma \) bzw. \(\mathcal {C}\colon \Cmd \rightarrow (\Sigma \rightarrow _p \Sigma )\). Dabei ist \((\mathcal {C}(c))(\sigma )\) definiert genau dann, wenn das Programm \(c\) bei
Eingabe von \(\sigma \) nach einer endlichen Zahl an Schritten terminiert.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>WHILE-Programme</b>:&#x2003; Die Menge WHILE der <em><span class="dashuline" >WHILE-Programme</span></em> ist definiert durch<br />
\(c ::= X := a \;|\; c_1; c_2 \;|\; \text {while } X \not = 0 \text { do } c \text { od}\) fu&#x0308;r \(X \in \V \) und \(c, c_1, c_2 \in \text {WHILE}\).
</p>

<p>
<b>LOOP-Programme</b>:&#x2003; Die Menge LOOP der <em><span class="dashuline" >LOOP-Programme</span></em> ist definiert durch<br />
\(c ::= X := a \;|\; c_1; c_2 \;|\; \text {loop } X \text { do } c \text { od}\) fu&#x0308;r \(X \in \V \) und \(c, c_1, c_2 \in \text {LOOP}\).<br />
Eine LOOP-Schleife wird dabei solange ausgefu&#x0308;hrt, wie der Wert von \(X\) zu Beginn angibt (A&#x0308;nderungen werden nicht beru&#x0308;cksichtigt).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<em>Bemerkung</em>: WHILE- und LOOP-Programme sind nach Definition IMP-Programme.<br />
Jedes IMP-Programm kann als WHILE-Programm geschrieben werden.<br />
Damit sind WHILE- und IMP-Programme gleichma&#x0308;chtig.
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >IMP-Programme Turing-berechenbar</span>):</span> IMP-Programme sind Turing-berechenbar.
</p>

<p>
<b>Folgerung</b>: Jedes WHILE-Programm (C, C++, Ada usw.) ist Turing-berechenbar.
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >TM WHILE-berechenbar</span>):</span> Jede Turingmaschine ist <em><span class="dashuline" >WHILE-berechenbar</span></em>, d.&#x202f;h. es gibt ein
WHILE-Programm, das die von der TM berechnete Funktion berechnet.
</p>

<p>
<b>Beweis</b>: Sei \(M = (Q, \Sigma , \Gamma , \delta , q_0, \{q_f\}, \Box )\) eine deterministische Einband-TM mit \(\Sigma = \{1\}\), \(\Gamma = \{0, 1\}\) und \(\Box = 0\). Zu zeigen ist, dass die von \(M\)
berechnete, partiell definierte Funktion \(f_M\colon \natural \rightarrow _p \natural \) WHILE-berechenbar ist. OBdA sei \(Q = \{0, 1, \dotsc , n\}\) mit \(q_f = 0\) und \(q_0 = 1\).<br />
Konfigurationen sind Wo&#x0308;rter \(uqv\) mit \(u \in 0\{0, 1\}^\ast \) und \(v \in \{0, 1\}^\ast 0\). Fu&#x0308;r \(a_1 \dotsb a_n \in \Sigma \) definiere \(\overleftarrow {a_1 \dotsb a_n} := a_n
\dotsb a_1\). Lies nun fu&#x0308;r einen Zustandsu&#x0308;bergang \(u \in \natural \) richtig herum, aber \(\overleftarrow {v} \in \natural \) falsch herum ein. Die U&#x0308;bergangstabelle von \(\delta
\subset Q \times \Gamma \times Q \times \Gamma \times \{L, R, N\}\) ist eine Tabelle mit \(|\delta |\) vielen Zeilen. Eine Zeile ko&#x0308;nnte z.&#x202f;B. so aussehen: \((i, 1, j, 0, L)\).<br />
Dies entspricht \(\dotsb c i 1 \dotsb \vdash \dotsb j c 0 \dotsb \). In IMP ko&#x0308;nnte man das durch<br />
\(\text {if } ((q = i) \land \text {odd}(v)) \text { then } v := 2 \cdot (v - 1) + c;\; u := u \text { div } 2;\; q := j \text { fi}\) darstellen (\(\Loc = \{q, u, v\}\)). Genauso behandelt man die
anderen Fa&#x0308;lle. Das IMP-Programm hat dann am Ende folgende Form: \(q = 1;\; \text {while } q \ge 1 \text { do } \dotsb \text { if } \dotsb \text { then } \dotsb \text { fi} \dotsb \text {
od}\). &#x2003;&#x2003;
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" ><span class="textsc" >Kleene</span>sche Normalform fu&#x0308;r WHILE-Programme</span>):</span> Jedes WHILE-Programm kann in ein
gleichwertiges IMP-Programm umgeschrieben werden, das mit nur einer einzigen a&#x0308;ußeren WHILE-Schleife auskommt und innerhalb der Schleife nur IF-Abfragen verwendet.
</p>

<p>
<b>Beweis</b>: Man forme das WHILE-Programm in eine TM um und diese anschließend in ein WHILE-Programm nach dem konstruktiven Beweis von eben. &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<em>Bemerkung</em>: LOOP-Programme sind WHILE-berechenbar.
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >LOOP-berechenbar \(\iff \) primitiv-rekursiv</span>):</span> Sei \(f\colon \natural ^k \rightarrow \natural \).<br />
Dann ist \(f\) <em><span class="dashuline" >LOOP-berechenbar</span></em> (es gibt ein LOOP-Programm, das \(f\) berechnet) genau dann, wenn \(f\) primitv-rekursiv ist.
</p>

<p>
<em>Bemerkung</em>: Damit sind nicht alle Turing-berechenbaren Funktionen LOOP-berechenbar.
</p>



<h2 id="mu-rekursive-funktionen">μ-rekursive Funktionen</h2>

</p>


<p>
<b>\(\mu \)-Operator</b>:&#x2003; Sei \(f\colon \natural ^{k+1} \rightarrow _p \natural \) eine partiell definierte Funktion.<br />
Dann ist der <em><span class="dashuline" >\(\mu \)-Operator</span></em> definiert durch \(\mu f\colon \natural ^k \rightarrow _p \natural \) mit<br />
\((\mu f)(n_1, \dotsc , n_k) := \min \{m \in \natural \;|\; f(m, n_1, \dotsc , n_k) = 0,\; \forall _{i = 0, \dotsc , m}\; f(i, n_1, \dotsc , n_k) \text { definiert}\}\)<br />
(fu&#x0308;r \(\{\dotsb \} = \emptyset \) sei \((\mu f)(n_1, \dotsc , n_k)\) nicht definiert).
</p>

<p>
<b>\(\mu \)-rekursive Funktion</b>:&#x2003; Die Klasse der <em><span class="dashuline" >\(\mu \)-rekursiven Funktionen</span></em> ist eine Teilmenge der partiell definierten Funktionen \(\natural ^k \rightarrow
_p \natural \) mit \(k \in \natural \), die wie folgt definiert ist:
</p>
<ul style="list-style-type:none">

<li class="list-item-f25"><p>Jede primitv-rekursive Funktion ist \(\mu \)-rekursiv.
</p>
</li>
<li class="list-item-f26"><p>\(\mu f\colon \natural ^k \rightarrow _p \natural \) ist \(\mu \)-rekursiv, falls \(f\colon \natural ^{k+1} \rightarrow _p \natural \) \(\mu \)-rekursiv ist.
</p>
</li>
</ul>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >WHILE-berechenbar \(\iff \) \(\mu \)-rekursiv</span>):</span> Sei \(f\colon \natural ^k \rightarrow \natural \).<br />
Dann ist \(f\) WHILE-berechenbar genau dann, wenn \(f\) \(\mu \)-rekursiv ist.
</p>

<p>
<em>Bemerkung</em>: Also sind die Turing-/WHILE-berechenbaren Funktionen und die \(\mu \)-rekursiven Funktionen identisch.
</p>



<h2 id="zusatz-praedikatenlogik-erster-stufe">Zusatz: Prädikatenlogik erster Stufe</h2>

</p>


<p>
<b>mo&#x0308;gliche Symbole</b>:&#x2003; Die in der Pra&#x0308;dikatenlogik erster Stufe <em><span class="dashuline" >mo&#x0308;glichen Symbole</span></em> sind:
</p>
<ul style="list-style-type:none">

<li class="list-item-f27"><p><em><span class="dashuline" >logische Symbole</span></em>: \(\forall \), \(\exists \), \(\land \), \(\lor \), \(\lnot \), \(\Rightarrow \), \(\Leftrightarrow \), \((\), \()\), \(=\) und \(,\)
</p>
</li>
<li class="list-item-f28"><p><em><span class="dashuline" >Variablensymbole</span></em>: \(A_1, A_2, A_3, \dotsc \)
</p>
</li>
<li class="list-item-f29"><p>Menge \(\C \) von <em><span class="dashuline" >Konstantensymbole</span></em>
</p>
</li>
<li class="list-item-f30"><p>Menge \(\F \) von <em><span class="dashuline" >Funktionssymbole</span></em> mit einer bestimmten natu&#x0308;rlichen Zahl als Stelligkeit
</p>
</li>
<li class="list-item-f31"><p>Menge \(\R \) von <em><span class="dashuline" >Relationssymbole</span></em> mit einer bestimmten natu&#x0308;rlichen Zahl als Stelligkeit
</p>
</li>
</ul>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Term</b>:&#x2003; Ein <em><span class="dashuline" >Term</span></em> ist induktiv wie folgt definiert:
</p>
<ul style="list-style-type:none">

<li class="list-item-f32"><p>Jedes Variablensymbol \(x\) ist ein Term.
</p>
</li>
<li class="list-item-f33"><p>Jedes Konstantensymbol \(c\) ist ein Term.
</p>
</li>
<li class="list-item-f34"><p>Ist \(f\) ein \(n\)-stelliges Funktionssymbol und sind \(t_1, \dotsc , t_n\) Terme, so ist \(f(t_1, \dotsc , t_n)\) ein Term.
</p>
</li>
</ul>

<p>
<b>Variablen, die in einem Term vorkommen</b>:&#x2003;<br />
Die <em><span class="dashuline" >Variablen \(\var (t)\)</span></em>, die in einem Term \(t\) vorkommen, sind induktiv wie folgt definiert:
</p>
<ul style="list-style-type:none">

<li class="list-item-f35"><p>\(\var (x) := \{x\}\) fu&#x0308;r ein Variablensymbol \(x\)
</p>
</li>
<li class="list-item-f36"><p>\(\var (c) := \emptyset \) fu&#x0308;r ein Konstantensymbol \(c\)
</p>
</li>
<li class="list-item-f37"><p>\(\var (f(t_1, \dotsc , t_n)) := \var (t_1) \cup \dotsb \cup \var (t_n)\) fu&#x0308;r ein \(n\)-stelliges Funktionssymbol \(f\) und \(t_1, \dotsc , t_n\) Terme
</p>
</li>
</ul>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Ausdruck</b>:&#x2003; Ein <em><span class="dashuline" >Ausdruck</span></em> oder eine <em><span class="dashuline" >Formel</span></em> ist induktiv wie folgt definiert:
</p>
<ul style="list-style-type:none">

<li class="list-item-f38"><p>Fu&#x0308;r \(t_1\) und \(t_2\) Terme ist \((t_1 = t_2)\) ein Ausdruck.
</p>
</li>
<li class="list-item-f39"><p>Ist \(R\) ein \(n\)-stelliges Relationssymbol und sind \(t_1, \dotsc , t_n\) Terme, so ist \(R(t_1, \dotsc , t_n)\) ein Ausdruck.
</p>
</li>
<li class="list-item-f40"><p>Ist \(\varphi \) ein Ausdruck, so auch \((\lnot \varphi )\).
</p>
</li>
<li class="list-item-f41"><p>Sind \(\varphi \) und \(\psi \) Ausdru&#x0308;cke, so auch \((\varphi \land \psi )\), \((\varphi \lor \psi )\), \((\varphi \Rightarrow \psi )\) und \((\varphi \Leftrightarrow \psi )\).
</p>
</li>
<li class="list-item-f42"><p>Ist \(\varphi \) ein Ausdruck und \(x\) ein Variablensymbol, dann sind auch \(\forall _x \varphi \) und \(\exists _x \varphi \) Ausdru&#x0308;cke.
</p>
</li>
</ul>

<p>
Die nach den ersten beiden Regeln erstellten Ausdru&#x0308;cke heißen <em><span class="dashuline" >atomar</span></em>.<br />
Klammern ko&#x0308;nnen ggf. auch weggelassen werden.
</p>

<p>
<b>Sprache erster Stufe</b>:&#x2003; Man fasst \(\C \), \(\F \) und \(\R \) zur <em><span class="dashuline" >Signatur</span></em> oder <em><span class="dashuline" >Symbolmenge</span></em> \(S\) zusammen.
Die <em><span class="dashuline" >Sprache erster Stufe</span></em> \(L_I^S\) ist die Menge aller u&#x0308;ber \(S\) gu&#x0308;ltigen Ausdru&#x0308;cke.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>freie Variablen</b>:&#x2003;<br />
Die <em><span class="dashuline" >freien Variablen \(\frei (\varphi )\)</span></em> eines Ausdrucks \(\varphi \) sind induktiv wie folgt definiert:
</p>
<ul style="list-style-type:none">

<li class="list-item-f43"><p>\(\frei   (t_1 = t_2) := \var (t_1) \cup \var (t_2)\) fu&#x0308;r Terme \(t_1\) und \(t_2\)
</p>
</li>
<li class="list-item-f44"><p>\(\frei   (R(t_1, \dotsc , t_n)) := \var (t_1) \cup \dotsb \cup \var (t_n)\) fu&#x0308;r \(R\) ein \(n\)-stelliges Relationssymbol und \(t_1, \dotsc , t_n\) Terme
</p>
</li>
<li class="list-item-f45"><p>\(\frei   (\lnot \varphi ) := \frei (\varphi )\) fu&#x0308;r einen Ausdruck \(\varphi \)
</p>
</li>
<li class="list-item-f46"><p>\(\frei   (\varphi \ast \psi ) := \frei (\varphi ) \cup \frei (\psi )\) fu&#x0308;r Ausdru&#x0308;cke \(\varphi \) und \(\psi \) und \(\ast \in \{\land , \lor , \Rightarrow , \Leftrightarrow \}\)
</p>
</li>
<li class="list-item-f47"><p>\(\frei   (\forall _x \varphi ), \frei (\exists _x \varphi ) := \frei (\varphi ) \setminus \{x\}\) fu&#x0308;r einen Ausdruck \(\varphi \) und ein Variablensymbol \(x\)
</p>
</li>
</ul>

<p>
Nicht-freie Variablen heißen <em><span class="dashuline" >gebunden</span></em>.
</p>

<p>
<b>geschlossene Formel</b>:&#x2003; Eine <em><span class="dashuline" >geschlossene Formel</span></em> oder ein <em><span class="dashuline" >Satz</span></em> ist eine Formel \(F\) ohne freie Variable,
d.&#x202f;h. \(\frei (F) = \emptyset \).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>passende Struktur</b>:&#x2003; Eine <em><span class="dashuline" >passende Struktur</span></em> \(\A \) fu&#x0308;r eine Signatur \(S\) ist eine nicht-leere Menge \(A\) zusammen mit:
</p>
<ul style="list-style-type:none">

<li class="list-item-f48"><p>einem Element \(c^\A \in A\) fu&#x0308;r jedes Konstantensymbol \(c\)
</p>
</li>
<li class="list-item-f49"><p>einer Funktion \(f^\A \colon A^n \rightarrow A\) fu&#x0308;r jedes \(n\)-stellige Funktionssymbol \(f\)
</p>
</li>
<li class="list-item-f50"><p>einer Relation \(R^\A \subset A^n\) fu&#x0308;r jedes \(n\)-stellige Relationssymbol \(R\)
</p>
</li>
</ul>

<p>
<b>Belegung</b>:&#x2003;<br />
Eine Belegung \(\beta \) einer passenden Struktur \(\A \) ist eine Abbildung \(\beta \colon \{A_i \;|\; i \in \natural \} \rightarrow A\).
</p>

<p>
<b>Interpretation</b>:&#x2003; Eine <em><span class="dashuline" >Interpretation</span></em> einer Sprache \(L_I^S\) ist ein Paar \(\I = (\A , \beta )\) mit einer passenden Struktur \(\A \) und einer Belegung
\(\beta \). Ein Term \(t\) kann wie folgt induktiv interpretiert werden:
</p>
<ul style="list-style-type:none">

<li class="list-item-f51"><p>\(\I (x) := \beta (x)\) fu&#x0308;r eine Variable \(x\)
</p>
</li>
<li class="list-item-f52"><p>\(\I (c) := c^\A \) fu&#x0308;r ein Konstantensymbol \(c\)
</p>
</li>
<li class="list-item-f53"><p>\(\I (f(t_1, \dotsc , t_n)) := f^\A (\I (t_1), \dotsc , \I (t_n))\) fu&#x0308;r ein \(n\)-stelliges Funktionssymbol \(f\) und Terme \(t_1, \dotsc , t_n\)
</p>
</li>
</ul>

<p>
<b>gea&#x0308;nderte Belegung</b>:&#x2003; Ist eine Interpretation \(\I = (\A , \beta )\) gegeben, dann sei \(\beta \frac {a}{x}\) fu&#x0308;r \(a \in A\) und \(x\) Variablensymbol die <em><span
class="dashuline" >gea&#x0308;nderte Belegung</span></em>, die \(x\) auf \(a\) abbildet und sonst alles wie \(\beta \). \(\I \frac {a}{x} := (\A , \beta \frac {a}{x})\) ist die <em><span class="dashuline"
>gea&#x0308;nderte Interpretation</span></em>.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Modell</b>:&#x2003; Eine Interpretation \(\I = (\A , \beta )\) heißt <em><span class="dashuline" >Modell</span></em> fu&#x0308;r einen Ausdruck \(\varphi \) (\(\I \models \varphi \)), falls induktiv:
</p>
<ul style="list-style-type:none">

<li class="list-item-f54"><p>\(\I \models (t_1 = t_2)\), falls \(\I (t_1) = \I (t_2)\) (fu&#x0308;r Terme \(t_1\) und \(t_2\))
</p>
</li>
<li class="list-item-f55"><p>\(\I \models R(t_1, \dotsc , t_n)\), falls \(R^\A (\I (t_1), \dotsc , \I (t_n))\) (fu&#x0308;r ein \(n\)-stelliges Relationssymbol \(R\) und Terme \(t_1, \dotsc , t_n\))
</p>
</li>
<li class="list-item-f56"><p>\(\I \models (\lnot \varphi )\), falls \(\lnot (\I \models \varphi )\) (fu&#x0308;r einen Ausdruck \(\varphi \))
</p>
</li>
<li class="list-item-f57"><p>\(\I \models (\varphi \ast \psi )\), falls \((\I \models \varphi ) \ast (\I \models \psi )\) (fu&#x0308;r Ausdru&#x0308;cke \(\varphi \) und \(\psi \) und \(\ast \in \{\land , \lor , \Rightarrow ,
\Leftrightarrow \}\))
</p>
</li>
<li class="list-item-f58"><p>\(\I \models \forall _x \varphi \), falls \(\forall _{a \in A}\; (\I \frac {a}{x} \models \varphi )\), bzw. \(\I \models \exists _x \varphi \), falls \(\exists _{a \in A}\; (\I \frac {a}{x} \models
\varphi )\)<br />
(fu&#x0308;r einen Ausdruck \(\varphi \) und ein Variablensymbol \(x\))
</p>
</li>
</ul>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Tautologie</b>:&#x2003;<br />
Eine Tautologie ist eine Formel \(F\), sodass alle passenden Strukturen Modelle fu&#x0308;r \(F\) sind.
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >Satz von &#x202f;<span class="textsc" >Go&#x0308;del</span></span>):</span><br />
\(\TAUT (1) = \{F \;|\; F \text { ist Tautologie in der Prädikatenlogik erster Stufe}\}\) ist unentscheidbar.
</p>

<p>
<b>Beweis</b>: Sei ein beliebiges PKP gegeben. Dies kann nach obiger Bemerkung auch folgendermaßen formuliert werden: Gegeben sind Homomorphismen \(f, g\colon \{1, \dotsc , k\}^\ast \rightarrow \Sigma ^\ast
\).<br />
Gibt es \(w \in \{1, \dotsc , k\}^\ast \), \(z \in \Sigma ^\ast \) und \(a \in \Sigma \) mit \(f(w) = g(w) = az\)?<br />
Man kann fu&#x0308;r beliebige \(a \in \Sigma \) ein einstelliges Funktionssymbol \(a\colon \Sigma ^\ast \rightarrow \Sigma ^\ast \) definieren durch \(a(w) = aw\). Dadurch kann man fu&#x0308;r \(u = u_1
\dotsb u_n\), \(u_i \in \Sigma \) ein einstelliges Funktionssymbol \(u\colon \Sigma ^\ast \rightarrow \Sigma ^\ast \) mit \(u(w) = uw = u_1(u_2(\dotsb u_n(w) \dotsb ))\) definieren.<br />
Fu&#x0308;r ein zweistelliges Relationssymbol \(P\) kann man nun in Abha&#x0308;ngigkeit von \(f\) und \(g\) eine Formel \(A(f, g) := (P(\varepsilon , \varepsilon ) \land \bigwedge _{j=1}^k \forall _x
\forall _y\; (P(x, y) \Rightarrow P(u_j(x), v_j(y))))\) definieren. Interpretiere nun \(P\) u&#x0308;ber \(\Sigma ^\ast \) durch die Relation \(R := \{(f(w), g(w)) \;|\; w \in \{1, \dotsc , k\}^\ast
\}\).<br />
Damit wird \(\Sigma ^\ast \) zu einem Modell von \(A(f, g)\): Es gilt \((\varepsilon , \varepsilon ) \in R\) (fu&#x0308;r \(w = \varepsilon \in \{1, \dotsc , k\}^\ast \)) und fu&#x0308;r \(u = f(w)\) und
\(v = g(w)\) mit \(w \in \{1, \dotsc , k\}^\ast \) beliebig (d.&#x202f;h. \((u, v) \in R\)) gilt stets auch \((u_j u, v_j v) \in R\), weil \(u_j u = f(j w)\) und \(v_j v = f(j w)\) (wa&#x0308;hle also
\(\widetilde {w} = jw\) in der Definition von \(R\)) fu&#x0308;r beliebige \(j = 1, \dotsc , k\).<br />
Definiere nun die Formel \(F(f, g) := (A(f, g) \Rightarrow \exists _z\; P(a(z), a(z)))\). Damit gilt: \(F(f, g)\) ist eine Tautologie genau dann, wenn das PKP lo&#x0308;sbar ist, denn:<br />
„\(\Rightarrow \)“: Sei das PKP unlo&#x0308;sbar. Dann wa&#x0308;hle als passende Struktur \(\Sigma ^\ast \) wie eben. Es gibt kein \(z \in \Sigma ^\ast \) mit \((az, az) \in R\), denn sonst wa&#x0308;re \(az =
f(w) = g(w)\) und das PKP wa&#x0308;re lo&#x0308;sbar. Also ist \(F(f, g)\) keine Tautologie, weil die linke Seite der Implikation wahr ist (\(\Sigma ^\ast \) ist ein Modell von \(A(f, g)\)) und die rechte nicht.<br />
„\(\Leftarrow \)“: Sei das PKP lo&#x0308;sbar mit Lo&#x0308;sung \(az = f(i_1 \dotsb i_m) = u_{i_1} \dotsb u_{i_m} = v_{i_1} \dotsb v_{i_m} = g(i_1 \dotsb i_m)\). Dann gilt \(u_{i_1}(u_{i_2}(\dotsb
u_{i_m}(\varepsilon ) \dotsb )) = a(z(\varepsilon )) = v_{i_1}(v_{i_2}(\dotsb v_{i_m}(\varepsilon ) \dotsb ))\). Mit Induktion nach \(m\) folgt die Behauptung.<br />
Weil (PKP lo&#x0308;sbar?) im Allgemeinen nicht entscheidbar ist, ist auch nicht entscheidbar, ob \(F(f, g)\) eine Tautologie ist. &#x2003;&#x2003;
</p>



<h2 id="der-goedelsche-unvollstaendigkeitssatz">Der <span style="font-variant: small-caps;">Gödel</span>sche Unvollständigkeitssatz</h2>

</p>


<p>
<b>arithmetischer Term</b>:&#x2003; Ein <em><span class="dashuline" >arithmetischer Term</span></em> ist definiert durch<br />
\(a ::= n \;|\; x \;|\; (a_1 + a_2) \;|\; (a_1 - a_2) \;|\; (a_1 \cdot a_2)\) fu&#x0308;r \(n \in \natural _0\), \(x \in \V \) und arithmetische Terme \(a_1, a_2\).
</p>

<p>
<b>arithmetische Formel</b>:&#x2003; Eine <em><span class="dashuline" >arithmetische Formel</span></em> ist definiert durch<br />
\(b ::= \text {true} \;|\; (a_1 &lt; a_2) \;|\; (F_1 \land F_2) \;|\; (F_1 \lor F_2) \;|\; (\lnot F) \;|\; \forall _x F \;|\; \exists _x F\) fu&#x0308;r \(x \in \V \) und arithmetische Formeln \(F,
F_1, F_2\).<br />
Arithmetische Formeln ko&#x0308;nnen intuitiv zu Wahrheitswerten ausgewertet werden, falls eine Belegung der Variablen aus \(\V \) gegeben ist.
</p>

<p>
<b>arithmetische Darstellung</b>:&#x2003; Eine partielle Funktion \(f\colon \natural _0^k \rightarrow _p \natural _0^\ell \) <em><span class="dashuline" >hat eine arithmetische Darstellung</span></em>, falls es
eine arithmetische Formel \(F\) gibt, sodass \(\forall _{x_1, \dotsc , x_k, y_1, \dotsc , y_\ell \in \natural _0}\)<br />
\(F(x_1, \dotsc , x_k, y_1, \dotsc , y_\ell ) \text { wahr} \iff (f(x_1, \dotsc , x_k) \text { definiert } \land f(x_1, \dotsc , x_k) = (y_1, \dotsc , y_\ell ))\).<br />
\(F\) heißt in diesem Fall <em><span class="dashuline" >arithmetische Darstellung</span></em> von \(f\).
</p>

<p>
<em>Beispiel</em>: Die Addition \(\add \colon \natural _0 \times \natural _0 \rightarrow \natural _0\) hat die arithmetische Darstellung<br />
\(F(x, y, z) = (\lnot (z &lt; (x + y)) \land \lnot ((x + y) &lt; z))\). Die Restabbildung \(\mod \colon \natural _0 \times \natural _0 \rightarrow _p \natural _0\) hat die arithmetische Darstellung
\(F(a, n, r) = (\exists _k\; a = k \cdot n + r \land r &lt; n)\).<br />
Genauso haben \(\text {div}\), \(\text {sq}\) und \(\text {exp}\) arithmetische Darstellungen usw.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b><span class="textsc" >Go&#x0308;del</span>sches \(\beta \)-Pra&#x0308;dikat</b>:&#x2003; Sei \(f\colon \natural _0^3 \rightarrow \natural _0\), \(f(a, b, i) := a \mod (1 + (i + 1)b)\).<br />
Dann ist \(\beta (a, b, i, n) := ((n &lt; 1 + (i + 1)b) \land (\exists _k\; a = n + k(1 + (i + 1)b)))\) eine arithmetische Darstellung von \(f\) und heißt <em><span class="dashuline" ><span
class="textsc" >Go&#x0308;del</span>sches \(\beta \)-Pra&#x0308;dikat</span></em>.
</p>

<p>
<em>Bemerkung</em>: Das folgende Lemma besagt, dass man zwei Zahlen \(a\) und \(b\) finden kann, sodass ein \(k\)-Tupel \((n_0, \dotsc , n_k) \in \natural _0^{k+1}\) in \(f(a, b, i)\) „gespeichert“ werden kann.
</p>

<p>
<em>Lemma</em> (<span class="textsl" ><span class="textsc" >Go&#x0308;del</span>sches \(\beta \)-Lemma</span>): Seien \(k \in \natural _0\) und \((n_0, \dotsc , n_k) \in \natural _0^{k+1}\).<br />
Dann gibt es \(a, b \in \natural \) mit \(n_i = f(a, b, i)\) fu&#x0308;r \(i = 0, \dotsc , k\).
</p>

<p>
<b>Beweis</b>: Definiere \(b := (\max \{k, n_0, \dotsc , n_k\})!\) und \(b_i := 1 + (i + 1)b\).
</p>

<p>
Dann gilt fu&#x0308;r \(i \not = j\), dass \(\text {ggT}(b_i, b_j) = 1\), denn: OBdA sei \(i &lt; j\) und \(p\) prim mit \(p \;|\; b_i\) und \(p \;|\; b_j\). Dann teilt \(p\) auch \(b_j - b_i = (j - i)b\). Nach
Konstruktion von \(b\) gilt \((j - i) \;|\; b\) wegen \(j - i \le k\). Somit muss \(p \;|\; b\) gelten (\(p\) teilt \(j - i\) oder \(b\) und \(j - i\) teilt \(b\)). Allerdings teilt \(p\) nach Voraussetzung \(b_i = 1 + (i +
1)b\). Weil \(p\) den zweiten Summanden teilt, muss \(p\) auch den ersten Summanden \(1\) teilen, ein Widerspruch.
</p>

<p>
Nun wird behauptet, dass fu&#x0308;r alle \(n_1, n_2 \in \natural _0\) es eine natu&#x0308;rliche Zahl \(a \in \natural _0\) gibt mit \(a \equiv n_1 \mod b_1\) und \(a \equiv n_2 \mod b_2\). Eine solche
Lo&#x0308;sung ist a&#x0308;quivalent zur Existenz von \(k, \ell \in \integer \) mit \(a = n_1 + kb_1 = n_2 + \ell b_2\), d.&#x202f;h. \(n_2 - n_1 = kb_1 - \ell b_2\). Nach dem erweiterten euklidischen
Algorithmus gibt es \(\alpha , \beta \in \integer \) mit \(1 = \text {ggT}(b_1, b_2) = \alpha b_1 + \beta b_2\). Also muss \((n_2 - n_1)(\alpha b_1 + \beta b_2) = kb_1 - \ell b_2\) gelten. Dies ist
allerdings erfu&#x0308;llt, wenn man \(k := (n_2 - n_1)\alpha \) und \(\ell := (n_1 - n_2)\beta \) wa&#x0308;hlt, d.&#x202f;h. die obige Lo&#x0308;sung existiert. Sie ist in den natu&#x0308;rlichen Zahlen, wenn
man oft genug \(b_1 \cdot b_2\) addiert.
</p>

<p>
Induktiv gibt es also eine natu&#x0308;rliche Zahl \(a \in \natural \) mit \(a \equiv n_i \mod b_i\) fu&#x0308;r \(i = 0, \dotsc , k\). Wegen \(n_i \le b &lt; b_i\) gilt \(f(a, b, i) = a \mod b_i = n_i \mod
b_i = n_i\). &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >IMP-Programme arithmetisch darstellbar</span>):</span> Sei \(c \in \Cmd \) ein IMP-Programm.<br />
Dann existiert effektiv (d.&#x202f;h. berechenbar) eine arithmetische Darstellung \(F_c\) der Funktion \(\C (c)\colon \natural _0^k \rightarrow _p \natural _0^k\). Diese hat die Form \(F_c(\underline {X},
\underline {Y}) = (\exists _T\; G_c(T, \underline {X}, \underline {Y}))\), wobei \(G_c\) nur beschra&#x0308;nkte Quantoren der Form \(\exists _{x \le T}\) und \(\forall _{x \le T}\) entha&#x0308;lt und
\(G_c(T, \underline {X}, \underline {Y}) \Rightarrow G_c(\widehat {T}, \underline {X}, \underline {Y})\) fu&#x0308;r alle \(\widehat {T} \ge T\) und \(\underline {X} = (x_1, \dotsc , x_k)\) und
\(\underline {Y} = (y_1, \dotsc , y_k)\).
</p>

<p>
<b>Beweis</b>: Der Beweis erfolgt strukturell induktiv u&#x0308;ber den Aufbau von \(c \in \Cmd \).
</p>

<p>
Sei \(F_\text {skip}(\underline {X}, \underline {Y}) := (\underline {X} = \underline {Y}) = ((x_1 = y_1) \land \dotsb \land (x_k = y_k))\). Fu&#x0308;r die gewu&#x0308;nschte Form kann man dies
ohne Probleme umschreiben zu \((\exists _T\; \underline {X} = \underline {Y})\).
</p>

<p>
Sei \(F_{x_j := a}(\underline {X}, \underline {Y}) := ((x_j = a(\underline {X})) \land (x_1 = y_1) \land \dotsb \land (x_{j-1} = y_{j-1}) \land (x_{j+1} = y_{j+1}) \land \dotsb \land (x_k =
y_k))\).<br />
Auch hier kann man ohne Probleme \((\exists _T\; \cdots )\) schreiben, da keine Quantoren vorkommen.
</p>

<p>
Sei \(F_{c_1; c_2}(\underline {X}, \underline {Y}) := (\exists _{\underline {Z}}\; F_{c_1}(\underline {X}, \underline {Z}) \land F_{c_2}(\underline {Z}, \underline {Y}))\). Hier muss man das
umschreiben zu<br />
\((\exists _T \exists _{\underline {Z} \le T}\; G_{c_1}(T, \underline {X}, \underline {Z}) \land G_{c_2}(T, \underline {Z}, \underline {Y}))\), wobei \(\underline {Z} \le T\) komponentenweise zu
lesen ist.
</p>

<p>
Sei \(F_{\text {if } b \text { then } c_1 \text { else } c_2 \text { fi}}(\underline {X}, \underline {Y}) := ((b(\underline {X}) \Rightarrow F_{c_1}(\underline {X}, \underline {Y})) \land
(\lnot b(\underline {X}) \Rightarrow F_{c_2}(\underline {X}, \underline {Y})))\). Hier muss man das ebenfalls umschreiben zu \((\exists _T\; ((b(\underline {X}) \Rightarrow G_{c_1}(T, \underline
{X}, \underline {Y})) \land (\lnot b(\underline {X}) \Rightarrow G_{c_2}(T, \underline {X}, \underline {Y}))))\).
</p>

<p>
Sei \(\widetilde {F}_{\text {while } b \text { do } c \text { od}}(\underline {X}, \underline {Y}) := (\exists _t \exists _{\underline {n_0}} \dotsb \exists _{\underline {n_t}} (\underline
{n_0} = \underline {X}) \land (\lnot b(\underline {Y})) \land (\forall _{i \le t - 1}\; F_c(\underline {n_i}, \underline {n_{i+1}}) \land b(\underline {n_i})))\). Dies ist allerdings keine
arithmetische Formel, da die Zahl der Quantoren variieren kann. Um das zu beheben, bedient man sich des Go&#x0308;delschen \(\beta \)-Pra&#x0308;dikats, das zuna&#x0308;chst durch \(\beta (\underline {a},
\underline {b}, i, \underline {n}) := \bigwedge _{j=1}^n \beta (a_j, b_j, i, n_j)\) auf Vektoren ausgeweitet wird. Damit kann man das umschreiben zu<br />
\(F_{\text {while } b \text { do } c \text { od}}(\underline {X}, \underline {Y}) := (\exists _t \exists _{\underline {a}, \underline {b}}\; \beta (\underline {a}, \underline {b}, 0,
\underline {X}) \land \beta (\underline {a}, \underline {b}, t, \underline {Y}) \land (\lnot b(\underline {Y})) \;\land \)<br />
\((\forall _{i \le t - 1} \exists _{\underline {m}, \underline {n}}\; \beta (\underline {a}, \underline {b}, i, \underline {m}) \land \beta (\underline {a}, \underline {b}, i + 1, \underline
{n}) \land F_c(\underline {m}, \underline {n}) \land b(\underline {m})))\). Fu&#x0308;r die gewu&#x0308;nschte Form muss man das umformen zu \((\exists _T \exists _{t \le T} \exists _{\underline
{a}, \underline {b} \le T}\; \beta (\underline {a}, \underline {b}, 0, \underline {x}) \land \beta (\underline {a}, \underline {b}, t, \underline {Y}) \land (\lnot b(\underline {Y})) \;\land
\)<br />
\((\forall _{i \le T} \exists _{\underline {m}, \underline {n} \le T}\; \beta (\underline {a}, \underline {b}, i, \underline {m}) \land \beta (\underline {a}, \underline {b}, i + 1,
\underline {n}) \land G_c(\underline {m}, \underline {n}) \land b(\underline {m})))\). &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Folgerung</b>: Eine Funktion \(f\colon \natural _0^k \rightarrow _p \natural _0^\ell \) ist berechenbar genau dann, wenn \(f\) eine arithmetische Darstellung der Form \(\exists _T\; G(T, \underline {X},
\underline {Y})\) besitzt, wobei \(G\) nur \(T\)-beschra&#x0308;nkte Quantoren benutzt.
</p>

<p>
<b>Beweis</b>: Die eine Richtung des Beweises ist der obige Satz. Fu&#x0308;r die andere Richtung kann man bei gegebenen \(T\), \(\underline {X}\) und \(\underline {Y}\) den Wert \(G(T, \underline {X}, \underline
{Y})\) bestimmen. Also berechnet folgendes Programm \(f\): \(\text {for } (T, \underline {Y}) \in \natural _0^{k+1} \text { do} \text { if } G(T, \underline {X}, \underline {Y}) \text { then} \text
{ return } \underline {Y} \text { fi} \text { od}\). &#x2003;&#x2003;
</p>

<p>
<span
      class="textcolor"
      style="color:#808080"
>
</span>
</p>

<p>
<b>formales Beweissystem</b>:&#x2003; Seien \(\Sigma \) und \(\Gamma \) zwei Alphabete.<br />
Ein <em><span class="dashuline" >formales Beweissystem</span></em> \((B, F)\) ist eine Menge \(B \subset \Sigma ^\ast \) zusammen mit einer Abbildung \(F\colon B \rightarrow \Gamma ^\ast \), sodass \(B\)
entscheidbar und \(F\) berechenbar ist.<br />
Fu&#x0308;r \(a \in \Gamma ^\ast \) schreibt man \(\vdash a\), falls \(\exists _{b \in B}\; F(b) = a\) (d.&#x202f;h. \(a\) ist <em><span class="dashuline" >herleitbar</span></em>).
</p>

<p>
<em>Bemerkung</em>: Die Menge \(B\) ist die Menge aller Beweise (u&#x0308;ber dem „Beweisalphabet“ \(\Sigma \)). Die „Interpretationsfunktion“ \(F\) weist jedem Beweis \(b \in B\) die Formel \(F(b) \in \Gamma ^\ast
\) (u&#x0308;ber dem „Formelalphabet“ \(\Gamma \)) zu, die \(b\) beweist. \(F(B)\) sind sozusagen die „beweisbaren Formeln“.<br />
Die Menge \(A\) ist die „Wahrheit“, d.&#x202f;h. die Menge aller wahren Formeln.<br />
\(\vdash a\) bedeutet, dass die Formel \(a \in \Gamma ^\ast \) beweisbar ist (also \(a \in F(B)\)).
</p>

<p>
<b>korrekt</b>:&#x2003; Ein formales Beweissystem \((B, F)\) heißt <em><span class="dashuline" >korrekt</span></em> fu&#x0308;r \(A \subset \Gamma ^\ast \), falls<br />
\(\forall _{b \in B}\; F(b) \in A\) (d.&#x202f;h. falls \(F(B) \subset A\) gilt).
</p>

<p>
<b>vollsta&#x0308;ndig</b>:&#x2003; Ein formales Beweissystem \((B, F)\) heißt <em><span class="dashuline" >vollsta&#x0308;ndig</span></em> fu&#x0308;r \(A \subset \Gamma ^\ast \), falls<br />
\(\forall _{a \in A}\; \vdash a\) (d.&#x202f;h. falls \(F(B) \supset A\) gilt).
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" ><span class="textsc" >Go&#x0308;del</span>scher Unvollsta&#x0308;ndigkeitssatz</span>):</span> Jedes formale Beweissystem ist inkorrekt oder
unvollsta&#x0308;ndig fu&#x0308;r \(\TAUT _\natural := \{F \;|\; F \text { ist Tautologie der Arithmetik über } \natural \text { mit } +,\; -,\; \cdot \}\).
</p>

<p>
<b>Beweis</b>: Sei \((B, F)\) ein formales Beweissystem, das korrekt und vollsta&#x0308;ndig fu&#x0308;r \(\TAUT _\natural \) ist. Dann gilt \(F(B) = \TAUT _\natural \). Weil jedoch \(F\) berechenbar und \(B\)
entscheidbar ist, ist dann \(\TAUT _\natural \) rekursiv aufza&#x0308;hlbar, indem man alle \(b \in B\) durchla&#x0308;uft und \(F(b)\) ausgibt. Das geht allerdings nicht, wie wie folgt gezeigt wird.
</p>

<p>
Wenn \(\TAUT _\natural \) rekursiv aufza&#x0308;hlbar wa&#x0308;re, wa&#x0308;re sie auch entscheidbar, da fu&#x0308;r jede Formel \(F\) entweder \(F\) oder \(\lnot F\) gilt (Entscheidungsverfahren: za&#x0308;hle
bei Eingabe \(F\) die Menge \(\TAUT _\natural = \{F_0, F_1, \dotsc \}\) auf, bis fu&#x0308;r ein \(i \in \natural _0\) \(F = F_i\) oder \(F = \lnot F_i\) gilt).<br />
Sei \(A\) eine rekursiv aufza&#x0308;hlbare, aber unentscheidbare Sprache (z.&#x202f;B. \(A = K, H, \dotsc \)). Da \(A\) rekursiv-aufza&#x0308;hlbar ist, ist die partielle Funktion \(\chi _A’\) mit \(\chi _A’(n) = 1\)
fu&#x0308;r \(n \in A\) und \(\chi _A’(n)\) undefiniert fu&#x0308;r \(n \notin A\) berechenbar. Turing-Berechenbarkeit stimmt mit IMP-Berechenbarkeit u&#x0308;berein, sodass nach dem vorherigen Satz eine
arithmetische Darstellung \(F(x, y)\) von \(\chi _A’\) existiert. Nun gilt \(n \in A \iff \chi _A’(n) = 1 \iff F(n, 1) \text { wahr} \iff F(n, 1) \in \TAUT _\natural \), d.&#x202f;h. die berechenbare Abbildung
\(n \mapsto F(n, 1)\) ist eine Reduktion von \(A\) auf \(\TAUT _\natural \). Wenn \(\TAUT _\natural \) entscheidbar wa&#x0308;re, wa&#x0308;re damit auch \(A\) entscheidbar, ein Widerspruch.
</p>

<p>
Damit ist \(\TAUT _\natural \) nicht entscheidbar und nach obiger Bemerkung auch nicht rekursiv aufza&#x0308;hlbar. &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Folgerung</b>: Sowohl \(\TAUT _\natural \) als auch \(\overline {\TAUT _\natural }\) sind nicht rekursiv aufza&#x0308;hlbar.
</p>

<p>
<em>Bemerkung</em>: Die Menge der Tautologien der Aussagenlogik ist entscheidbar (\(\NP \)-vollsta&#x0308;ndig).<br />
Die Menge der Tautologien der Pra&#x0308;dikatenlogik 1. Stufe ist unentscheidbar, aber rekursiv aufza&#x0308;hlbar.<br />
Die Menge der arithmetischen Tautologien (Fragment der Pra&#x0308;dikatenlogik 2. Stufe) ist weder rekursiv aufza&#x0308;hlbar, noch ist ihr Komplement rekursiv aufza&#x0308;hlbar.
</p>

{% endraw %}
</div>
{:/nomarkdown}
