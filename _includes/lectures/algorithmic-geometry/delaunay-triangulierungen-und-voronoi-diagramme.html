
{::nomarkdown}
<div class="lwarp-contents">
{% raw %}
<div class="hidden" >

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\mathllap }[2][]{{#1#2}}\)

\(\newcommand {\mathrlap }[2][]{{#1#2}}\)

\(\newcommand {\mathclap }[2][]{{#1#2}}\)

\(\newcommand {\mathmbox }[1]{#1}\)

\(\newcommand {\clap }[1]{#1}\)

\(\newcommand {\LWRmathmakebox }[2][]{#2}\)

\(\newcommand {\mathmakebox }[1][]{\LWRmathmakebox }\)

\(\newcommand {\cramped }[2][]{{#1#2}}\)

\(\newcommand {\crampedllap }[2][]{{#1#2}}\)

\(\newcommand {\crampedrlap }[2][]{{#1#2}}\)

\(\newcommand {\crampedclap }[2][]{{#1#2}}\)

\(\newenvironment {crampedsubarray}[1]{}{}\)

\(\newcommand {\crampedsubstack }{}\)

\(\newcommand {\smashoperator }[2][]{#2\limits }\)

\(\newcommand {\adjustlimits }{}\)

\(\newcommand {\SwapAboveDisplaySkip }{}\)

\(\require {extpfeil}\)

\(\Newextarrow \xleftrightarrow {10,10}{0x2194}\)

\(\Newextarrow \xLeftarrow {10,10}{0x21d0}\)

\(\Newextarrow \xhookleftarrow {10,10}{0x21a9}\)

\(\Newextarrow \xmapsto {10,10}{0x21a6}\)

\(\Newextarrow \xRightarrow {10,10}{0x21d2}\)

\(\Newextarrow \xLeftrightarrow {10,10}{0x21d4}\)

\(\Newextarrow \xhookrightarrow {10,10}{0x21aa}\)

\(\Newextarrow \xrightharpoondown {10,10}{0x21c1}\)

\(\Newextarrow \xleftharpoondown {10,10}{0x21bd}\)

\(\Newextarrow \xrightleftharpoons {10,10}{0x21cc}\)

\(\Newextarrow \xrightharpoonup {10,10}{0x21c0}\)

\(\Newextarrow \xleftharpoonup {10,10}{0x21bc}\)

\(\Newextarrow \xleftrightharpoons {10,10}{0x21cb}\)

\(\newcommand {\LWRdounderbracket }[3]{\underset {#3}{\underline {#1}}}\)

\(\newcommand {\LWRunderbracket }[2][]{\LWRdounderbracket {#2}}\)

\(\newcommand {\underbracket }[1][]{\LWRunderbracket }\)

\(\newcommand {\LWRdooverbracket }[3]{\overset {#3}{\overline {#1}}}\)

\(\newcommand {\LWRoverbracket }[2][]{\LWRdooverbracket {#2}}\)

\(\newcommand {\overbracket }[1][]{\LWRoverbracket }\)

\(\newcommand {\LaTeXunderbrace }[1]{\underbrace {#1}}\)

\(\newcommand {\LaTeXoverbrace }[1]{\overbrace {#1}}\)

\(\newenvironment {matrix*}[1][]{\begin {matrix}}{\end {matrix}}\)

\(\newenvironment {pmatrix*}[1][]{\begin {pmatrix}}{\end {pmatrix}}\)

\(\newenvironment {bmatrix*}[1][]{\begin {bmatrix}}{\end {bmatrix}}\)

\(\newenvironment {Bmatrix*}[1][]{\begin {Bmatrix}}{\end {Bmatrix}}\)

\(\newenvironment {vmatrix*}[1][]{\begin {vmatrix}}{\end {vmatrix}}\)

\(\newenvironment {Vmatrix*}[1][]{\begin {Vmatrix}}{\end {Vmatrix}}\)

\(\newenvironment {smallmatrix*}[1][]{\begin {matrix}}{\end {matrix}}\)

\(\newenvironment {psmallmatrix*}[1][]{\begin {pmatrix}}{\end {pmatrix}}\)

\(\newenvironment {bsmallmatrix*}[1][]{\begin {bmatrix}}{\end {bmatrix}}\)

\(\newenvironment {Bsmallmatrix*}[1][]{\begin {Bmatrix}}{\end {Bmatrix}}\)

\(\newenvironment {vsmallmatrix*}[1][]{\begin {vmatrix}}{\end {vmatrix}}\)

\(\newenvironment {Vsmallmatrix*}[1][]{\begin {Vmatrix}}{\end {Vmatrix}}\)

\(\newenvironment {psmallmatrix}[1][]{\begin {pmatrix}}{\end {pmatrix}}\)

\(\newenvironment {bsmallmatrix}[1][]{\begin {bmatrix}}{\end {bmatrix}}\)

\(\newenvironment {Bsmallmatrix}[1][]{\begin {Bmatrix}}{\end {Bmatrix}}\)

\(\newenvironment {vsmallmatrix}[1][]{\begin {vmatrix}}{\end {vmatrix}}\)

\(\newenvironment {Vsmallmatrix}[1][]{\begin {Vmatrix}}{\end {Vmatrix}}\)

\(\newcommand {\LWRmultlined }[1][]{\begin {multline*}}\)

\(\newenvironment {multlined}[1][]{\LWRmultlined }{\end {multline*}}\)

\(\let \LWRorigshoveleft \shoveleft \)

\(\renewcommand {\shoveleft }[1][]{\LWRorigshoveleft }\)

\(\let \LWRorigshoveright \shoveright \)

\(\renewcommand {\shoveright }[1][]{\LWRorigshoveright }\)

\(\newenvironment {dcases}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {dcases*}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {rcases}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {rcases*}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {drcases}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {drcases*}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {cases*}{\begin {cases}}{\end {cases}}\)

\(\newcommand {\MoveEqLeft }[1][]{}\)

\(\def \LWRAboxed #1&amp;#2&amp;#3!|!{\fbox {\(#1\)}&amp;\fbox {\(#2\)}} \newcommand {\Aboxed }[1]{\LWRAboxed #1&amp;&amp;!|!} \)

\( \newcommand {\LWRABLines }[1][\Updownarrow ]{#1 \notag \\}\newcommand {\ArrowBetweenLines }{\ifstar \LWRABLines \LWRABLines } \)

\(\newcommand {\shortintertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\vdotswithin }[1]{\hspace {.5em}\vdots }\)

\(\newcommand {\LWRshortvdotswithinstar }[1]{\vdots \hspace {.5em} &amp; \\}\)

\(\newcommand {\LWRshortvdotswithinnostar }[1]{&amp; \hspace {.5em}\vdots \\}\)

\(\newcommand {\shortvdotswithin }{\ifstar \LWRshortvdotswithinstar \LWRshortvdotswithinnostar }\)

\(\newcommand {\MTFlushSpaceAbove }{}\)

\(\newcommand {\MTFlushSpaceBelow }{\\}\)

\(\newcommand \lparen {(}\)

\(\newcommand \rparen {)}\)

\(\newcommand {\ordinarycolon }{:}\)

\(\newcommand {\vcentcolon }{\mathrel {\mathop \ordinarycolon }}\)

\(\newcommand \dblcolon {\vcentcolon \vcentcolon }\)

\(\newcommand \coloneqq {\vcentcolon =}\)

\(\newcommand \Coloneqq {\dblcolon =}\)

\(\newcommand \coloneq {\vcentcolon {-}}\)

\(\newcommand \Coloneq {\dblcolon {-}}\)

\(\newcommand \eqqcolon {=\vcentcolon }\)

\(\newcommand \Eqqcolon {=\dblcolon }\)

\(\newcommand \eqcolon {\mathrel {-}\vcentcolon }\)

\(\newcommand \Eqcolon {\mathrel {-}\dblcolon }\)

\(\newcommand \colonapprox {\vcentcolon \approx }\)

\(\newcommand \Colonapprox {\dblcolon \approx }\)

\(\newcommand \colonsim {\vcentcolon \sim }\)

\(\newcommand \Colonsim {\dblcolon \sim }\)

\(\newcommand {\nuparrow }{\mathrel {\cancel {\uparrow }}}\)

\(\newcommand {\ndownarrow }{\mathrel {\cancel {\downarrow }}}\)

\(\newcommand {\bigtimes }{\mathop {\Large \times }\limits }\)

\(\newcommand {\prescript }[3]{{}^{#1}_{#2}#3}\)

\(\newenvironment {lgathered}{\begin {gathered}}{\end {gathered}}\)

\(\newenvironment {rgathered}{\begin {gathered}}{\end {gathered}}\)

\(\newcommand {\splitfrac }[2]{{}^{#1}_{#2}}\)

\(\let \splitdfrac \splitfrac \)

\(\newcommand {\LWRoverlaysymbols }[2]{\mathord {\smash {\mathop {#2\strut }\limits ^{\smash {\lower 3ex{#1}}}}\strut }}\)

\(\newcommand{\alphaup}{\unicode{x03B1}}\)

\(\newcommand{\betaup}{\unicode{x03B2}}\)

\(\newcommand{\gammaup}{\unicode{x03B3}}\)

\(\newcommand{\digammaup}{\unicode{x03DD}}\)

\(\newcommand{\deltaup}{\unicode{x03B4}}\)

\(\newcommand{\epsilonup}{\unicode{x03F5}}\)

\(\newcommand{\varepsilonup}{\unicode{x03B5}}\)

\(\newcommand{\zetaup}{\unicode{x03B6}}\)

\(\newcommand{\etaup}{\unicode{x03B7}}\)

\(\newcommand{\thetaup}{\unicode{x03B8}}\)

\(\newcommand{\varthetaup}{\unicode{x03D1}}\)

\(\newcommand{\iotaup}{\unicode{x03B9}}\)

\(\newcommand{\kappaup}{\unicode{x03BA}}\)

\(\newcommand{\varkappaup}{\unicode{x03F0}}\)

\(\newcommand{\lambdaup}{\unicode{x03BB}}\)

\(\newcommand{\muup}{\unicode{x03BC}}\)

\(\newcommand{\nuup}{\unicode{x03BD}}\)

\(\newcommand{\xiup}{\unicode{x03BE}}\)

\(\newcommand{\omicronup}{\unicode{x03BF}}\)

\(\newcommand{\piup}{\unicode{x03C0}}\)

\(\newcommand{\varpiup}{\unicode{x03D6}}\)

\(\newcommand{\rhoup}{\unicode{x03C1}}\)

\(\newcommand{\varrhoup}{\unicode{x03F1}}\)

\(\newcommand{\sigmaup}{\unicode{x03C3}}\)

\(\newcommand{\varsigmaup}{\unicode{x03C2}}\)

\(\newcommand{\tauup}{\unicode{x03C4}}\)

\(\newcommand{\upsilonup}{\unicode{x03C5}}\)

\(\newcommand{\phiup}{\unicode{x03D5}}\)

\(\newcommand{\varphiup}{\unicode{x03C6}}\)

\(\newcommand{\chiup}{\unicode{x03C7}}\)

\(\newcommand{\psiup}{\unicode{x03C8}}\)

\(\newcommand{\omegaup}{\unicode{x03C9}}\)

\(\newcommand{\Alphaup}{\unicode{x0391}}\)

\(\newcommand{\Betaup}{\unicode{x0392}}\)

\(\newcommand{\Gammaup}{\unicode{x0393}}\)

\(\newcommand{\Digammaup}{\unicode{x03DC}}\)

\(\newcommand{\Deltaup}{\unicode{x0394}}\)

\(\newcommand{\Epsilonup}{\unicode{x0395}}\)

\(\newcommand{\Zetaup}{\unicode{x0396}}\)

\(\newcommand{\Etaup}{\unicode{x0397}}\)

\(\newcommand{\Thetaup}{\unicode{x0398}}\)

\(\newcommand{\Varthetaup}{\unicode{x03F4}}\)

\(\newcommand{\Iotaup}{\unicode{x0399}}\)

\(\newcommand{\Kappaup}{\unicode{x039A}}\)

\(\newcommand{\Lambdaup}{\unicode{x039B}}\)

\(\newcommand{\Muup}{\unicode{x039C}}\)

\(\newcommand{\Nuup}{\unicode{x039D}}\)

\(\newcommand{\Xiup}{\unicode{x039E}}\)

\(\newcommand{\Omicronup}{\unicode{x039F}}\)

\(\newcommand{\Piup}{\unicode{x03A0}}\)

\(\newcommand{\Varpiup}{\unicode{x03D6}}\)

\(\newcommand{\Rhoup}{\unicode{x03A1}}\)

\(\newcommand{\Sigmaup}{\unicode{x03A3}}\)

\(\newcommand{\Tauup}{\unicode{x03A4}}\)

\(\newcommand{\Upsilonup}{\unicode{x03A5}}\)

\(\newcommand{\Phiup}{\unicode{x03A6}}\)

\(\newcommand{\Chiup}{\unicode{x03A7}}\)

\(\newcommand{\Psiup}{\unicode{x03A8}}\)

\(\newcommand{\Omegaup}{\unicode{x03A9}}\)

\(\newcommand{\alphait}{\unicode{x1D6FC}}\)

\(\newcommand{\betait}{\unicode{x1D6FD}}\)

\(\newcommand{\gammait}{\unicode{x1D6FE}}\)

\(\newcommand{\digammait}{\mathit{\unicode{x03DD}}}\)

\(\newcommand{\deltait}{\unicode{x1D6FF}}\)

\(\newcommand{\epsilonit}{\unicode{x1D716}}\)

\(\newcommand{\varepsilonit}{\unicode{x1D700}}\)

\(\newcommand{\zetait}{\unicode{x1D701}}\)

\(\newcommand{\etait}{\unicode{x1D702}}\)

\(\newcommand{\thetait}{\unicode{x1D703}}\)

\(\newcommand{\varthetait}{\unicode{x1D717}}\)

\(\newcommand{\iotait}{\unicode{x1D704}}\)

\(\newcommand{\kappait}{\unicode{x1D705}}\)

\(\newcommand{\varkappait}{\unicode{x1D718}}\)

\(\newcommand{\lambdait}{\unicode{x1D706}}\)

\(\newcommand{\muit}{\unicode{x1D707}}\)

\(\newcommand{\nuit}{\unicode{x1D708}}\)

\(\newcommand{\xiit}{\unicode{x1D709}}\)

\(\newcommand{\omicronit}{\unicode{x1D70A}}\)

\(\newcommand{\piit}{\unicode{x1D70B}}\)

\(\newcommand{\varpiit}{\unicode{x1D71B}}\)

\(\newcommand{\rhoit}{\unicode{x1D70C}}\)

\(\newcommand{\varrhoit}{\unicode{x1D71A}}\)

\(\newcommand{\sigmait}{\unicode{x1D70E}}\)

\(\newcommand{\varsigmait}{\unicode{x1D70D}}\)

\(\newcommand{\tauit}{\unicode{x1D70F}}\)

\(\newcommand{\upsilonit}{\unicode{x1D710}}\)

\(\newcommand{\phiit}{\unicode{x1D719}}\)

\(\newcommand{\varphiit}{\unicode{x1D711}}\)

\(\newcommand{\chiit}{\unicode{x1D712}}\)

\(\newcommand{\psiit}{\unicode{x1D713}}\)

\(\newcommand{\omegait}{\unicode{x1D714}}\)

\(\newcommand{\Alphait}{\unicode{x1D6E2}}\)

\(\newcommand{\Betait}{\unicode{x1D6E3}}\)

\(\newcommand{\Gammait}{\unicode{x1D6E4}}\)

\(\newcommand{\Digammait}{\mathit{\unicode{x03DC}}}\)

\(\newcommand{\Deltait}{\unicode{x1D6E5}}\)

\(\newcommand{\Epsilonit}{\unicode{x1D6E6}}\)

\(\newcommand{\Zetait}{\unicode{x1D6E7}}\)

\(\newcommand{\Etait}{\unicode{x1D6E8}}\)

\(\newcommand{\Thetait}{\unicode{x1D6E9}}\)

\(\newcommand{\Varthetait}{\unicode{x1D6F3}}\)

\(\newcommand{\Iotait}{\unicode{x1D6EA}}\)

\(\newcommand{\Kappait}{\unicode{x1D6EB}}\)

\(\newcommand{\Lambdait}{\unicode{x1D6EC}}\)

\(\newcommand{\Muit}{\unicode{x1D6ED}}\)

\(\newcommand{\Nuit}{\unicode{x1D6EE}}\)

\(\newcommand{\Xiit}{\unicode{x1D6EF}}\)

\(\newcommand{\Omicronit}{\unicode{x1D6F0}}\)

\(\newcommand{\Piit}{\unicode{x1D6F1}}\)

\(\newcommand{\Rhoit}{\unicode{x1D6F2}}\)

\(\newcommand{\Sigmait}{\unicode{x1D6F4}}\)

\(\newcommand{\Tauit}{\unicode{x1D6F5}}\)

\(\newcommand{\Upsilonit}{\unicode{x1D6F6}}\)

\(\newcommand{\Phiit}{\unicode{x1D6F7}}\)

\(\newcommand{\Chiit}{\unicode{x1D6F8}}\)

\(\newcommand{\Psiit}{\unicode{x1D6F9}}\)

\(\newcommand{\Omegait}{\unicode{x1D6FA}}\)

\(\let \digammaup \Digammaup \)

\(\renewcommand {\digammait }{\mathit {\digammaup }}\)

\(\newcommand {\smallin }{\unicode {x220A}}\)

\(\newcommand {\smallowns }{\unicode {x220D}}\)

\(\newcommand {\notsmallin }{\LWRoverlaysymbols {/}{\unicode {x220A}}}\)

\(\newcommand {\notsmallowns }{\LWRoverlaysymbols {/}{\unicode {x220D}}}\)

\(\newcommand {\rightangle }{\unicode {x221F}}\)

\(\newcommand {\intclockwise }{\unicode {x2231}}\)

\(\newcommand {\ointclockwise }{\unicode {x2232}}\)

\(\newcommand {\ointctrclockwise }{\unicode {x2233}}\)

\(\newcommand {\oiint }{\unicode {x222F}}\)

\(\newcommand {\oiiint }{\unicode {x2230}}\)

\(\newcommand {\ddag }{\unicode {x2021}}\)

\(\newcommand {\P }{\unicode {x00B6}}\)

\(\newcommand {\copyright }{\unicode {x00A9}}\)

\(\newcommand {\dag }{\unicode {x2020}}\)

\(\newcommand {\pounds }{\unicode {x00A3}}\)

\(\newcommand {\iddots }{\unicode {x22F0}}\)

\(\newcommand {\utimes }{\overline {\times }}\)

\(\newcommand {\dtimes }{\underline {\times }}\)

\(\newcommand {\udtimes }{\overline {\underline {\times }}}\)

\(\newcommand {\leftwave }{\left \{}\)

\(\newcommand {\rightwave }{\right \}}\)

\(\newcommand {\toprule }[1][]{\hline }\)

\(\let \midrule \toprule \)

\(\let \bottomrule \toprule \)

\(\newcommand {\cmidrule }[2][]{}\)

\(\newcommand {\morecmidrules }{}\)

\(\newcommand {\specialrule }[3]{\hline }\)

\(\newcommand {\addlinespace }[1][]{}\)

\(\newcommand {\LWRsubmultirow }[2][]{#2}\)

\(\newcommand {\LWRmultirow }[2][]{\LWRsubmultirow }\)

\(\newcommand {\multirow }[2][]{\LWRmultirow }\)

\(\newcommand {\mrowcell }{}\)

\(\newcommand {\mcolrowcell }{}\)

\(\newcommand {\STneed }[1]{}\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\newcommand {\tothe }[1]{^{#1}}\)

\(\newcommand {\raiseto }[2]{{#2}^{#1}}\)

\(\newcommand {\ang }[2][]{(\mathrm {#2})\degree }\)

\(\newcommand {\num }[2][]{\mathrm {#2}}\)

\(\newcommand {\si }[2][]{\mathrm {#2}}\)

\(\newcommand {\LWRSI }[2][]{\mathrm {#1\LWRSInumber \,#2}}\)

\(\newcommand {\SI }[2][]{\def \LWRSInumber {#2}\LWRSI }\)

\(\newcommand {\numlist }[2][]{\mathrm {#2}}\)

\(\newcommand {\numrange }[3][]{\mathrm {#2\,\unicode {x2013}\,#3}}\)

\(\newcommand {\SIlist }[3][]{\mathrm {#2\,#3}}\)

\(\newcommand {\SIrange }[4][]{\mathrm {#2\,#4\,\unicode {x2013}\,#3\,#4}}\)

\(\newcommand {\tablenum }[2][]{\mathrm {#2}}\)

\(\newcommand {\ampere }{\mathrm {A}}\)

\(\newcommand {\candela }{\mathrm {cd}}\)

\(\newcommand {\kelvin }{\mathrm {K}}\)

\(\newcommand {\kilogram }{\mathrm {kg}}\)

\(\newcommand {\metre }{\mathrm {m}}\)

\(\newcommand {\mole }{\mathrm {mol}}\)

\(\newcommand {\second }{\mathrm {s}}\)

\(\newcommand {\becquerel }{\mathrm {Bq}}\)

\(\newcommand {\degreeCelsius }{\unicode {x2103}}\)

\(\newcommand {\coulomb }{\mathrm {C}}\)

\(\newcommand {\farad }{\mathrm {F}}\)

\(\newcommand {\gray }{\mathrm {Gy}}\)

\(\newcommand {\hertz }{\mathrm {Hz}}\)

\(\newcommand {\henry }{\mathrm {H}}\)

\(\newcommand {\joule }{\mathrm {J}}\)

\(\newcommand {\katal }{\mathrm {kat}}\)

\(\newcommand {\lumen }{\mathrm {lm}}\)

\(\newcommand {\lux }{\mathrm {lx}}\)

\(\newcommand {\newton }{\mathrm {N}}\)

\(\newcommand {\ohm }{\mathrm {\Omega }}\)

\(\newcommand {\pascal }{\mathrm {Pa}}\)

\(\newcommand {\radian }{\mathrm {rad}}\)

\(\newcommand {\siemens }{\mathrm {S}}\)

\(\newcommand {\sievert }{\mathrm {Sv}}\)

\(\newcommand {\steradian }{\mathrm {sr}}\)

\(\newcommand {\tesla }{\mathrm {T}}\)

\(\newcommand {\volt }{\mathrm {V}}\)

\(\newcommand {\watt }{\mathrm {W}}\)

\(\newcommand {\weber }{\mathrm {Wb}}\)

\(\newcommand {\day }{\mathrm {d}}\)

\(\newcommand {\degree }{\mathrm {^\circ }}\)

\(\newcommand {\hectare }{\mathrm {ha}}\)

\(\newcommand {\hour }{\mathrm {h}}\)

\(\newcommand {\litre }{\mathrm {l}}\)

\(\newcommand {\liter }{\mathrm {L}}\)

\(\newcommand {\arcminute }{^\prime }\)
\(\newcommand {\minute }{\mathrm {min}}\)

\(\newcommand {\arcsecond }{^{\prime \prime }}\)

\(\newcommand {\tonne }{\mathrm {t}}\)

\(\newcommand {\astronomicalunit }{au}\)

\(\newcommand {\atomicmassunit }{u}\)

\(\newcommand {\bohr }{\mathit {a}_0}\)

\(\newcommand {\clight }{\mathit {c}_0}\)

\(\newcommand {\dalton }{\mathrm {D}_\mathrm {a}}\)

\(\newcommand {\electronmass }{\mathit {m}_{\mathrm {e}}}\)

\(\newcommand {\electronvolt }{\mathrm {eV}}\)

\(\newcommand {\elementarycharge }{\mathit {e}}\)

\(\newcommand {\hartree }{\mathit {E}_{\mathrm {h}}}\)

\(\newcommand {\planckbar }{\mathit {\unicode {x210F}}}\)

\(\newcommand {\angstrom }{\mathrm {\unicode {x212B}}}\)

\(\let \LWRorigbar \bar \)

\(\newcommand {\bar }{\mathrm {bar}}\)

\(\newcommand {\barn }{\mathrm {b}}\)

\(\newcommand {\bel }{\mathrm {B}}\)

\(\newcommand {\decibel }{\mathrm {dB}}\)

\(\newcommand {\knot }{\mathrm {kn}}\)

\(\newcommand {\mmHg }{\mathrm {mmHg}}\)

\(\newcommand {\nauticalmile }{\mathrm {M}}\)

\(\newcommand {\neper }{\mathrm {Np}}\)

\(\newcommand {\yocto }{\mathrm {y}}\)

\(\newcommand {\zepto }{\mathrm {z}}\)

\(\newcommand {\atto }{\mathrm {a}}\)

\(\newcommand {\femto }{\mathrm {f}}\)

\(\newcommand {\pico }{\mathrm {p}}\)

\(\newcommand {\nano }{\mathrm {n}}\)

\(\newcommand {\micro }{\mathrm {\unicode {x00B5}}}\)

\(\newcommand {\milli }{\mathrm {m}}\)

\(\newcommand {\centi }{\mathrm {c}}\)

\(\newcommand {\deci }{\mathrm {d}}\)

\(\newcommand {\deca }{\mathrm {da}}\)

\(\newcommand {\hecto }{\mathrm {h}}\)

\(\newcommand {\kilo }{\mathrm {k}}\)

\(\newcommand {\mega }{\mathrm {M}}\)

\(\newcommand {\giga }{\mathrm {G}}\)

\(\newcommand {\tera }{\mathrm {T}}\)

\(\newcommand {\peta }{\mathrm {P}}\)

\(\newcommand {\exa }{\mathrm {E}}\)

\(\newcommand {\zetta }{\mathrm {Z}}\)

\(\newcommand {\yotta }{\mathrm {Y}}\)

\(\newcommand {\percent }{\mathrm {\%}}\)

\(\newcommand {\meter }{\mathrm {m}}\)

\(\newcommand {\metre }{\mathrm {m}}\)

\(\newcommand {\gram }{\mathrm {g}}\)

\(\newcommand {\kg }{\kilo \gram }\)

\(\newcommand {\of }[1]{_{\mathrm {#1}}}\)

\(\newcommand {\squared }{^2}\)

\(\newcommand {\square }[1]{\mathrm {#1}^2}\)

\(\newcommand {\cubed }{^3}\)

\(\newcommand {\cubic }[1]{\mathrm {#1}^3}\)

\(\newcommand {\per }{/}\)

\(\newcommand {\celsius }{\unicode {x2103}}\)

\(\newcommand {\fg }{\femto \gram }\)

\(\newcommand {\pg }{\pico \gram }\)

\(\newcommand {\ng }{\nano \gram }\)

\(\newcommand {\ug }{\micro \gram }\)

\(\newcommand {\mg }{\milli \gram }\)

\(\newcommand {\g }{\gram }\)

\(\newcommand {\kg }{\kilo \gram }\)

\(\newcommand {\amu }{\mathrm {u}}\)

\(\newcommand {\nm }{\nano \metre }\)

\(\newcommand {\um }{\micro \metre }\)

\(\newcommand {\mm }{\milli \metre }\)

\(\newcommand {\cm }{\centi \metre }\)

\(\newcommand {\dm }{\deci \metre }\)

\(\newcommand {\m }{\metre }\)

\(\newcommand {\km }{\kilo \metre }\)

\(\newcommand {\as }{\atto \second }\)

\(\newcommand {\fs }{\femto \second }\)

\(\newcommand {\ps }{\pico \second }\)

\(\newcommand {\ns }{\nano \second }\)

\(\newcommand {\us }{\micro \second }\)

\(\newcommand {\ms }{\milli \second }\)

\(\newcommand {\s }{\second }\)

\(\newcommand {\fmol }{\femto \mol }\)

\(\newcommand {\pmol }{\pico \mol }\)

\(\newcommand {\nmol }{\nano \mol }\)

\(\newcommand {\umol }{\micro \mol }\)

\(\newcommand {\mmol }{\milli \mol }\)

\(\newcommand {\mol }{\mol }\)

\(\newcommand {\kmol }{\kilo \mol }\)

\(\newcommand {\pA }{\pico \ampere }\)

\(\newcommand {\nA }{\nano \ampere }\)

\(\newcommand {\uA }{\micro \ampere }\)

\(\newcommand {\mA }{\milli \ampere }\)

\(\newcommand {\A }{\ampere }\)

\(\newcommand {\kA }{\kilo \ampere }\)

\(\newcommand {\ul }{\micro \litre }\)

\(\newcommand {\ml }{\milli \litre }\)

\(\newcommand {\l }{\litre }\)

\(\newcommand {\hl }{\hecto \litre }\)

\(\newcommand {\uL }{\micro \liter }\)

\(\newcommand {\mL }{\milli \liter }\)

\(\newcommand {\L }{\liter }\)

\(\newcommand {\hL }{\hecto \liter }\)

\(\newcommand {\mHz }{\milli \hertz }\)

\(\newcommand {\Hz }{\hertz }\)

\(\newcommand {\kHz }{\kilo \hertz }\)

\(\newcommand {\MHz }{\mega \hertz }\)

\(\newcommand {\GHz }{\giga \hertz }\)

\(\newcommand {\THz }{\tera \hertz }\)

\(\newcommand {\mN }{\milli \newton }\)

\(\newcommand {\N }{\newton }\)

\(\newcommand {\kN }{\kilo \newton }\)

\(\newcommand {\MN }{\mega \newton }\)

\(\newcommand {\Pa }{\pascal }\)

\(\newcommand {\kPa }{\kilo \pascal }\)

\(\newcommand {\MPa }{\mega \pascal }\)

\(\newcommand {\GPa }{\giga \pascal }\)

\(\newcommand {\mohm }{\milli \ohm }\)

\(\newcommand {\kohm }{\kilo \ohm }\)

\(\newcommand {\Mohm }{\mega \ohm }\)

\(\newcommand {\pV }{\pico \volt }\)

\(\newcommand {\nV }{\nano \volt }\)

\(\newcommand {\uV }{\micro \volt }\)

\(\newcommand {\mV }{\milli \volt }\)

\(\newcommand {\V }{\volt }\)

\(\newcommand {\kV }{\kilo \volt }\)

\(\newcommand {\W }{\watt }\)

\(\newcommand {\uW }{\micro \watt }\)

\(\newcommand {\mW }{\milli \watt }\)

\(\newcommand {\kW }{\kilo \watt }\)

\(\newcommand {\MW }{\mega \watt }\)

\(\newcommand {\GW }{\giga \watt }\)

\(\newcommand {\J }{\joule }\)

\(\newcommand {\uJ }{\micro \joule }\)

\(\newcommand {\mJ }{\milli \joule }\)

\(\newcommand {\kJ }{\kilo \joule }\)

\(\newcommand {\eV }{\electronvolt }\)

\(\newcommand {\meV }{\milli \electronvolt }\)

\(\newcommand {\keV }{\kilo \electronvolt }\)

\(\newcommand {\MeV }{\mega \electronvolt }\)

\(\newcommand {\GeV }{\giga \electronvolt }\)

\(\newcommand {\TeV }{\tera \electronvolt }\)

\(\newcommand {\kWh }{\kilo \watt \hour }\)

\(\newcommand {\F }{\farad }\)

\(\newcommand {\fF }{\femto \farad }\)

\(\newcommand {\pF }{\pico \farad }\)

\(\newcommand {\K }{\mathrm {K}}\)

\(\newcommand {\dB }{\mathrm {dB}}\)

\(\newcommand {\kibi }{\mathrm {Ki}}\)

\(\newcommand {\mebi }{\mathrm {Mi}}\)

\(\newcommand {\gibi }{\mathrm {Gi}}\)

\(\newcommand {\tebi }{\mathrm {Ti}}\)

\(\newcommand {\pebi }{\mathrm {Pi}}\)

\(\newcommand {\exbi }{\mathrm {Ei}}\)

\(\newcommand {\zebi }{\mathrm {Zi}}\)

\(\newcommand {\yobi }{\mathrm {Yi}}\)

\(\require {mhchem}\)

\(\require {cancel}\)

\(\newcommand {\fint }{âĺŊ}\)

\(\newcommand {\hdots }{\cdots }\)

\(\newcommand {\mathnormal }[1]{#1}\)

\(\newcommand {\vecs }[2]{\vec {#1}_{#2}}\)

\(\renewcommand {\A }{\mathcal {A}}\)

\(\newcommand {\D }{\mathcal {D}}\)

\(\renewcommand {\H }{\mathcal {H}}\)

\(\renewcommand {\L }{\mathcal {L}}\)

\(\renewcommand {\O }{\mathcal {O}}\)

\(\renewcommand {\P }{\mathcal {P}}\)

\(\newcommand {\T }{\mathcal {T}}\)

\(\newcommand {\EE }{\mathbb {E}}\)

\(\newcommand {\PP }{\mathbb {P}}\)

\(\newcommand {\DT }{\operatorname {DT}}\)

\(\newcommand {\dcup }{\mathbin {\dot {\cup }}}\)

\(\newcommand {\parent }{\operatorname {parent}}\)

\(\newcommand {\cc }{\operatorname {cc}}\)

\(\newcommand {\interior }{\operatorname {int}}\)

\(\newcommand {\CH }{\operatorname {CH}}\)

\(\newcommand {\sgn }{\operatorname {sgn}}\)

\(\newcommand {\zone }{\operatorname {zone}}\)

\(\newcommand {\code }[1]{\texttt {#1}}\)

\(\newcommand {\name }[1]{\textsc {#1}}\)

\(\newcommand {\smallpmatrix }[1]{\left (\begin {smallmatrix}#1\end {smallmatrix}\right )}\)

\(\newcommand {\matlab }{{\fontfamily {bch}\scshape \selectfont {}Matlab}}\)

\(\newcommand {\innerproduct }[1]{\left \langle {#1}\right \rangle }\)

\(\newcommand {\norm }[1]{\left \Vert {#1}\right \Vert }\)

\(\renewcommand {\natural }{\mathbb {N}}\)

\(\newcommand {\integer }{\mathbb {Z}}\)

\(\newcommand {\rational }{\mathbb {Q}}\)

\(\newcommand {\real }{\mathbb {R}}\)

\(\newcommand {\complex }{\mathbb {C}}\)

\(\renewcommand {\d }{\mathop {}\!\mathrm {d}}\)

\(\newcommand {\dr }{\d {}r}\)

\(\newcommand {\ds }{\d {}s}\)

\(\newcommand {\dt }{\d {}t}\)

\(\newcommand {\du }{\d {}u}\)

\(\newcommand {\dv }{\d {}v}\)

\(\newcommand {\dw }{\d {}w}\)

\(\newcommand {\dx }{\d {}x}\)

\(\newcommand {\dy }{\d {}y}\)

\(\newcommand {\dz }{\d {}z}\)

\(\newcommand {\dsigma }{\d {}\sigma }\)

\(\newcommand {\dphi }{\d {}\phi }\)

\(\newcommand {\dvarphi }{\d {}\varphi }\)

\(\newcommand {\dtau }{\d {}\tau }\)

\(\newcommand {\dxi }{\d {}\xi }\)

\(\newcommand {\dtheta }{\d {}\theta }\)

\(\newcommand {\tp }{\mathrm {T}}\)

</div>

<style type="text/css">
.lwarp-contents li.list-item-f0::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f1::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f2::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f3::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f4::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f5::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f6::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f7::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f8::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f9::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f10::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f11::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f12::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f13::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f14::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f15::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f16::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f17::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f18::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f19::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f20::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f21::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f22::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f23::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f24::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f25::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f26::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f27::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f28::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f29::marker {
  font-style:italic;
  content:'(4)\00a0\00a0';
}
.lwarp-contents li.list-item-f30::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f31::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f32::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f33::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f34::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f35::marker {
  font-style:italic;
  content:'(4)\00a0\00a0';
}
.lwarp-contents li.list-item-f36::marker {
  font-style:italic;
  content:'(5)\00a0\00a0';
}
.lwarp-contents li.list-item-f37::marker {
  font-style:italic;
  content:'(6)\00a0\00a0';
}
.lwarp-contents li.list-item-f38::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f39::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f40::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f41::marker {
  font-style:italic;
  content:'(4)\00a0\00a0';
}
.lwarp-contents li.list-item-f42::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f43::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f44::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f45::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f46::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f47::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f48::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f49::marker {
  content:'•\00a0\00a0';
}
</style>
<p>

</p>



<h2 id="delaunay-triangulierungen"><span style="font-variant: small-caps;">Delaunay</span>-Triangulierungen</h2>

</p>


<p>
<b>Motivation</b>: Gegeben sei eine sehr du&#x0308;nne Raute, in der die Diagonalen stark unterschiedliche La&#x0308;ngen besitzen. Angenommen, an jeder der vier Ecken sei eine Ho&#x0308;he gegeben. Gesucht ist eine
Triangulierung der Raute, sodass man dem Mittelpunkt (Schnittpunkt der Diagonalen) z.&#x202f;B. durch lineare Interpolation eine Ho&#x0308;he zuweisen kann. Nimmt man an, dass sich die Ho&#x0308;he in einer kleinen
Entfernung auch nur wenig a&#x0308;ndert, dann erscheint die Triangulierung mit der kurzen Diagonalen natu&#x0308;rlicher als die mit der langen, denn bei der langen Diagonalen berechnet sich die Ho&#x0308;he des
Mittelpunkts aus zwei sehr weit voneinander entfernten Eckpunkten.
</p>

<p>
Auffa&#x0308;llig ist, dass der Innenwinkel bei „natu&#x0308;rlicheren“ Triangulierung mit der kurzen Diagonalen doppelt so groß ist wie bei der anderen Triangulierung. Um auf kanonische Weise eine „beste“ Triangulierung
fu&#x0308;r eine gegebene Punktmenge zu definieren, ist ein sinnvolles Ziel, die Triangulierung zu finden, die den Vektor lexikografisch maximiert, der aufsteigend sortiert alle Innenwinkel der Dreiecke der Triangulierung
entha&#x0308;lt.
</p>

<p>
Die Delaunay-Triangulierung ist die in diesem Sinne beste Triangulierung.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Umkreis</b>: Sei \(T\) ein nicht-entartetes Dreieck in \(\real ^2\).<br />
Dann heißt das Innere des Kreises durch die Eckpunkte von \(T\) <em><span class="dashuline" >Umkreis</span></em> \(\cc (T)\) von \(T\).
</p>

<p>
<b><span class="textsc" >Delaunay</span>-Triangulierung</b>: Sei \(P \subset \real ^2\) eine endliche Punktmenge. Eine Triangulierung \(\T \) von \(P\) heißt <em><span class="dashuline" ><span
class="textsc" >Delaunay</span>-Triangulierung</span></em> \(\DT (P)\), falls \(\forall _{T \in \T }\; \cc (T) \cap P = \emptyset \).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Fragen</b>:
</p>
<ul style="list-style-type:none">

<li class="list-item-f0"><p>Existiert eine eindeutige Delaunay-Triangulierung fu&#x0308;r jede Punktmenge \(P \subset \real ^2\)?
</p>
</li>
<li class="list-item-f1"><p>Falls ja, wie berechnet man die Delaunay-Triangulierung?
</p>
</li>
<li class="list-item-f2"><p>Warum maximiert die Delaunay-Triangulierung den kleinsten Innenwinkel?
</p>
</li>
</ul>



<h2 id="lifting-abbildung">Lifting-Abbildung</h2>
<b>Lifting-Abbildung</b>: \(’\colon \real ^2 \rightarrow \real ^3, (p_x, p_y) =: p \mapsto p’ := (p_x, p_y, p_x^2 + p_y^2)\) heißt <em><span class="dashuline" >Lifting-Abbildung</span></em>.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>
<div class="marginblock" style="width:185pt">

<p>
\(\begin {vmatrix}1 &amp; a’_x &amp; a’_y &amp; a’_z\\1 &amp; b’_x &amp; b’_y &amp; b’_z\\ 1 &amp; c’_x &amp; c’_y &amp; c’_z\\1 &amp; p’_x &amp; p’_y &amp; p’_z\end {vmatrix} = \begin
{vmatrix}1 &amp; a_x &amp; a_y &amp; a_x^2 + a_y^2\\1 &amp; b_x &amp; b_y &amp; b_x^2 + b_y^2\\ 1 &amp; c_x &amp; c_y &amp; c_x^2 + c_y^2\\1 &amp; p_x &amp; p_y &amp; p_x^2 + p_y^2\end
{vmatrix}\)
</p>
</div>

<p>
<b>Lemma (Lokalisierung im Umkreis)</b>:<br />
Seien \(a, b, c \in \real ^2\) drei nicht-kollineare Punkte, \(p \in \real ^2\). Dann gilt \(p \in \cc (\triangle abc)\) genau dann, wenn \(p’\) unterhalb der Ebene durch \(a’, b’, c’\) liegt.<br />
Auf welcher Seite \(p’\) bzgl. der Ebene durch \(a’, b’, c’\) liegt,<br />
kann mit dem Vorzeichen der Determinanten rechts bestimmt werden.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Lemma (Zusammenhang DT – CH)</b>: Es gilt \(\triangle pqr \in \DT (P) \iff \triangle p’q’r’ \in \partial (\CH (P’))\) (wobei \(\partial (\CH (P’))\) die oberste Facette nicht enthalten soll).
</p>

<p>
<b>Beweis</b>: Fu&#x0308;r \(\triangle pqr \in \DT (P)\) und \(s \in P \setminus \{p, q, r\}\) beliebig gilt \(s \notin \cc (\triangle pqr)\), d.&#x202f;h. nach obigem Lemma liegt \(s\) oberhalb der Ebene
durch \(p’, q’, r’\). Damit liegen alle Punkte in \(P \setminus \{p, q, r\}\) auf einer Seite und somit \(\triangle p’q’r’ \in \partial (\CH (P’))\). Die Umkehrung geht analog. &#x2003;&#x2003;
</p>

<p>
Damit kann man \(\DT (P)\) berechnen, indem man zuna&#x0308;chst \(\CH (P’)\) in \(\real ^3\) berechnet und anschließend alle Kanten auf die \(x_1\)-\(x_2\)-Ebene projiziert. Insbesondere existiert \(\DT (P)\), ist
eindeutig und kann in erwartet \(\O (n \log n)\) Zeit konstruiert werden (RIC-Algorithmus fu&#x0308;r CH).
</p>



<h2 id="lokale-und-globale-delaunay-bedingung">Lokale und globale <span style="font-variant: small-caps;">Delaunay</span>-Bedingung</h2>

</p>


<p>
Im Folgenden ist \(\T \) eine Triangulierung der Punktmenge \(P \subset \real ^2\).
</p>

<p>
<b><span class="textsc" >Delaunay</span>-Dreieck</b>: Ein Dreieck \(T \in \T \) heißt <em><span class="dashuline" ><span class="textsc" >Delaunay</span>-Dreieck</span></em>, falls \(\cc (T) \cap P =
\emptyset \).
</p>

<p>
<b><span class="textsc" >Delaunay</span>-Kante</b>: Eine Kante \(e = pq\) in \(\T \) heißt <em><span class="dashuline" ><span class="textsc" >Delaunay</span>-Kante</span></em>, falls es einen Kreis \(C\)
gibt mit \(p, q \in \partial C\) und \(\interior (C) \cap P = \emptyset \).
</p>

<p>
<b>lokale <span class="textsc" >Delaunay</span>-Kante</b>: Eine Kante \(e = pq\) in \(\T \) heißt <em><span class="dashuline" >lokale <span class="textsc" >Delaunay</span>-Kante</span></em>, falls
</p>
<ul style="list-style-type:none">

<li class="list-item-f3"><p>\(e\) Kante nur eines einzigen Dreiecks ist (d.&#x202f;h. \(e\) liegt auf dem Rand von \(\CH (P)\)) oder
</p>
</li>
<li class="list-item-f4"><p>\(e\) Kante zweier Dreiecke \(\triangle psq, \triangle pqr \in \T \) ist sowie \(r \notin \cc (\triangle psq)\) und \(s \notin \cc (\triangle pqr)\).
</p>
</li>
</ul>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Lemma (<span class="textsc" >Delaunay</span>-Lemma)</b>: Folgendes ist a&#x0308;quivalent.
</p>
<ul style="list-style-type:none">

<li class="list-item-f5"><p>Jedes Dreieck in \(\T \) ist ein Delaunay-Dreieck (d.&#x202f;h. \(\T = \DT (P)\)).
</p>
</li>
<li class="list-item-f6"><p>Jede Kante in \(\T \) ist eine Delaunay-Kante.
</p>
</li>
<li class="list-item-f7"><p>Jede Kante in \(\T \) ist eine lokale Delaunay-Kante.
</p>
</li>
</ul>

<p>
<b>Beweis</b>: „<em>(1)</em> \(\implies \) <em>(2)</em>“: Sei \(e = pq\) eine Kante in \(\T \). Wa&#x0308;hle ein Dreieck \(T \in \T \), sodass \(e\) eine Seite von \(T\) ist. Dann gilt fu&#x0308;r \(C := \cc (T)\),
dass \(p, q \in \partial C\) und \(\interior (C) \cap P = \emptyset \).
</p>

<p>
„<em>(2)</em> \(\implies \) <em>(3)</em>“: Sei \(e = pq\) eine Kante zweier Dreiecke \(\triangle psq, \triangle pqr \in \T \) und \(C\) ein Kreis mit \(p, q \in \partial C\) und \(\interior (C) \cap P =
\emptyset \). Man kann sich klar machen, dass \(C\) vollsta&#x0308;ndig in der Vereinigung \(\cc (\triangle psq) \cup \cc (\triangle pqr)\) liegt, weil sonst \(s \in C\) oder \(r \in C\) gilt. Außerdem gilt \(\cc
(\triangle psq) \cap \cc (\triangle pqr) \subset C\). Damit kann \(C\) so innerhalb von \(\cc (\triangle psq) \cup \cc (\triangle pqr)\) „verschoben“ werden, sodass zusa&#x0308;tzlich zu \(p, q \in
\partial C\) auch noch \(r \in \partial C\) gilt (ohne dass \(s \in C\)), d.&#x202f;h. dann gilt \(C = \cc (\triangle pqr)\) und \(s \notin C\). Analog geht das mit \(C = \cc (\triangle psq)\) und \(r \notin C\).
</p>

<p>
„<em>(3)</em> \(\implies \) <em>(1)</em>“: Angenommen, alle Kanten sind lokale Delaunay-Kanten, aber es gibt ein Dreieck \(\triangle pqr\) und ein Punkt \(s \in P\) mit \(s \in \cc (\triangle pqr)\). \(s\) sei oBdA
in dem Kreissegment, das durch die Kante \(pr\) begrenzt wird. Betrachte die Strecke zwischen \(s\) und irgendeinem Punkt auf \(pr\) und alle Dreiecke zwischen \(pr\) und \(s\) auf dieser Strecke. Man wird im Folgenden
argumentieren, dass \(s\) in den Umkreisen aller dieser Dreiecke liegt. Insbesondere liegt \(s\) dann auch im Umkreis des „vorletzten“ Dreiecks \(\triangle tuv\) (teilt mit einem Dreieck mit \(s\) als Ecke eine gemeinsame Kante
\(vu\)), d.&#x202f;h. \(vu\) ist keine lokale Delaunay-Kante, ein Widerspruch.
</p>

<p>
Dazu „verformt“ man den Umkreis von \(\triangle pqr\), sodass \(p\) und \(r\) immer noch auf dem Kreis liegen, aber statt \(q\) nun der Eckpunkt \(t\) des na&#x0308;chsten Dreiecks auf dem Kreis liegt (man verschiebt den
Mittelpunkt des Kreises auf der Mittelsenkrechten von \(pr\) solange Richtung \(s\), bis \(t\) auf dem Kreis liegt). Weil der Mittelpunkt Richtung \(s\) verschoben wird, wird der Kreis in Richtung von \(s\) nur gro&#x0308;ßer,
d.&#x202f;h. \(s\) liegt auch im Umkreis von \(\cc (\triangle prt)\). Induktiv erha&#x0308;lt man damit, dass \(s\) in den Umkreisen aller Dreiecke zwischen \(s\) und \(pr\) liegt. &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Anwendung</b>: Das Delaunay-Lemma erlaubt es, in \(\O (n)\) Zeit zu u&#x0308;berpru&#x0308;fen, ob eine gegebene Triangulierung eine Delaunay-Triangulierung ist, indem alle \(\O (n)\) Kanten auf die lokale
Delaunay-Bedingung u&#x0308;berpru&#x0308;ft werden (was jeweils in \(\O (1)\) Zeit geht, im Gegensatz dazu, die Dreiecke auf die Delaunay-Bedingung zu pru&#x0308;fen). Außerdem motiviert das Lemma den
Delaunay-Flip-Algorithmus, der vom Typ „lokale Suche“ ist (versuche in jedem Schritt, lokal besser zu werden, um irgendwann die „beste“ Lo&#x0308;sung zu erreichen).
</p>



<h2 id="delaunay-flip-algorithmus"><span style="font-variant: small-caps;">Delaunay</span>-Flip-Algorithmus</h2>

</p>


<p>
<b><span class="textsc" >Delaunay</span>-Flip-Algorithmus</b>: Der <em><span class="dashuline" ><span class="textsc" >Delaunay</span>-Flip-Algorithmus</span></em> berechnet die Delaunay-Triangulierung
\(\DT (P)\) fu&#x0308;r eine Punktmenge \(P \subset \real ^2\) mit \(n := |P|\) wie folgt.
</p>
<ul style="list-style-type:none">

<li class="list-item-f8"><p>Berechne eine beliebige Triangulierung von \(P\).
</p>
</li>
<li class="list-item-f9"><p>Wiederhole, solange es eine Kante \(e = pr\) gibt, die keine lokale Delaunay-Kante ist:
</p>
<ul style="list-style-type:none">

<li class="list-item-f10"><p>„Flippe“ \(e = pr\), d.&#x202f;h. liegt die Kante an die Dreiecke \(\triangle pqr\) und \(\triangle prs\) an, dann ersetze \(pr\) durch \(qs\).
</p>
</li>
</ul>
</li>
</ul>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Lemma (Korrektheit)</b>: Sei \(e = pr\) eine Kante in \(\T \) mit zwei anliegenden Dreiecken \(\triangle pqr\) und \(\triangle prs\). Ist \(e\) keine lokale Delaunay-Kante, dann kann sie geflippt werden
(d.&#x202f;h. das Viereck \(pqrs\) ist konvex) und die neu erstellte Kante \(qs\) ist eine lokale Delaunay-Kante.
</p>

<p>
<b>Beweis</b>: Sei oBdA \(s \in \cc (\triangle pqr)\). Das Viereck \(pqrs\) ist konvex, weil alle Punkte \(p, q, r, s\) im Umkreis \(\cc (\triangle pqr)\) enthalten sind, d.&#x202f;h. alle Innenwinkel sind kleiner als
\(\pi \) (das wu&#x0308;rde nicht gehen, wenn \(e\) eine lokale Delaunay-Kante wa&#x0308;re). Damit liegt die Diagonale \(qs\) vollsta&#x0308;ndig im Viereck und die Kante \(e = pr\) kann geflippt werden.
</p>

<p>
Die neue Kante \(qs\) ist eine lokale Delaunay-Kante, weil \(\cc (\triangle pqr)\) zu \(\cc (\triangle qrs)\) deformiert werden kann, indem \(q, r\) auf dem Rand gehalten werden, wa&#x0308;hrend der Kreis schrumpft.
Dadurch fa&#x0308;llt \(p\) automatisch aus dem Kreis heraus, d.&#x202f;h. \(p \notin \cc (\triangle qrs)\). Analog zeigt man \(r \notin \cc (\triangle pqs)\). &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Lemma (Flip vergro&#x0308;ßert min. Winkel)</b>: Durch einen Flip einer Kante, die keine lokale Delaunay-Kante ist, vergro&#x0308;ßert sich der minimale Innenwinkel der beiden Dreiecke.
</p>

<p>
<b>Lemma (Flip-Algorithmus terminiert)</b>: Der Delaunay-Flip-Algorithmus terminiert.
</p>

<p>
<b>Beweis</b>: Ordne jeder Triangulierung den aufsteigend sortierten Vektor der Innenwinkel aller Dreiecke zu. Nach dem Lemma von eben fu&#x0308;hrt ein Flip zu einem lexikografisch gro&#x0308;ßeren Vektor. Weil jede
Triangulierung von \(P\) gleich viele Dreiecke (und Kanten) besitzt, gibt es nur endlich viele Triangulierungen von \(P\), d.&#x202f;h. der Flip-Algorithmus terminiert spa&#x0308;testens, wenn der lexikografisch gro&#x0308;ßte
Vektor erreicht ist. &#x2003;&#x2003;
</p>

<p>
<b>Lemma (\(\DT (P)\) maximiert Innenwinkel)</b>: \(\DT (P)\) maximiert den aufstetigend sortierten Vektor der Innenwinkel aller Dreiecke unter allen mo&#x0308;glichen Triangulierungen von \(P\).
</p>

<p>
<b>Beweis</b>: Angenommen, es gibt eine Triangulierung \(\T \), die zwar den Innenwinkel-Vektor maximiert, aber nicht die Delaunay-Triangulierung ist. Dann gibt es eine Kante, die keine lokale Delaunay-Kante ist, d.&#x202f;h.
diese Kante kann geflippt werden. Nach obigem Lemma vergro&#x0308;ßert sich dabei der minimale Innenwinkel der beteiligten Dreiecke, d.&#x202f;h. die neue Triangulierung \(\T ’\) wa&#x0308;re lexikografisch
gro&#x0308;ßer als \(\T \), ein Widerspruch. &#x2003;&#x2003;
</p>

<p>
<b>Lemma (Spezialfall)</b>: Sei \(e = pr\) eine Kante, die an die Dreiecke \(\triangle pqr\) und \(\triangle prs\) anliegt.<br />
Sind \(p, q, r, s\) <em><span class="dashuline" >kozirkula&#x0308;r</span></em> (d.&#x202f;h. \(s \in \partial (\cc (\triangle pqr))\)), dann a&#x0308;ndert ein Flip den minimalen Innenwinkel nicht.
</p>

<p>
<b>Beweis</b>: Das Lemma folgt aus dem Peripheriewinkel-Satz: Ist ein Kreis mit einer Sehne \(ab\) gegeben und wa&#x0308;hlt man einen dritten Punkt \(c\) auf dem Kreis, dann ist der Winkel \(\sphericalangle acb\)
unabha&#x0308;ngig von der Wahl von \(c\). Daraus folgt, dass es vier Winkel \(\alpha , \beta , \gamma , \delta \) gibt, sodass \(\alpha , \beta , \gamma , \delta , \alpha + \delta , \beta + \gamma \) die
Innenwinkel vor dem Flip sind und \(\alpha , \beta , \gamma , \delta , \alpha + \beta , \gamma + \delta \) die Innenwinkel nach dem Flip. Wegen \(\alpha + \delta &gt; \alpha \) usw. muss der kleinste
Innenwinkel vor und nach dem Flip in \(\{\alpha , \beta , \gamma , \delta \}\) enthalten sein, d.&#x202f;h. er a&#x0308;ndert sich nicht. &#x2003;&#x2003;
</p>



<h2 id="effiziente-implementierung-des-flip-algorithmus">Effiziente Implementierung des Flip-Algorithmus</h2>

</p>


<p>
<b>effiziente Implementierung des Flip-Algorithmus</b>:
</p>
<ul style="list-style-type:none">

<li class="list-item-f11"><p>Berechne eine beliebige Triangulierung z.&#x202f;B. mittels eines Sweepline-Algorithmus in Zeit \(\O (n \log n)\) (oder konstruiere zuna&#x0308;chst aus der Punktmenge wie im Graham-Scan-Algorithmus
fu&#x0308;r konvexe Hu&#x0308;llen ein Polygon und trianguliere dieses dann, beides geht in Zeit \(\O (n \log n)\)).
</p>
</li>
<li class="list-item-f12"><p>Erstelle einen Stack und fu&#x0308;ge alle Kanten der Triangulierung hinzu.
</p>
</li>
<li class="list-item-f13"><p>Solange es eine Kante \(e\) im Stack gibt, wiederhole:
</p>
<ul style="list-style-type:none">

<li class="list-item-f14"><p>Ist \(e\) eine lokale Delaunay-Kante, dann entferne \(e\) vom Stack.
</p>
</li>
<li class="list-item-f15"><p>Ist \(e\) keine lokale Delaunay-Kante, dann entferne \(e\) vom Stack, ersetze \(e\) durch die geflippte Kante \(e’\) in der Triangulierung und fu&#x0308;ge die a&#x0308;ußeren Kanten \(e_1, \dotsc , e_4\) des Vierecks
zum Stack hinzu, das durch die beiden zu \(e\) adjazenten Dreiecke gebildet wird.
</p>
</li>
</ul>
</li>
</ul>

<p>
<b>Zeitbedarf</b>: \(\O (\text {\#Flips} + n\log n)\)
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Lemma</b>: Die Anzahl der Flips ist \(\O (n^2)\).
</p>

<p>
<b>Beweis</b>: Betrachte die Abbildung \(h\colon \CH (P) \rightarrow \real _0^+\), die jedem Punkt \(p\) in der konvexen Hu&#x0308;lle der Punktmenge \(P\) die „Ho&#x0308;he“ \(h(p)\) von \(\CH (P’)\)
u&#x0308;ber \(p\) zuweist<br />
(d.&#x202f;h. \(h(p) := \min \{z \ge 0 \;|\; (p_x, p_y, z) \in \CH (P’)\}\)).<br />
Dann ist \(h(p)\) punktweise fu&#x0308;r alle \(p \in \CH (P)\) wa&#x0308;hrend des Flip-Algorithmus monoton fallend, denn bei Flips werden „Da&#x0308;cher“ (Vierecke in \(\real ^3\) mit hoher Diagonale) zu
„Ta&#x0308;lern“ (Vierecke in \(\real ^3\) mit niedriger Diagonale) aufgrund des Lifting-Lemmas bzgl. Umkreisen.
</p>

<p>
Eine bereits geflippte Kante kann also niemals wieder auf dem Stack auftauchen und wieder die lokale Delaunay-Eigenschaft verletzen, d.&#x202f;h. es wurden insgesamt ho&#x0308;chstens \(\binom {n}{2}\) Kanten dem Stack
hinzugefu&#x0308;gt, die geflippt werden mu&#x0308;ssen. &#x2003;&#x2003;
</p>

<p>
<b>Lemma</b>: Im Worst-Case ist die Anzahl der Flips \(\Omega (n^2)\).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
Die Laufzeit des Flip-Algorithmus ist damit \(\O (n^2)\) (scharfe Schranke, d.&#x202f;h. im Worst-Case ist die Laufzeit \(\Theta (n^2)\)). Daraus folgt insbesondere, dass sich zwei Triangulierungen in \(\O (n^2)\) Zeit
ineinander u&#x0308;berfu&#x0308;hren lassen (u&#x0308;ber die Delaunay-Triangulierung).
</p>



<h2 id="ric-algorithmus">RIC-Algorithmus</h2>

</p>


<p>
Man nimmt an, dass die Punkte in einem großen Dreieck liegen. Im \(i\)-ten Schritt ist \(\DT _i\) die Delaunay-Triangulierung der Punkte \(p_1, \dotsc , p_i\). Der Algorithmus terminiert, da der Flip-Algorithmus terminiert.
</p>

<p>
<b>RIC-Algorithmus fu&#x0308;r DT</b>: Der <em><span class="dashuline" >RIC-Algorithmus</span></em> berechnet die Delaunay-Triangulierung \(\DT (P)\) fu&#x0308;r eine Punktmenge \(P \subset \real ^2\) mit
\(n := |P|\) wie folgt.
</p>
<ul style="list-style-type:none">

<li class="list-item-f16"><p>Permutiere die Punktmenge \(P\) zufa&#x0308;llig zu \(p_1, \dotsc , p_n\).
</p>
</li>
<li class="list-item-f17"><p>Konstruiere die Triangulierung \(\DT _1\) durch Verbindung von \(p_1\) mit den Ecken des großen Dreiecks.
</p>
</li>
<li class="list-item-f18"><p>Wiederhole fu&#x0308;r \(i = 1, \dotsc , n - 1\):
</p>
<ul style="list-style-type:none">

<li class="list-item-f19"><p>Lokalisiere \(p_{i+1}\) in \(\DT _i\), d.&#x202f;h. finde \(T \in \DT _i\) mit \(p_{i+1} \in T\).
</p>
</li>
<li class="list-item-f20"><p>Verbinde \(p_{i+1}\) mit den Ecken von \(T\).
</p>
</li>
<li class="list-item-f21"><p>Wende den Delaunay-Flip-Algorithmus auf die entstehende Triangulierung an, um \(\DT _{i+1}\) zu erhalten.
</p>
</li>
</ul>
</li>
</ul>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Lemma (lokale Delaunay-Eigenschaft direkt nach Einfu&#x0308;gung)</b>: Die drei neuen Kanten zwischen \(p_{i+1}\) und den Ecken von \(\DT _i\) sind direkt nach der Einfu&#x0308;gung lokale Delaunay-Kanten.
Die einzigen Kanten, die zuna&#x0308;chst evtl. die lokale Delaunay-Eigenschaft verloren haben, sind die Kanten von \(T\).
</p>

<p>
<b>Beweis</b>: Die zu den neuen Kanten geho&#x0308;rigen Vierecke sind nicht konvex und daher lokale Delaunay-Kanten (sonst ko&#x0308;nnte man sie evtl. flippen, was nur geht, wenn die Vierecke konvex sind). Die einzigen
Vierecke direkt nach Einfu&#x0308;gung von \(p_{i+1}\), die nicht schon in \(\DT _i\) waren, sind die, die zu den Kanten von \(T\) geho&#x0308;ren, d.&#x202f;h. nur diese Kanten ko&#x0308;nnen die lokale
Delaunay-Eigenschaft verloren haben. &#x2003;&#x2003;
</p>

<p>
<b>Lemma (zersto&#x0308;rte und neue Dreiecke)</b>: Die Dreiecke in \(\DT _i \setminus \DT _{i+1}\) (die Dreiecke, die im \(i\)-ten Schritt zersto&#x0308;rt wurden) sind genau die, die \(p_{i+1}\) im Umkreis
enthalten.<br />
Die Dreiecke in \(\DT _{i+1} \setminus \DT _i\) (die Dreiecke, die im \(i\)-ten Schritt erstellt wurden) sind genau die, die \(p_{i+1}\) als eine Ecke besitzen.
</p>

<p>
<b>Beweis</b>: Wird \(p_{i+1}’\) in die konvexe Hu&#x0308;lle von \(\{p_1’, \dotsc , p_i’\}\) eingefu&#x0308;gt, dann a&#x0308;ndert sich diese nur adjazent zu \(p_{i+1}’\) (jede neue Facette hat \(p_{i+1}’\) als
Eckpunkt), d.&#x202f;h. mit jedem Flip entsteht eine Kante adjazent zu \(p_{i+1}\). Damit besitzen neue Dreiecke \(p_{i+1}\) als eine Ecke. Umgekehrt sind Dreiecke mit Ecke \(p_{i+1}\) neue Dreiecke, weil \(p_{i+1}\) vorher
nicht in der Punktmenge war.
</p>

<p>
Analog argumentiert man, dass genau die Facetten von \(\CH (\{p_1’, \dotsc , p_i’\})\) zersto&#x0308;rt werden, bei denen \(p_{i+1}’\) unterhalb der Ebene durch die jeweilige Facette liegt. Damit werden im \(i\)-ten
Schritt genau die Dreiecke zersto&#x0308;rt, in deren Umkreis \(p_{i+1}\) liegt. &#x2003;&#x2003;
</p>

<p>
<b>Lemma</b>: Die erwarteten Flipkosten fu&#x0308;r das Einfu&#x0308;gen von \(p_{i+1}\) sind \(\O (1)\).
</p>

<p>
<b>Beweis</b>: Die Anzahl der Flips ist \(\O (\text {$\deg (p_{i+1})$ nach fertiger Einfügung})\) nach dem Lemma von eben. Der erwartete Grad eines zufa&#x0308;lligen Knotens in einem planeren Graph mit \(i +
1\) Knoten ist kleiner als \(6\) (la&#x0308;sst sich aus Euler folgern). Damit sind die Flipkosten erwartet \(\O (1)\). &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
Um die Konstruktion der Delaunay-Triangulierung mittels des RIC-Algorithmus zu verschnellern, wird wa&#x0308;hrend des Algorithmus eine Suchstruktur aufgebaut, mit der effizient \(p_{i+1}\) in \(\DT _i\) lokalisiert werden
kann.
</p>

<p>
<b>Suchstruktur fu&#x0308;r RIC-Algorithmus</b>: Der RIC-Algorithmus verwaltet einen <em><span class="dashuline" >gerichteten, azyklischen Graphen (DAG)</span></em> und erweitert diesen in jedem Schritt. Knoten des
Graphen entsprechen dabei Dreiecken wie folgt:
</p>
<ul style="list-style-type:none">

<li class="list-item-f22"><p>Senken (Sinks, Knoten mit Ausgangsgrad \(0\)) entsprechen aktuell existierenden Dreiecken.
</p>
</li>
<li class="list-item-f23"><p>Innere Knoten entsprechen Dreiecken, die schon zersto&#x0308;rt wurden.
</p>
</li>
</ul>

<p>
Wa&#x0308;hrend des RIC-Algorithmus wird der DAG wie folgt gea&#x0308;ndert:
</p>
<ul style="list-style-type:none">

<li class="list-item-f24"><p><em><span class="dashuline" >Split</span></em> (Verbindung von \(p_{i+1}\) mit den Ecken von \(T \in \DT _i\) mit \(p_{i+1} \in T\)):<br />
Erstelle drei neue Kindknoten unter dem Knoten, der zu \(T_i\) geho&#x0308;rt.
</p>
</li>
<li class="list-item-f25"><p><em><span class="dashuline" >Flip</span></em> (Flip einer Kante wa&#x0308;hrend des Flip-Algorithmus):<br />
Bezeichnen \(1, 2\) die alten Dreiecke und \(3, 4\) die neuen, dann erstelle zwei Kindknoten und verbinde beide mit den beiden Knoten, die zu \(1, 2\) geho&#x0308;ren.
</p>
</li>
</ul>

<p>
Zur Punktlokalisierung geht man wie bei der Kirkpatrick-Hierarchie „von oben nach unten“ vor, d.&#x202f;h. fu&#x0308;r den aktuellen Knoten entscheidet man, in welchem Kindknoten sich \(p_{i+1}\) befindet.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
Die beno&#x0308;tigte Zeit im \(i\)-ten Schritt ist die Summe des Aufwands der Lokalisierung von \(p_{i+1}\) in \(\DT _i\) und des Flip-Algorithmus. Letztere beno&#x0308;tigt erwartet nur \(\O (1)\) Zeit. Weil jeder
DAG-Knoten \(\le 3\) und damit \(\O (1)\) viele Kinder besitzt, ist der Aufwand einer Punktlokalisierung linear in der La&#x0308;nge des Suchpfads, d.&#x202f;h. linear in der Anzahl an Dreiecken, die irgendwann (auch
wa&#x0308;hrend des Flip-Algorithmus) mal existierten und \(p_{i+1}\) enthalten.
</p>

<p>
<b>Lemma</b>: Die Kosten der Lokalisierung von \(p_{i+1}\) in \(\DT _i\) ist ho&#x0308;chstens linear in der Anzahl an (verschiedenen) Delaunay-Dreiecken, die irgendwann mal existierten und \(p_{i+1}\) im Umkreis
enthalten.
</p>

<p>
<b>Satz (Gesamt-Laufzeit der Punktlokalisierungen)</b>:<br />
Die erwartete Gesamt-Laufzeit der Punktlokalisierungen ist \(\O (n \log n)\).
</p>

<p>
<b>Beweis</b>: Fu&#x0308;r jedes Delaunay-Dreieck \(T\) in einer der \(\DT _i\) sei \(k(T) := |\cc (T) \cap P|\) die Anzahl der Punkte in seinem Umkreis. Nach dem Lemma ist der gesamte Punktlokalisierungs-Aufwand
beschra&#x0308;nkt durch \(\O (\sum _{T \in \bigcup _{i=1}^n \DT _i} k(T))\).
</p>

<p>
Zuna&#x0308;chst analysiert man \(\EE [\sum _{T \in \DT _i \setminus \DT _{i-1}} k(T)]\), d.&#x202f;h. man betrachtet nur die Delaunay-Dreiecke, die im \((i-1)\)-ten Schritt entstanden sind. Die Dreiecke in \(\DT
_i \setminus \DT _{i-1}\) sind genau die Dreiecke in \(\DT _i\), die \(p_i\) als eine Ecke besitzen (siehe Lemma oben). Weil \(p_i\) eine zufa&#x0308;llige Ecke von \(\DT _i\) ist und jedes Dreieck in \(\DT _i\) drei Ecken
besitzt, gilt<br />
\(\EE [\sum _{T \in \DT _i \setminus \DT _{i-1}} k(T)] = \EE [\sum _{T \in \DT _i,\; \text {$p_i$ Ecke von $T$}} k(T)] = \frac {3}{i} \EE [\sum _{T \in \DT _i} k(T)]\).
</p>

<p>
Auf der anderen Seite sind die Dreiecke in \(\DT _i \setminus \DT _{i+1}\) genau die Dreiecke in \(\DT _i\), die \(p_{i+1}\) in ihrem Umkreis haben. Weil \(p_{i+1}\) ein zufa&#x0308;lliger Punkt von \(P \setminus
\{p_1, \dotsc , p_i\}\) ist, gilt<br />
\(\EE [|\DT _i \setminus \DT _{i+1}|] = \frac {1}{n-i} \EE [\sum _{T \in \DT _i} k(T)]\). Allerdings ist die Zahl der im \(i\)-ten Schritt zersto&#x0308;rten Dreiecke genau zwei weniger als die Anzahl der erstellten
Dreiecke, Letzteres ist erwartet \(\O (1)\) (siehe oben). Damit gilt \(\EE [\sum _{T \in \DT _i} k(T)] = (n-i) \cdot \EE [|\DT _i \setminus \DT _{i+1}|] = \O (n - i)\).
</p>

<p>
Man erha&#x0308;lt also \(\EE [\sum _{T \in \DT _i \setminus \DT _{i-1}} k(T)] = \O (\frac {n - i}{i})\) und somit als Gesamt-Laufzeit der Punktlokalisierungen \(\sum _{i=2}^n \EE [\sum _{T \in \DT _i
\setminus \DT _{i-1}} k(T)] = \sum _{i=2}^n \O (\frac {n-i}{i}) = \O (n \log n)\). &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Zeitbedarf des RIC-Algorithmus</b>: erwartet \(\O (n \log n)\)
</p>



<h2 id="divide-and-conquer-algorithmus">Divide-and-Conquer-Algorithmus</h2>

</p>


<p>
<b>Divide-and-Conquer-Algorithmus</b>: Der <em><span class="dashuline" >Divide-and-Conquer-Algorithmus</span></em> berechnet die<br />
Delaunay-Triangulierung \(\DT (P)\) fu&#x0308;r eine Punktmenge \(P \subset \real ^2\) mit \(n := |P|\) wie folgt.
</p>
<ul style="list-style-type:none">

<li class="list-item-f26"><p>Entha&#x0308;lt \(P\) nur konstant viele Punkte, dann berechne die Delaunay-Triangulierung direkt und gebe diese zuru&#x0308;ck.
</p>
</li>
<li class="list-item-f27"><p><em>Divide-Schritt</em>: Sonst berechne den \(x\)-Median der Punkte und teile anhand diesem \(P\) in zwei Ha&#x0308;lften \(P_L\) und \(P_R\), d.&#x202f;h. \(|P_L| \approx |P_R|\) (z.&#x202f;B. anhand
des \(x\)-Medians in zwei Ha&#x0308;lften).
</p>
</li>
<li class="list-item-f28"><p>Berechne rekursiv \(\DT (P_L)\) und \(\DT (P_R)\).
</p>
</li>
<li class="list-item-f29"><p><em>Conquer-Schritt</em>: Vereine \(\DT (P_L)\) und \(\DT (P_R)\) durch Lo&#x0308;schen und Hinzufu&#x0308;gen einiger Kanten zu \(\DT (P)\).
</p>
</li>
</ul>

<p>
Das Problem dabei ist, dass man Schritt <em>(4)</em> irgendwie so durchfu&#x0308;hren muss, dass dabei nur Kosten von \(\O (n)\) entstehen, wenn der Algorithmus die Gesamtlaufzeit \(\O (n \log n)\) besitzen soll.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Beobachtungen</b>:
</p>
<ul style="list-style-type:none">

<li class="list-item-f30"><p>\(\DT (P)\) entha&#x0308;lt die obere und die untere Tangente an \(\CH (P_L)\) und \(\CH (P_R)\).
</p>
</li>
<li class="list-item-f31"><p>Alle neuen Delaunay-Kanten und -Dreiecke haben mindestens einen Punkt in \(P_L\) und einen in \(P_R\).
</p>
</li>
</ul>

<p>
<b>eine Mo&#x0308;glichkeit fu&#x0308;r den Conquer-Schritt</b>: Trianguliere den Bereich zwischen \(\DT (P_L)\) und \(\DT (P_R)\) beliebig und fu&#x0308;hre anschließend den Flip-Algorithmus durch. Allerdings ist
nicht klar, ob und warum der Flip-Algorithmus nur \(\O (n)\) Kanten flippen muss.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>besser</b>: Nutze die Tatsache, dass alle neuen Kanten und Dreiecke die Teilungsgerade schneiden. Finde die neuen Kanten und Dreiecke in der Reihenfolge, in der sie die Teilungsgerade schneiden, wie folgt:
</p>
<ul style="list-style-type:none">

<li class="list-item-f32"><p>Nimm an, dass keine zwei Punkte dieselbe \(x\)-Koordinate haben (sonst Rotation).
</p>
</li>
<li class="list-item-f33"><p>Berechne die unterste neue Kante als die untere Kante der beiden Kanten auf dem Rand von \(\CH (P)\), die die Teilungsgerade schneiden. Definiere einen Kreis durch die beiden Endpunkte \(a \in P_L\) und \(b
\in P_R\) der Kante, der seinen Mittelpunkt sehr weit unten hat.
</p>
</li>
<li class="list-item-f34"><p>Verschiebe den Mittelpunkt des letzten berechneten Kreises so lange nach oben auf der Mittelsenkrechten von \(ab\), bis ein neuer Punkt \(c\) aus \(P\) auf dem Rand des Kreises liegt, wobei \(a, b\) immer auf dem
Rand des Kreises liegen sollen.
</p>
</li>
<li class="list-item-f35"><p>\(\triangle abc\) bildet ein Delaunay-Dreieck, verbinde also \(c\) mit \(a\) und mit \(b\) und lo&#x0308;sche Kanten, die \(ac\) oder \(ab\) schneiden.
</p>
</li>
<li class="list-item-f36"><p>Fu&#x0308;r \(c \in P_L\) setze \(a \leftarrow c\) und fu&#x0308;r \(c \in P_R\) setze \(b \leftarrow c\).
</p>
</li>
<li class="list-item-f37"><p>Wiederhole Schritte <em>(3)</em> bis <em>(5)</em> solange, bis \(ab\) die obere Tangente ist (obere Kante der beiden Kanten auf dem Rand von \(\CH (P)\), die die Teilungsgerade schneiden).
</p>
</li>
</ul>

<p>
Das Problem ist, dass dieser Algorithmus so nicht implementiert werden kann, weil im Programm Kreise nicht kontinuierlich verschoben werden ko&#x0308;nnen.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Lemma</b>: Sei \(c_L\) der erste Punkt in \(P_L\), der vom Kreis durch \(a \in P_L\) und \(b \in P_R\) getroffen wird. Seien \(b, n_1, n_2, \dotsc \) die Nachbarn von \(a\) im Gegenuhrzeigersinn, startend mit
\(b\).<br />
Ist \(i\) der kleinste Index mit \(b \notin \cc (\triangle a n_i n_{i+1})\), dann ist \(an_j\) fu&#x0308;r \(j = 1, \dotsc , i - 1\) keine Delaunay-Kante und es gilt \(c_L = n_i\).
</p>

<p>
<b>Beweis</b>: Fu&#x0308;r alle \(j &lt; i\) gilt \(b \in \cc (\triangle a n_j n_{j+1})\) nach Voraussetzung. \(n_{j+1}\) und \(b\) liegen wegen der Nummerierung im Gegenuhrzeigersinn auf verschiedenen Seiten von
\(an_j\). Aus diesen beiden Aussagen folgt, dass jeder Kreis durch \(a\) und \(n_j\) einen der beiden Punkte \(b\) und \(n_{j+1}\) entha&#x0308;lt (geht der Kreis durch einen dritten Punkt \(q\), so liegt \(b\) im Kreis, wenn
\(q\) auf der Seite von \(b\), aber außerhalb von \(\cc (\triangle a n_j n_{j+1})\) liegt, oder wenn \(q\) auf der Seite von \(n_{j+1}\), aber innerhalb von \(\cc (\triangle a n_j n_{j+1})\) liegt). Somit ist \(an_j\)
keine Delaunay-Kante.
</p>

<p>
Außerdem folgt, dass der Kreis mit dem sich verschiebenden Mittelpunkt auf der Mittelsenkrechten von \(ab\) zuerst \(n_{j+1}\) trifft und dann \(n_j\), d.&#x202f;h. der Kreis trifft \(n_i\) vor \(n_j\) fu&#x0308;r \(j &lt;
i\). Die Aussage \(c_L = n_i\) ist damit a&#x0308;quivalent dazu, dass \(n_i\) vor \(n_j\) fu&#x0308;r \(j &gt; i\) getroffen wird.
</p>

<p>
Sei also \(j &gt; i\) beliebig. Angenommen, \(n_j\) wird vor \(n_i\) getroffen. Dann gilt \(n_j \in \cc (\triangle abn_i)\) (der Umkreis \(\cc (\triangle abn_i)\) ist nach oben hin gro&#x0308;ßer worden im Vergleich
zum Zeitpunkt, als \(n_j\) getroffen wurde, und \(n_j\) liegt u&#x0308;ber \(ab\)), aber \(n_j\) liegt links von \(an_i\) (\(j &gt; i\) und Nummerierung im Gegenuhrzeigersinn). Dieser Teil des Kreises ist in \(\cc
(\triangle an_i n_{i+1})\) enthalten, ein Widerspruch, denn dieser Umkreis entha&#x0308;lt keine Punkte aus \(P_L\). &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Implementierung</b>:
</p>
<ul style="list-style-type:none">

<li class="list-item-f38"><p>Der Algorithmus betrachtet die Dreiecke \(\triangle a n_j n_{j+1}\) fu&#x0308;r steigendes \(j\) und fu&#x0308;hrt Umkreis-Tests fu&#x0308;r diese Dreiecke und \(b\) durch. Fu&#x0308;r \(j = i_L\)
stoppt die Suche. Das Ergebnis ist ein Punkt \(c_L\), den der Kreis durch \(a\) und \(b\) zuerst von denen in \(P_L\) trifft, und der zugeho&#x0308;rige Index \(i_L\). Die Kanten \(an_j\) fu&#x0308;r \(j &lt; i_L\)
ko&#x0308;nnen entfernt werden, weil sie nach obigem Lemma keine Delaunay-Kanten sind.
</p>
</li>
<li class="list-item-f39"><p>Dann fu&#x0308;hrt der Algorithmus die Prozedur analog fu&#x0308;r \(P_R\) durch, um \(c_R\) und \(i_R\) zu erhalten und bestimmte Kanten aus \(\DT (P_R)\) zu entfernen.
</p>
</li>
<li class="list-item-f40"><p>Schließlich wird ein weiterer Umkreis-Test durchgefu&#x0308;hrt, um zu bestimmen, ob \(c_L\) oder \(c_R\) zuerst getroffen wird. Wenn \(c_L\) zuerst getroffen wird, wird die Kante \(bc_L\)
hinzugefu&#x0308;gt, sonst \(ac_R\).
</p>
</li>
<li class="list-item-f41"><p>In jedem Fall macht der Algorithmus mit der hinzugefu&#x0308;gten Kante \(bc_L\) oder \(ac_R\) anstelle von \(ab\) weiter.
</p>
</li>
</ul>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Zeitbedarf</b>: \(\O (n \log n)\)
</p>

<p>
<b>Beweis</b>: Die Laufzeit des Conquer-Schritts ist linear in der Gesamtzahl \(i_L + i_R\) an „Suchschritten“ auf beiden Seiten. Weil fu&#x0308;r jeden Suchschritt eine andere Kante in \(\DT (P_L)\) oder \(\DT (P_R)\)
betrachtet wird, ist diese Zahl ho&#x0308;chstens gleich der Anzahl \(\O (n)\) an Kanten in beiden Delaunay-Triangulierungen, d.&#x202f;h. der Conquer-Schritt kostet \(\O (n)\) Zeit.
</p>

<p>
Bezeichnet \(T(n)\) die Zeit, die der Divide-and-Conquer-Algorithmus zur Berechnung der Delaunay-Triangulierung von \(n\) Punkten beno&#x0308;tigt, so gilt damit \(T(n) = 2T(\frac {n}{2}) + \O (n)\) (der Median kann
direkt in \(\O (n)\) berechnet werden, alternativ vorsortiert man die Punkte nach ihrer \(x\)-Koordinate und halbiert dann in jedem Divide-Schritt die Punktmenge in der Mitte).<br />
Mit dem Master-Theorem ergibt sich \(T(n) = \O (n \log n)\). &#x2003;&#x2003;
</p>



<h2 id="voronoi-diagramme"><span style="font-variant: small-caps;">Voronoi</span>-Diagramme</h2>

</p>


<p>
<b>Postamt-Problem</b>: Gegeben sind \(n\) Punkte (Posta&#x0308;mter) in \(P \subset \real ^2\) und ein Punkt \(q \in \real ^2\).<br />
Gesucht ist der Punkt \(p \in P\) mit \(\norm {p - q}\) minimal.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b><span class="textsc" >Voronoi</span>-Diagramm</b>: Das <em><span class="dashuline" ><span class="textsc" >Voronoi</span>-Diagramm</span></em> ist die Partition der Ebene in Knoten, Kanten und \(n\)
Zellen, sodass alle Punkte einer Zelle genau einem bestimmten Postamt am na&#x0308;chsten sind. (Kanten sind dabei Schnitte der Abschlu&#x0308;sse benachbarter Zellen und Knoten sind Schnitte der Abschlu&#x0308;sse
benachbarter Kanten.)
</p>

<p>
<b>Lemma (<span class="textsc" >Voronoi</span>-Zellen)</b>: Die Zellen sind konvex, polygonal berandet (aber evtl. unbegrenzt), zusammenha&#x0308;ngend und enthalten das zu ihnen assoziierte Postamt.
</p>

<p>
<b>Beweis</b>: Jede Zelle ist ein Schnitt von bestimmten offenen Halbebenen. Diese Halbebenen sind konvex, damit ist der Schnitt ebenfalls konvex (und polygonal berandet). Als konvexe Mengen sind die Zellen
zusammenha&#x0308;ngend. Das zu einer Zelle assoziierte Postamt ist sich selbst am na&#x0308;chsten, weswegen es in der Zelle enthalten ist. &#x2003;&#x2003;
</p>

<p>
<b>effiziente Lo&#x0308;sung des Postamt-Problems mit <span class="textsc" >Voronoi</span>-Diagrammen</b>:
</p>
<ul style="list-style-type:none">

<li class="list-item-f42"><p>Konstruiere das Voronoi-Diagramm von \(P\).
</p>
</li>
<li class="list-item-f43"><p>Trianguliere alle Zellen.
</p>
</li>
<li class="list-item-f44"><p>Konstruiere Suchstruktur u&#x0308;ber der entstehenden Triangulierung (Kirkpatrick-Hierarchie).
</p>
</li>
</ul>

<p>
<b>Zeitbedarf fu&#x0308;r Abfrage</b>: \(\O (\log n)\)
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Dualita&#x0308;t zwischen <span class="textsc" >Delaunay</span>-Triangulierung und <span class="textsc" >Voronoi</span>-Diagramm</b>:
</p>
<ul style="list-style-type:none">

<li class="list-item-f45"><p><em><span class="textsc" >Voronoi</span>-Knoten</em> sind charakterisiert durch drei Posta&#x0308;mter, die dem Knoten am na&#x0308;chsten liegen und alle gleich weit vom Knoten entfernt sind, und entsprechen
Kreisen durch diese drei Posta&#x0308;mter, die keine Posta&#x0308;mter enthalten, d.&#x202f;h. Delaunay-Dreiecken.<br />
Ein Voronoi-Knoten ist der Umkreis-Mittelpunkt des zugeho&#x0308;rigen Delaunay-Dreiecks.
</p>
</li>
<li class="list-item-f46"><p><em><span class="textsc" >Voronoi</span>-Kanten</em> sind charakterisiert dadurch, dass fu&#x0308;r alle Punkte auf der Kante genau zwei bestimmte Posta&#x0308;mter am na&#x0308;chsten sind, und entsprechen
Kreisen durch diese zwei Posta&#x0308;mter, die keine Posta&#x0308;mter enthalten, d.&#x202f;h. Delaunay-Kanten.<br />
Eine Voronoi-Kante ist ein Teil der Mittelsenkrechten der zugeho&#x0308;rigen Delaunay-Kante.
</p>
</li>
</ul>

<p>
Die unbegrenzten Voronoi-Zellen und -Kanten entsprechen den Punkten und Delaunay-Kanten auf dem Rand von \(\CH (P)\).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>in drei Dimensionen</b>: In \(\real ^3\) verbraucht das Voronoi-Diagramm \(\O (n^2)\) Platz, d.&#x202f;h. Punktlokalisierung ist effizient nicht mo&#x0308;glich. Man geht daher zu approximativer Lokalisierung
u&#x0308;ber.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Anwendungen von <span class="textsc" >Delaunay</span>-Triangulierung und <span class="textsc" >Voronoi</span>-Diagramm</b>:
</p>
<ul style="list-style-type:none">

<li class="list-item-f47"><p>Berechnung von <em><span class="dashuline" >Minimum Spanning Trees (MSTs)</span></em> einer Punktmenge \(P \subset \real ^2\) (vollsta&#x0308;ndiger Graph mit \(n\) Knoten, wobei die Kantengewichte gleich
den euklidischen Absta&#x0308;nden sind), weil man zeigen kann, dass die MST-Kanten eine Teilmenge der Delaunay-Triangulierung bilden (d.&#x202f;h. nur \(\O (n)\) Konstruktionsaufwand)
</p>
</li>
<li class="list-item-f48"><p><em><span class="dashuline" >Meshing</span></em> von Gebieten: oft mit Delaunay-Dreiecken, außerdem wird oft mit Umkreis-Mittelpunkten verfeinert
</p>
</li>
<li class="list-item-f49"><p><em><span class="dashuline" >Kurvenrekonstruktion</span></em>: gegeben sind \(n\) Punkte (Abtastung/Sampling) einer glatten, geschlossenen Kurve, aber ohne Reihenfolge, gesucht ist eine Approximation der Kurve, alle
Ansa&#x0308;tze arbeiten mit Delaunay-Triangulierungen oder Voronoi-Diagrammen
</p>
</li>
</ul>

{% endraw %}
</div>
{:/nomarkdown}
