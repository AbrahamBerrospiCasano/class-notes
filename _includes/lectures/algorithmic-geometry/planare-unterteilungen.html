
{::nomarkdown}
<div class="lwarp-contents">
{% raw %}
<div class="hidden" >

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\mathllap }[2][]{{#1#2}}\)

\(\newcommand {\mathrlap }[2][]{{#1#2}}\)

\(\newcommand {\mathclap }[2][]{{#1#2}}\)

\(\newcommand {\mathmbox }[1]{#1}\)

\(\newcommand {\clap }[1]{#1}\)

\(\newcommand {\LWRmathmakebox }[2][]{#2}\)

\(\newcommand {\mathmakebox }[1][]{\LWRmathmakebox }\)

\(\newcommand {\cramped }[2][]{{#1#2}}\)

\(\newcommand {\crampedllap }[2][]{{#1#2}}\)

\(\newcommand {\crampedrlap }[2][]{{#1#2}}\)

\(\newcommand {\crampedclap }[2][]{{#1#2}}\)

\(\newenvironment {crampedsubarray}[1]{}{}\)

\(\newcommand {\crampedsubstack }{}\)

\(\newcommand {\smashoperator }[2][]{#2\limits }\)

\(\newcommand {\adjustlimits }{}\)

\(\newcommand {\SwapAboveDisplaySkip }{}\)

\(\require {extpfeil}\)

\(\Newextarrow \xleftrightarrow {10,10}{0x2194}\)

\(\Newextarrow \xLeftarrow {10,10}{0x21d0}\)

\(\Newextarrow \xhookleftarrow {10,10}{0x21a9}\)

\(\Newextarrow \xmapsto {10,10}{0x21a6}\)

\(\Newextarrow \xRightarrow {10,10}{0x21d2}\)

\(\Newextarrow \xLeftrightarrow {10,10}{0x21d4}\)

\(\Newextarrow \xhookrightarrow {10,10}{0x21aa}\)

\(\Newextarrow \xrightharpoondown {10,10}{0x21c1}\)

\(\Newextarrow \xleftharpoondown {10,10}{0x21bd}\)

\(\Newextarrow \xrightleftharpoons {10,10}{0x21cc}\)

\(\Newextarrow \xrightharpoonup {10,10}{0x21c0}\)

\(\Newextarrow \xleftharpoonup {10,10}{0x21bc}\)

\(\Newextarrow \xleftrightharpoons {10,10}{0x21cb}\)

\(\newcommand {\LWRdounderbracket }[3]{\underset {#3}{\underline {#1}}}\)

\(\newcommand {\LWRunderbracket }[2][]{\LWRdounderbracket {#2}}\)

\(\newcommand {\underbracket }[1][]{\LWRunderbracket }\)

\(\newcommand {\LWRdooverbracket }[3]{\overset {#3}{\overline {#1}}}\)

\(\newcommand {\LWRoverbracket }[2][]{\LWRdooverbracket {#2}}\)

\(\newcommand {\overbracket }[1][]{\LWRoverbracket }\)

\(\newcommand {\LaTeXunderbrace }[1]{\underbrace {#1}}\)

\(\newcommand {\LaTeXoverbrace }[1]{\overbrace {#1}}\)

\(\newenvironment {matrix*}[1][]{\begin {matrix}}{\end {matrix}}\)

\(\newenvironment {pmatrix*}[1][]{\begin {pmatrix}}{\end {pmatrix}}\)

\(\newenvironment {bmatrix*}[1][]{\begin {bmatrix}}{\end {bmatrix}}\)

\(\newenvironment {Bmatrix*}[1][]{\begin {Bmatrix}}{\end {Bmatrix}}\)

\(\newenvironment {vmatrix*}[1][]{\begin {vmatrix}}{\end {vmatrix}}\)

\(\newenvironment {Vmatrix*}[1][]{\begin {Vmatrix}}{\end {Vmatrix}}\)

\(\newenvironment {smallmatrix*}[1][]{\begin {matrix}}{\end {matrix}}\)

\(\newenvironment {psmallmatrix*}[1][]{\begin {pmatrix}}{\end {pmatrix}}\)

\(\newenvironment {bsmallmatrix*}[1][]{\begin {bmatrix}}{\end {bmatrix}}\)

\(\newenvironment {Bsmallmatrix*}[1][]{\begin {Bmatrix}}{\end {Bmatrix}}\)

\(\newenvironment {vsmallmatrix*}[1][]{\begin {vmatrix}}{\end {vmatrix}}\)

\(\newenvironment {Vsmallmatrix*}[1][]{\begin {Vmatrix}}{\end {Vmatrix}}\)

\(\newenvironment {psmallmatrix}[1][]{\begin {pmatrix}}{\end {pmatrix}}\)

\(\newenvironment {bsmallmatrix}[1][]{\begin {bmatrix}}{\end {bmatrix}}\)

\(\newenvironment {Bsmallmatrix}[1][]{\begin {Bmatrix}}{\end {Bmatrix}}\)

\(\newenvironment {vsmallmatrix}[1][]{\begin {vmatrix}}{\end {vmatrix}}\)

\(\newenvironment {Vsmallmatrix}[1][]{\begin {Vmatrix}}{\end {Vmatrix}}\)

\(\newcommand {\LWRmultlined }[1][]{\begin {multline*}}\)

\(\newenvironment {multlined}[1][]{\LWRmultlined }{\end {multline*}}\)

\(\let \LWRorigshoveleft \shoveleft \)

\(\renewcommand {\shoveleft }[1][]{\LWRorigshoveleft }\)

\(\let \LWRorigshoveright \shoveright \)

\(\renewcommand {\shoveright }[1][]{\LWRorigshoveright }\)

\(\newenvironment {dcases}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {dcases*}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {rcases}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {rcases*}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {drcases}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {drcases*}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {cases*}{\begin {cases}}{\end {cases}}\)

\(\newcommand {\MoveEqLeft }[1][]{}\)

\(\def \LWRAboxed #1&amp;#2&amp;#3!|!{\fbox {\(#1\)}&amp;\fbox {\(#2\)}} \newcommand {\Aboxed }[1]{\LWRAboxed #1&amp;&amp;!|!} \)

\( \newcommand {\LWRABLines }[1][\Updownarrow ]{#1 \notag \\}\newcommand {\ArrowBetweenLines }{\ifstar \LWRABLines \LWRABLines } \)

\(\newcommand {\shortintertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\vdotswithin }[1]{\hspace {.5em}\vdots }\)

\(\newcommand {\LWRshortvdotswithinstar }[1]{\vdots \hspace {.5em} &amp; \\}\)

\(\newcommand {\LWRshortvdotswithinnostar }[1]{&amp; \hspace {.5em}\vdots \\}\)

\(\newcommand {\shortvdotswithin }{\ifstar \LWRshortvdotswithinstar \LWRshortvdotswithinnostar }\)

\(\newcommand {\MTFlushSpaceAbove }{}\)

\(\newcommand {\MTFlushSpaceBelow }{\\}\)

\(\newcommand \lparen {(}\)

\(\newcommand \rparen {)}\)

\(\newcommand {\ordinarycolon }{:}\)

\(\newcommand {\vcentcolon }{\mathrel {\mathop \ordinarycolon }}\)

\(\newcommand \dblcolon {\vcentcolon \vcentcolon }\)

\(\newcommand \coloneqq {\vcentcolon =}\)

\(\newcommand \Coloneqq {\dblcolon =}\)

\(\newcommand \coloneq {\vcentcolon {-}}\)

\(\newcommand \Coloneq {\dblcolon {-}}\)

\(\newcommand \eqqcolon {=\vcentcolon }\)

\(\newcommand \Eqqcolon {=\dblcolon }\)

\(\newcommand \eqcolon {\mathrel {-}\vcentcolon }\)

\(\newcommand \Eqcolon {\mathrel {-}\dblcolon }\)

\(\newcommand \colonapprox {\vcentcolon \approx }\)

\(\newcommand \Colonapprox {\dblcolon \approx }\)

\(\newcommand \colonsim {\vcentcolon \sim }\)

\(\newcommand \Colonsim {\dblcolon \sim }\)

\(\newcommand {\nuparrow }{\mathrel {\cancel {\uparrow }}}\)

\(\newcommand {\ndownarrow }{\mathrel {\cancel {\downarrow }}}\)

\(\newcommand {\bigtimes }{\mathop {\Large \times }\limits }\)

\(\newcommand {\prescript }[3]{{}^{#1}_{#2}#3}\)

\(\newenvironment {lgathered}{\begin {gathered}}{\end {gathered}}\)

\(\newenvironment {rgathered}{\begin {gathered}}{\end {gathered}}\)

\(\newcommand {\splitfrac }[2]{{}^{#1}_{#2}}\)

\(\let \splitdfrac \splitfrac \)

\(\newcommand {\LWRoverlaysymbols }[2]{\mathord {\smash {\mathop {#2\strut }\limits ^{\smash {\lower 3ex{#1}}}}\strut }}\)

\(\newcommand{\alphaup}{\unicode{x03B1}}\)

\(\newcommand{\betaup}{\unicode{x03B2}}\)

\(\newcommand{\gammaup}{\unicode{x03B3}}\)

\(\newcommand{\digammaup}{\unicode{x03DD}}\)

\(\newcommand{\deltaup}{\unicode{x03B4}}\)

\(\newcommand{\epsilonup}{\unicode{x03F5}}\)

\(\newcommand{\varepsilonup}{\unicode{x03B5}}\)

\(\newcommand{\zetaup}{\unicode{x03B6}}\)

\(\newcommand{\etaup}{\unicode{x03B7}}\)

\(\newcommand{\thetaup}{\unicode{x03B8}}\)

\(\newcommand{\varthetaup}{\unicode{x03D1}}\)

\(\newcommand{\iotaup}{\unicode{x03B9}}\)

\(\newcommand{\kappaup}{\unicode{x03BA}}\)

\(\newcommand{\varkappaup}{\unicode{x03F0}}\)

\(\newcommand{\lambdaup}{\unicode{x03BB}}\)

\(\newcommand{\muup}{\unicode{x03BC}}\)

\(\newcommand{\nuup}{\unicode{x03BD}}\)

\(\newcommand{\xiup}{\unicode{x03BE}}\)

\(\newcommand{\omicronup}{\unicode{x03BF}}\)

\(\newcommand{\piup}{\unicode{x03C0}}\)

\(\newcommand{\varpiup}{\unicode{x03D6}}\)

\(\newcommand{\rhoup}{\unicode{x03C1}}\)

\(\newcommand{\varrhoup}{\unicode{x03F1}}\)

\(\newcommand{\sigmaup}{\unicode{x03C3}}\)

\(\newcommand{\varsigmaup}{\unicode{x03C2}}\)

\(\newcommand{\tauup}{\unicode{x03C4}}\)

\(\newcommand{\upsilonup}{\unicode{x03C5}}\)

\(\newcommand{\phiup}{\unicode{x03D5}}\)

\(\newcommand{\varphiup}{\unicode{x03C6}}\)

\(\newcommand{\chiup}{\unicode{x03C7}}\)

\(\newcommand{\psiup}{\unicode{x03C8}}\)

\(\newcommand{\omegaup}{\unicode{x03C9}}\)

\(\newcommand{\Alphaup}{\unicode{x0391}}\)

\(\newcommand{\Betaup}{\unicode{x0392}}\)

\(\newcommand{\Gammaup}{\unicode{x0393}}\)

\(\newcommand{\Digammaup}{\unicode{x03DC}}\)

\(\newcommand{\Deltaup}{\unicode{x0394}}\)

\(\newcommand{\Epsilonup}{\unicode{x0395}}\)

\(\newcommand{\Zetaup}{\unicode{x0396}}\)

\(\newcommand{\Etaup}{\unicode{x0397}}\)

\(\newcommand{\Thetaup}{\unicode{x0398}}\)

\(\newcommand{\Varthetaup}{\unicode{x03F4}}\)

\(\newcommand{\Iotaup}{\unicode{x0399}}\)

\(\newcommand{\Kappaup}{\unicode{x039A}}\)

\(\newcommand{\Lambdaup}{\unicode{x039B}}\)

\(\newcommand{\Muup}{\unicode{x039C}}\)

\(\newcommand{\Nuup}{\unicode{x039D}}\)

\(\newcommand{\Xiup}{\unicode{x039E}}\)

\(\newcommand{\Omicronup}{\unicode{x039F}}\)

\(\newcommand{\Piup}{\unicode{x03A0}}\)

\(\newcommand{\Varpiup}{\unicode{x03D6}}\)

\(\newcommand{\Rhoup}{\unicode{x03A1}}\)

\(\newcommand{\Sigmaup}{\unicode{x03A3}}\)

\(\newcommand{\Tauup}{\unicode{x03A4}}\)

\(\newcommand{\Upsilonup}{\unicode{x03A5}}\)

\(\newcommand{\Phiup}{\unicode{x03A6}}\)

\(\newcommand{\Chiup}{\unicode{x03A7}}\)

\(\newcommand{\Psiup}{\unicode{x03A8}}\)

\(\newcommand{\Omegaup}{\unicode{x03A9}}\)

\(\newcommand{\alphait}{\unicode{x1D6FC}}\)

\(\newcommand{\betait}{\unicode{x1D6FD}}\)

\(\newcommand{\gammait}{\unicode{x1D6FE}}\)

\(\newcommand{\digammait}{\mathit{\unicode{x03DD}}}\)

\(\newcommand{\deltait}{\unicode{x1D6FF}}\)

\(\newcommand{\epsilonit}{\unicode{x1D716}}\)

\(\newcommand{\varepsilonit}{\unicode{x1D700}}\)

\(\newcommand{\zetait}{\unicode{x1D701}}\)

\(\newcommand{\etait}{\unicode{x1D702}}\)

\(\newcommand{\thetait}{\unicode{x1D703}}\)

\(\newcommand{\varthetait}{\unicode{x1D717}}\)

\(\newcommand{\iotait}{\unicode{x1D704}}\)

\(\newcommand{\kappait}{\unicode{x1D705}}\)

\(\newcommand{\varkappait}{\unicode{x1D718}}\)

\(\newcommand{\lambdait}{\unicode{x1D706}}\)

\(\newcommand{\muit}{\unicode{x1D707}}\)

\(\newcommand{\nuit}{\unicode{x1D708}}\)

\(\newcommand{\xiit}{\unicode{x1D709}}\)

\(\newcommand{\omicronit}{\unicode{x1D70A}}\)

\(\newcommand{\piit}{\unicode{x1D70B}}\)

\(\newcommand{\varpiit}{\unicode{x1D71B}}\)

\(\newcommand{\rhoit}{\unicode{x1D70C}}\)

\(\newcommand{\varrhoit}{\unicode{x1D71A}}\)

\(\newcommand{\sigmait}{\unicode{x1D70E}}\)

\(\newcommand{\varsigmait}{\unicode{x1D70D}}\)

\(\newcommand{\tauit}{\unicode{x1D70F}}\)

\(\newcommand{\upsilonit}{\unicode{x1D710}}\)

\(\newcommand{\phiit}{\unicode{x1D719}}\)

\(\newcommand{\varphiit}{\unicode{x1D711}}\)

\(\newcommand{\chiit}{\unicode{x1D712}}\)

\(\newcommand{\psiit}{\unicode{x1D713}}\)

\(\newcommand{\omegait}{\unicode{x1D714}}\)

\(\newcommand{\Alphait}{\unicode{x1D6E2}}\)

\(\newcommand{\Betait}{\unicode{x1D6E3}}\)

\(\newcommand{\Gammait}{\unicode{x1D6E4}}\)

\(\newcommand{\Digammait}{\mathit{\unicode{x03DC}}}\)

\(\newcommand{\Deltait}{\unicode{x1D6E5}}\)

\(\newcommand{\Epsilonit}{\unicode{x1D6E6}}\)

\(\newcommand{\Zetait}{\unicode{x1D6E7}}\)

\(\newcommand{\Etait}{\unicode{x1D6E8}}\)

\(\newcommand{\Thetait}{\unicode{x1D6E9}}\)

\(\newcommand{\Varthetait}{\unicode{x1D6F3}}\)

\(\newcommand{\Iotait}{\unicode{x1D6EA}}\)

\(\newcommand{\Kappait}{\unicode{x1D6EB}}\)

\(\newcommand{\Lambdait}{\unicode{x1D6EC}}\)

\(\newcommand{\Muit}{\unicode{x1D6ED}}\)

\(\newcommand{\Nuit}{\unicode{x1D6EE}}\)

\(\newcommand{\Xiit}{\unicode{x1D6EF}}\)

\(\newcommand{\Omicronit}{\unicode{x1D6F0}}\)

\(\newcommand{\Piit}{\unicode{x1D6F1}}\)

\(\newcommand{\Rhoit}{\unicode{x1D6F2}}\)

\(\newcommand{\Sigmait}{\unicode{x1D6F4}}\)

\(\newcommand{\Tauit}{\unicode{x1D6F5}}\)

\(\newcommand{\Upsilonit}{\unicode{x1D6F6}}\)

\(\newcommand{\Phiit}{\unicode{x1D6F7}}\)

\(\newcommand{\Chiit}{\unicode{x1D6F8}}\)

\(\newcommand{\Psiit}{\unicode{x1D6F9}}\)

\(\newcommand{\Omegait}{\unicode{x1D6FA}}\)

\(\let \digammaup \Digammaup \)

\(\renewcommand {\digammait }{\mathit {\digammaup }}\)

\(\newcommand {\smallin }{\unicode {x220A}}\)

\(\newcommand {\smallowns }{\unicode {x220D}}\)

\(\newcommand {\notsmallin }{\LWRoverlaysymbols {/}{\unicode {x220A}}}\)

\(\newcommand {\notsmallowns }{\LWRoverlaysymbols {/}{\unicode {x220D}}}\)

\(\newcommand {\rightangle }{\unicode {x221F}}\)

\(\newcommand {\intclockwise }{\unicode {x2231}}\)

\(\newcommand {\ointclockwise }{\unicode {x2232}}\)

\(\newcommand {\ointctrclockwise }{\unicode {x2233}}\)

\(\newcommand {\oiint }{\unicode {x222F}}\)

\(\newcommand {\oiiint }{\unicode {x2230}}\)

\(\newcommand {\ddag }{\unicode {x2021}}\)

\(\newcommand {\P }{\unicode {x00B6}}\)

\(\newcommand {\copyright }{\unicode {x00A9}}\)

\(\newcommand {\dag }{\unicode {x2020}}\)

\(\newcommand {\pounds }{\unicode {x00A3}}\)

\(\newcommand {\iddots }{\unicode {x22F0}}\)

\(\newcommand {\utimes }{\overline {\times }}\)

\(\newcommand {\dtimes }{\underline {\times }}\)

\(\newcommand {\udtimes }{\overline {\underline {\times }}}\)

\(\newcommand {\leftwave }{\left \{}\)

\(\newcommand {\rightwave }{\right \}}\)

\(\newcommand {\toprule }[1][]{\hline }\)

\(\let \midrule \toprule \)

\(\let \bottomrule \toprule \)

\(\newcommand {\cmidrule }[2][]{}\)

\(\newcommand {\morecmidrules }{}\)

\(\newcommand {\specialrule }[3]{\hline }\)

\(\newcommand {\addlinespace }[1][]{}\)

\(\newcommand {\LWRsubmultirow }[2][]{#2}\)

\(\newcommand {\LWRmultirow }[2][]{\LWRsubmultirow }\)

\(\newcommand {\multirow }[2][]{\LWRmultirow }\)

\(\newcommand {\mrowcell }{}\)

\(\newcommand {\mcolrowcell }{}\)

\(\newcommand {\STneed }[1]{}\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\newcommand {\tothe }[1]{^{#1}}\)

\(\newcommand {\raiseto }[2]{{#2}^{#1}}\)

\(\newcommand {\ang }[2][]{(\mathrm {#2})\degree }\)

\(\newcommand {\num }[2][]{\mathrm {#2}}\)

\(\newcommand {\si }[2][]{\mathrm {#2}}\)

\(\newcommand {\LWRSI }[2][]{\mathrm {#1\LWRSInumber \,#2}}\)

\(\newcommand {\SI }[2][]{\def \LWRSInumber {#2}\LWRSI }\)

\(\newcommand {\numlist }[2][]{\mathrm {#2}}\)

\(\newcommand {\numrange }[3][]{\mathrm {#2\,\unicode {x2013}\,#3}}\)

\(\newcommand {\SIlist }[3][]{\mathrm {#2\,#3}}\)

\(\newcommand {\SIrange }[4][]{\mathrm {#2\,#4\,\unicode {x2013}\,#3\,#4}}\)

\(\newcommand {\tablenum }[2][]{\mathrm {#2}}\)

\(\newcommand {\ampere }{\mathrm {A}}\)

\(\newcommand {\candela }{\mathrm {cd}}\)

\(\newcommand {\kelvin }{\mathrm {K}}\)

\(\newcommand {\kilogram }{\mathrm {kg}}\)

\(\newcommand {\metre }{\mathrm {m}}\)

\(\newcommand {\mole }{\mathrm {mol}}\)

\(\newcommand {\second }{\mathrm {s}}\)

\(\newcommand {\becquerel }{\mathrm {Bq}}\)

\(\newcommand {\degreeCelsius }{\unicode {x2103}}\)

\(\newcommand {\coulomb }{\mathrm {C}}\)

\(\newcommand {\farad }{\mathrm {F}}\)

\(\newcommand {\gray }{\mathrm {Gy}}\)

\(\newcommand {\hertz }{\mathrm {Hz}}\)

\(\newcommand {\henry }{\mathrm {H}}\)

\(\newcommand {\joule }{\mathrm {J}}\)

\(\newcommand {\katal }{\mathrm {kat}}\)

\(\newcommand {\lumen }{\mathrm {lm}}\)

\(\newcommand {\lux }{\mathrm {lx}}\)

\(\newcommand {\newton }{\mathrm {N}}\)

\(\newcommand {\ohm }{\mathrm {\Omega }}\)

\(\newcommand {\pascal }{\mathrm {Pa}}\)

\(\newcommand {\radian }{\mathrm {rad}}\)

\(\newcommand {\siemens }{\mathrm {S}}\)

\(\newcommand {\sievert }{\mathrm {Sv}}\)

\(\newcommand {\steradian }{\mathrm {sr}}\)

\(\newcommand {\tesla }{\mathrm {T}}\)

\(\newcommand {\volt }{\mathrm {V}}\)

\(\newcommand {\watt }{\mathrm {W}}\)

\(\newcommand {\weber }{\mathrm {Wb}}\)

\(\newcommand {\day }{\mathrm {d}}\)

\(\newcommand {\degree }{\mathrm {^\circ }}\)

\(\newcommand {\hectare }{\mathrm {ha}}\)

\(\newcommand {\hour }{\mathrm {h}}\)

\(\newcommand {\litre }{\mathrm {l}}\)

\(\newcommand {\liter }{\mathrm {L}}\)

\(\newcommand {\arcminute }{^\prime }\)
\(\newcommand {\minute }{\mathrm {min}}\)

\(\newcommand {\arcsecond }{^{\prime \prime }}\)

\(\newcommand {\tonne }{\mathrm {t}}\)

\(\newcommand {\astronomicalunit }{au}\)

\(\newcommand {\atomicmassunit }{u}\)

\(\newcommand {\bohr }{\mathit {a}_0}\)

\(\newcommand {\clight }{\mathit {c}_0}\)

\(\newcommand {\dalton }{\mathrm {D}_\mathrm {a}}\)

\(\newcommand {\electronmass }{\mathit {m}_{\mathrm {e}}}\)

\(\newcommand {\electronvolt }{\mathrm {eV}}\)

\(\newcommand {\elementarycharge }{\mathit {e}}\)

\(\newcommand {\hartree }{\mathit {E}_{\mathrm {h}}}\)

\(\newcommand {\planckbar }{\mathit {\unicode {x210F}}}\)

\(\newcommand {\angstrom }{\mathrm {\unicode {x212B}}}\)

\(\let \LWRorigbar \bar \)

\(\newcommand {\bar }{\mathrm {bar}}\)

\(\newcommand {\barn }{\mathrm {b}}\)

\(\newcommand {\bel }{\mathrm {B}}\)

\(\newcommand {\decibel }{\mathrm {dB}}\)

\(\newcommand {\knot }{\mathrm {kn}}\)

\(\newcommand {\mmHg }{\mathrm {mmHg}}\)

\(\newcommand {\nauticalmile }{\mathrm {M}}\)

\(\newcommand {\neper }{\mathrm {Np}}\)

\(\newcommand {\yocto }{\mathrm {y}}\)

\(\newcommand {\zepto }{\mathrm {z}}\)

\(\newcommand {\atto }{\mathrm {a}}\)

\(\newcommand {\femto }{\mathrm {f}}\)

\(\newcommand {\pico }{\mathrm {p}}\)

\(\newcommand {\nano }{\mathrm {n}}\)

\(\newcommand {\micro }{\mathrm {\unicode {x00B5}}}\)

\(\newcommand {\milli }{\mathrm {m}}\)

\(\newcommand {\centi }{\mathrm {c}}\)

\(\newcommand {\deci }{\mathrm {d}}\)

\(\newcommand {\deca }{\mathrm {da}}\)

\(\newcommand {\hecto }{\mathrm {h}}\)

\(\newcommand {\kilo }{\mathrm {k}}\)

\(\newcommand {\mega }{\mathrm {M}}\)

\(\newcommand {\giga }{\mathrm {G}}\)

\(\newcommand {\tera }{\mathrm {T}}\)

\(\newcommand {\peta }{\mathrm {P}}\)

\(\newcommand {\exa }{\mathrm {E}}\)

\(\newcommand {\zetta }{\mathrm {Z}}\)

\(\newcommand {\yotta }{\mathrm {Y}}\)

\(\newcommand {\percent }{\mathrm {\%}}\)

\(\newcommand {\meter }{\mathrm {m}}\)

\(\newcommand {\metre }{\mathrm {m}}\)

\(\newcommand {\gram }{\mathrm {g}}\)

\(\newcommand {\kg }{\kilo \gram }\)

\(\newcommand {\of }[1]{_{\mathrm {#1}}}\)

\(\newcommand {\squared }{^2}\)

\(\newcommand {\square }[1]{\mathrm {#1}^2}\)

\(\newcommand {\cubed }{^3}\)

\(\newcommand {\cubic }[1]{\mathrm {#1}^3}\)

\(\newcommand {\per }{/}\)

\(\newcommand {\celsius }{\unicode {x2103}}\)

\(\newcommand {\fg }{\femto \gram }\)

\(\newcommand {\pg }{\pico \gram }\)

\(\newcommand {\ng }{\nano \gram }\)

\(\newcommand {\ug }{\micro \gram }\)

\(\newcommand {\mg }{\milli \gram }\)

\(\newcommand {\g }{\gram }\)

\(\newcommand {\kg }{\kilo \gram }\)

\(\newcommand {\amu }{\mathrm {u}}\)

\(\newcommand {\nm }{\nano \metre }\)

\(\newcommand {\um }{\micro \metre }\)

\(\newcommand {\mm }{\milli \metre }\)

\(\newcommand {\cm }{\centi \metre }\)

\(\newcommand {\dm }{\deci \metre }\)

\(\newcommand {\m }{\metre }\)

\(\newcommand {\km }{\kilo \metre }\)

\(\newcommand {\as }{\atto \second }\)

\(\newcommand {\fs }{\femto \second }\)

\(\newcommand {\ps }{\pico \second }\)

\(\newcommand {\ns }{\nano \second }\)

\(\newcommand {\us }{\micro \second }\)

\(\newcommand {\ms }{\milli \second }\)

\(\newcommand {\s }{\second }\)

\(\newcommand {\fmol }{\femto \mol }\)

\(\newcommand {\pmol }{\pico \mol }\)

\(\newcommand {\nmol }{\nano \mol }\)

\(\newcommand {\umol }{\micro \mol }\)

\(\newcommand {\mmol }{\milli \mol }\)

\(\newcommand {\mol }{\mol }\)

\(\newcommand {\kmol }{\kilo \mol }\)

\(\newcommand {\pA }{\pico \ampere }\)

\(\newcommand {\nA }{\nano \ampere }\)

\(\newcommand {\uA }{\micro \ampere }\)

\(\newcommand {\mA }{\milli \ampere }\)

\(\newcommand {\A }{\ampere }\)

\(\newcommand {\kA }{\kilo \ampere }\)

\(\newcommand {\ul }{\micro \litre }\)

\(\newcommand {\ml }{\milli \litre }\)

\(\newcommand {\l }{\litre }\)

\(\newcommand {\hl }{\hecto \litre }\)

\(\newcommand {\uL }{\micro \liter }\)

\(\newcommand {\mL }{\milli \liter }\)

\(\newcommand {\L }{\liter }\)

\(\newcommand {\hL }{\hecto \liter }\)

\(\newcommand {\mHz }{\milli \hertz }\)

\(\newcommand {\Hz }{\hertz }\)

\(\newcommand {\kHz }{\kilo \hertz }\)

\(\newcommand {\MHz }{\mega \hertz }\)

\(\newcommand {\GHz }{\giga \hertz }\)

\(\newcommand {\THz }{\tera \hertz }\)

\(\newcommand {\mN }{\milli \newton }\)

\(\newcommand {\N }{\newton }\)

\(\newcommand {\kN }{\kilo \newton }\)

\(\newcommand {\MN }{\mega \newton }\)

\(\newcommand {\Pa }{\pascal }\)

\(\newcommand {\kPa }{\kilo \pascal }\)

\(\newcommand {\MPa }{\mega \pascal }\)

\(\newcommand {\GPa }{\giga \pascal }\)

\(\newcommand {\mohm }{\milli \ohm }\)

\(\newcommand {\kohm }{\kilo \ohm }\)

\(\newcommand {\Mohm }{\mega \ohm }\)

\(\newcommand {\pV }{\pico \volt }\)

\(\newcommand {\nV }{\nano \volt }\)

\(\newcommand {\uV }{\micro \volt }\)

\(\newcommand {\mV }{\milli \volt }\)

\(\newcommand {\V }{\volt }\)

\(\newcommand {\kV }{\kilo \volt }\)

\(\newcommand {\W }{\watt }\)

\(\newcommand {\uW }{\micro \watt }\)

\(\newcommand {\mW }{\milli \watt }\)

\(\newcommand {\kW }{\kilo \watt }\)

\(\newcommand {\MW }{\mega \watt }\)

\(\newcommand {\GW }{\giga \watt }\)

\(\newcommand {\J }{\joule }\)

\(\newcommand {\uJ }{\micro \joule }\)

\(\newcommand {\mJ }{\milli \joule }\)

\(\newcommand {\kJ }{\kilo \joule }\)

\(\newcommand {\eV }{\electronvolt }\)

\(\newcommand {\meV }{\milli \electronvolt }\)

\(\newcommand {\keV }{\kilo \electronvolt }\)

\(\newcommand {\MeV }{\mega \electronvolt }\)

\(\newcommand {\GeV }{\giga \electronvolt }\)

\(\newcommand {\TeV }{\tera \electronvolt }\)

\(\newcommand {\kWh }{\kilo \watt \hour }\)

\(\newcommand {\F }{\farad }\)

\(\newcommand {\fF }{\femto \farad }\)

\(\newcommand {\pF }{\pico \farad }\)

\(\newcommand {\K }{\mathrm {K}}\)

\(\newcommand {\dB }{\mathrm {dB}}\)

\(\newcommand {\kibi }{\mathrm {Ki}}\)

\(\newcommand {\mebi }{\mathrm {Mi}}\)

\(\newcommand {\gibi }{\mathrm {Gi}}\)

\(\newcommand {\tebi }{\mathrm {Ti}}\)

\(\newcommand {\pebi }{\mathrm {Pi}}\)

\(\newcommand {\exbi }{\mathrm {Ei}}\)

\(\newcommand {\zebi }{\mathrm {Zi}}\)

\(\newcommand {\yobi }{\mathrm {Yi}}\)

\(\require {mhchem}\)

\(\require {cancel}\)

\(\newcommand {\fint }{âĺŊ}\)

\(\newcommand {\hdots }{\cdots }\)

\(\newcommand {\mathnormal }[1]{#1}\)

\(\newcommand {\vecs }[2]{\vec {#1}_{#2}}\)

\(\renewcommand {\A }{\mathcal {A}}\)

\(\newcommand {\D }{\mathcal {D}}\)

\(\renewcommand {\H }{\mathcal {H}}\)

\(\renewcommand {\L }{\mathcal {L}}\)

\(\renewcommand {\O }{\mathcal {O}}\)

\(\renewcommand {\P }{\mathcal {P}}\)

\(\newcommand {\T }{\mathcal {T}}\)

\(\newcommand {\EE }{\mathbb {E}}\)

\(\newcommand {\PP }{\mathbb {P}}\)

\(\newcommand {\DT }{\operatorname {DT}}\)

\(\newcommand {\dcup }{\mathbin {\dot {\cup }}}\)

\(\newcommand {\parent }{\operatorname {parent}}\)

\(\newcommand {\cc }{\operatorname {cc}}\)

\(\newcommand {\interior }{\operatorname {int}}\)

\(\newcommand {\CH }{\operatorname {CH}}\)

\(\newcommand {\sgn }{\operatorname {sgn}}\)

\(\newcommand {\zone }{\operatorname {zone}}\)

\(\newcommand {\code }[1]{\texttt {#1}}\)

\(\newcommand {\name }[1]{\textsc {#1}}\)

\(\newcommand {\smallpmatrix }[1]{\left (\begin {smallmatrix}#1\end {smallmatrix}\right )}\)

\(\newcommand {\matlab }{{\fontfamily {bch}\scshape \selectfont {}Matlab}}\)

\(\newcommand {\innerproduct }[1]{\left \langle {#1}\right \rangle }\)

\(\newcommand {\norm }[1]{\left \Vert {#1}\right \Vert }\)

\(\renewcommand {\natural }{\mathbb {N}}\)

\(\newcommand {\integer }{\mathbb {Z}}\)

\(\newcommand {\rational }{\mathbb {Q}}\)

\(\newcommand {\real }{\mathbb {R}}\)

\(\newcommand {\complex }{\mathbb {C}}\)

\(\renewcommand {\d }{\mathop {}\!\mathrm {d}}\)

\(\newcommand {\dr }{\d {}r}\)

\(\newcommand {\ds }{\d {}s}\)

\(\newcommand {\dt }{\d {}t}\)

\(\newcommand {\du }{\d {}u}\)

\(\newcommand {\dv }{\d {}v}\)

\(\newcommand {\dw }{\d {}w}\)

\(\newcommand {\dx }{\d {}x}\)

\(\newcommand {\dy }{\d {}y}\)

\(\newcommand {\dz }{\d {}z}\)

\(\newcommand {\dsigma }{\d {}\sigma }\)

\(\newcommand {\dphi }{\d {}\phi }\)

\(\newcommand {\dvarphi }{\d {}\varphi }\)

\(\newcommand {\dtau }{\d {}\tau }\)

\(\newcommand {\dxi }{\d {}\xi }\)

\(\newcommand {\dtheta }{\d {}\theta }\)

\(\newcommand {\tp }{\mathrm {T}}\)

</div>

<style type="text/css">
.lwarp-contents li.list-item-f0::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f1::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f2::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f3::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f4::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f5::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f6::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f7::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f8::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f9::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f10::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f11::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f12::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f13::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f14::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f15::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f16::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f17::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f18::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f19::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f20::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f21::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f22::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f23::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f24::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f25::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f26::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f27::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f28::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f29::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f30::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f31::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f32::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f33::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f34::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f35::marker {
  font-style:italic;
  content:'(4)\00a0\00a0';
}
.lwarp-contents li.list-item-f36::marker {
  font-style:italic;
  content:'(5)\00a0\00a0';
}
</style>
<p>

</p>


<p>
Planare Unterteilungen finden viele Anwendungen bei Geoinformationssystemen (GIS). Dabei wird ein Teil der Ebene \(\real ^2\) in Zellen unterteilt (Postleitzahlen, Telefonvorwahlen, Landkreise usw.). Typische Operationen auf
Unterteilungen sind zum einen die Lokalisierung (in welcher Zelle befindet sich ein gegebener Punkt), zum anderen die U&#x0308;berlagerung zweier Unterteilungen (z.&#x202f;B. Gebiete gleicher Vorwahl und gleicher
Postleitzahl). Fu&#x0308;r das letzte Problem bestimmt man im Wesentlichen die Schnittpunkte der Zellenra&#x0308;nder und berechnet so die Zellen der verfeinerten U&#x0308;berlagerung.
</p>



<h2 id="schnitt-von-strecken">Schnitt von Strecken</h2>

</p>


<p>
<b>Problem</b>: Gegeben sei eine Menge \(S\) von Strecken, jede angegeben durch ihre beiden Endpunkte in \(\real ^2\). Gesucht ist die Menge aller Paare sich schneidender Strecken.
</p>

<p>
Fu&#x0308;r \(|S| = n\) und \(k\) der Anzahl der Schnittpunkte ist das Ziel, einen Algorithmus mit Laufzeit \(\O (n \log n + k)\) zu finden. \(\O (n \log n)\) ist nicht mo&#x0308;glich, da \(k \in \omega (n \log n)\)
sein kann (z.&#x202f;B. lauter horizontale und lauter vertikale Linien fu&#x0308;hren zu \(k \in \Theta (n^2)\)).
</p>



<h3 id="sweep-line-algorithmus">Sweep-Line-Algorithmus</h3>

</p>


<p>
Beim <em><span class="dashuline" >Sweep-Line-Paradigma</span></em> la&#x0308;sst man im Prinzip eine vertikale Gerade von links nach rechts u&#x0308;ber die Ebene laufen, wobei die Invariante gelten soll, dass alles
links der Gerade schon berechnet wurde (hier die Schnittpunkte links der Sweep-Line) und alles rechts der Gerade noch erkundet werden muss.
</p>

<p>
Im Folgenden geht man davon aus, dass es keine vertikalen Strecken gibt (oBdA durch Rotation mo&#x0308;glich).
</p>

<p>
<b>Sweep-Line-Datenstrukturen</b>: Der Sweep-Line-Algorithmus verwaltet 2 Datenstrukturen.
</p>
<ul style="list-style-type:none">

<li class="list-item-f0"><p><em><span class="dashuline" >\(X\)-Struktur</span></em> (Min-Heap u&#x0308;ber \(x\)-Koordinaten): entha&#x0308;lt alle Strecken-Endpunkte rechts der SL und die Schnittpunkte rechts der SL, die zu Strecken
geho&#x0308;ren, die die SL momentan schneiden und auf ihr benachbart sind
</p>
</li>
<li class="list-item-f1"><p><em><span class="dashuline" >\(Y\)-Struktur</span></em> (2-4-Baum): entha&#x0308;lt alle Strecken, die die SL momentan schneiden, geordnet gema&#x0308;ß der \(y\)-Koordinate des Schnittpunkts zwischen Segment
und SL
</p>
</li>
</ul>

<p>
<b>Sweep-Line-Algorithmus</b>: Der <em><span class="dashuline" >Sweep-Line-Algorithmus (SL-Algorithmus)</span></em> arbeitet wie folgt.
</p>
<ul style="list-style-type:none">

<li class="list-item-f2"><p>Fu&#x0308;ge alle Endpunkte gema&#x0308;ß ihrer \(x\)-Koordinate in die \(X\)-Struktur ein.
</p>
</li>
<li class="list-item-f3"><p>Die \(Y\)-Struktur entha&#x0308;lt anfangs keine Elemente.
</p>
</li>
<li class="list-item-f4"><p>Wiederhole Folgendes, wa&#x0308;hrend die \(X\)-Struktur nicht-leer ist:
</p>
<ul style="list-style-type:none">

<li class="list-item-f5"><p>Bestimme den Punkt \(p\) aus der \(X\)-Struktur mit der kleinsten \(x\)-Koordinate und entferne ihn aus der \(X\)-Struktur.
</p>
</li>
<li class="list-item-f6"><p>Rufe \(\code {process}(p)\) auf.
</p>
</li>
</ul>
</li>
</ul>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Prozedur \(\code {process}(p)\)</b>:
</p>
<ul style="list-style-type:none">

<li class="list-item-f7"><p>Ist \(p\) der linke Endpunkt einer Strecke \(s\), dann fu&#x0308;ge \(s\) in die \(Y\)-Struktur ein, teste auf Schnittpunkte rechts der SL und fu&#x0308;ge sie ggf. in die \(X\)-Struktur ein.
</p>
</li>
<li class="list-item-f8"><p>Ist \(p\) der rechte Endpunkt einer Strecke \(s\), dann entferne \(s\) aus der \(Y\)-Struktur, teste ggf. die beiden neu benachbarten Strecken in der \(Y\)-Struktur auf einen Schnittpunkt rechts der SL und
fu&#x0308;ge ihn ggf. in die \(X\)-Struktur ein.
</p>
</li>
<li class="list-item-f9"><p>Ist \(p\) der Schnittpunkt zweier Strecken \(s_1\) und \(s_2\), dann tausche \(s_1\) und \(s_2\) in der \(Y\)-Struktur, teste zwei neue Nachbarschaften auf Schnittpunkte rechts der SL und fu&#x0308;ge sie ggf. in
die \(X\)-Struktur ein.
</p>
</li>
</ul>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Korrektheit</b>: Der Algorithmus arbeitet korrekt.
</p>

<p>
<b>Beweis</b>: Zwei Strecken mu&#x0308;ssen auf der SL benachbart sein, bevor die SL ihren Schnittpunkt erreicht. Allerdings wird jedes Mal, wenn zwei Strecken benachbart werden ko&#x0308;nnen, ein Test auf Schnittpunkte
durchgefu&#x0308;hrt, d.&#x202f;h. alle Schnittpunkte werden erfasst. &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Problem</b>: Ein Problem ist, dann Schnittpunkte mehrfach in die \(X\)-Struktur eingefu&#x0308;gt werden ko&#x0308;nnen. Man stelle sich zwei große, sich schneidende Strecken \(s_1, s_2\) und sehr viele kurze Strecken
zwischen den beiden linken Endpunkten von \(s_1, s_2\) und ihrem Schnittpunkt \(S\) vor, wobei sich die kurzen Strecken vertikal nicht u&#x0308;berlagern. In diesem Fall wird jedes Mal, wenn die SL auf einen rechten Endpunkt
einer der kurzen Strecken sto&#x0308;ßt, der Schnittpunkt \(S\) in die \(X\)-Struktur aufgenommen, d.&#x202f;h. \(\Theta (n)\)-mal.
</p>

<p>
<b>Lo&#x0308;sung</b>: Man kann zwar zeigen, dass das nicht sonderlich problematisch ist. Eine einfache Lo&#x0308;sung besteht aber darin, dass Schnittpunkte wieder entfernt werden, wenn zwei Strecken auf der SL auf
einmal nicht mehr benachbart sind (was man ohnehin eigentlich tun muss, weil obiger Algorithmus die oben definierte Eigenschaft der \(X\)-Struktur nicht erfu&#x0308;llt).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Zeitbedarf</b>: \(\O ((n + k) \log n)\)
</p>

<p>
<b>Beweis</b>: In die \(X\)-Struktur werden insgesamt \(2n + k\) viele Punkte aufgenommen, na&#x0308;mlich genau alle Strecken-Endpunkte und alle Schnittpunkte. Bei jedem „Ereignis“ wird \(\code {process}(p)\)
aufgerufen. Implementiert man die \(X\)-Struktur als Min-Heap und die \(Y\)-Struktur als 2-4-Baum, dann kostet jeder Aufruf \(\O (\log n)\) Zeit, denn \(X\)- und \(Y\)-Struktur enthalten jeweils stets \(\O (n)\) Elemente. Dies
ergibt eine Laufzeit von \(\O ((2n + k) \log n) = \O ((n + k) \log n)\). &#x2003;&#x2003;
</p>

<p>
Ist \(k \in \Theta (n^2)\), dann ist der Sweep-Line-Algorithmus sogar schlechter als die naive Methode, alle mo&#x0308;glichen Paare zu u&#x0308;berpru&#x0308;fen (was \(\O (n^2)\) Zeit braucht). Daher folgt ein besserer
Algorithmus zur Bestimmung von Schnittpunkten.
</p>



<h3 id="ric-algorithmus">RIC-Algorithmus</h3>

</p>


<p>
Seien wieder alle Strecken nicht-senkrecht und keine drei Strecken schneiden sich in einem Punkt.
</p>

<p>
<b>Trapezierung</b>: Eine <em><span class="dashuline" >Trapezierung</span></em> einer Menge \(S\) von Strecken in \(\real ^2\) wird gebildet durch die Menge selbst sowie alle vertikalen Strahlen, die von Endpunkten
und Schnittpunkten aus nach oben oder unten laufen, bis sie auf eine Strecke treffen (oder bis \(\pm \infty \)).
</p>

<p>
<b>Pseudoecke</b>: Eine <em><span class="dashuline" >Pseudoecke</span></em> ist der Endpunkt eines Strahls, der in diesem Punkt auf eine Strecke trifft.
</p>

<p>
<b>Komplexita&#x0308;t</b>: Fu&#x0308;r \(|S| = n\) und \(k\) der Anzahl der Schnittpunkte gibt es \(\le 2(2n + k) = 4n + 2k\) Pseudoecken (von jedem Endpunkt und Schnittpunkt gehen zwei Strahlen aus). Betrachtet
man die Trapezierung als Graph mit den Endpunkten, Schnittpunkten und Pseudoecken als Ecken, so hat dieser als planarer Graph \(\O (n + k)\) Kanten und Facetten. Damit hat die Trapezierung den Platzbedarf \(\O (n + k)\).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
Wenn eine Trapezierung von \(S\) berechnet wird, werden die Schnittpunkte automatisch mitberechnet. Der Sweep-Line-Algorithmus ko&#x0308;nnte auch die Trapezierung berechnen, allerdings in \(\O ((n + k)\log n)\) Zeit.
</p>

<p>
<b>Berechnung einer Trapezierung</b>:
</p>
<ul style="list-style-type:none">

<li class="list-item-f10"><p>Berechne die Trapezierung der Endpunkte (also nur die vertikalen Strahlen der Endpunkte).
</p>
</li>
<li class="list-item-f11"><p>Fu&#x0308;ge die Strecken zufa&#x0308;llig nacheinander in die Trapezierung ein (evtl. mu&#x0308;ssen vertikale Strahlen geku&#x0308;rzt werden oder bei Schnittpunkten entstehen neue).
</p>
</li>
</ul>

<p>
Der erste Schritt kostet die Zeit \(\O (n \log n)\) (Zeit zum Sortieren der Endpunkte). Beim zweiten Schritt fu&#x0308;gt man ein Segment ein, indem man in einem Endpunkt startet und dann das Trapez berechnet, in das die
Strecke als „na&#x0308;chstes“ eintreten wird. Ist \(\tau \) das aktuelle Trapez, so kostet die Bestimmung des na&#x0308;chsten Trapezes \(\deg (\tau )\)-viele Schritte, wobei \(\deg (\tau )\) die Anzahl der Endpunkte,
Schnittpunkte und Pseudoecken ist, die auf dem Rand von \(\tau \) liegen.
</p>

<p>
<b>Probleme</b>:
</p>
<ul style="list-style-type:none">

<li class="list-item-f12"><p>Es kann Trapeze \(\tau \) geben mit \(\deg (\tau ) = \Theta (n)\).
</p>
</li>
<li class="list-item-f13"><p>Es kann sein, dass bei jeder Einfu&#x0308;gung einer Strecke viele Trapeze durchquert werden mu&#x0308;ssen. Wa&#x0308;hlt man z.&#x202f;B. lauter horizontale, u&#x0308;bereinander liegende Strecken, die symmetrisch
um einen Punkt nach oben hin immer kleiner werden, und fu&#x0308;gt diese Strecken von unten nach oben ein, dann werden bei der \(i\)-ten Einfu&#x0308;gung \(2(n - i)\) Trapeze durchlaufen, d.&#x202f;h. insgesamt
\(\Omega (n^2)\) (dabei haben diese Strecken nicht einmal einen Schnittpunkt).
</p>
</li>
</ul>

<p>
Die Probleme werden allerdings durch die Randomisierung beseitigt.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>erwartete Laufzeit</b>: \(\O (n \log n + k)\)
</p>

<p>
<b>Beweis</b>: Sei \(s \in S\) eine Strecke, die in die Trapezierung \(\T (R’)\) der bisherigen Strecken \(R’\) eingefu&#x0308;gt werden soll. Die Kosten fu&#x0308;r die Einfu&#x0308;gung von \(s\) in \(\T (R’)\) sind
\(\sum _{\tau \in \T (R’),\; s \cap \tau \not = \emptyset } \deg (\tau )\). Diese Kosten ko&#x0308;nnen in Abha&#x0308;ngigkeit der Trapezierung \(\T (R)\), nachdem \(s\) eingefu&#x0308;gt wurde, mit \(R
:= R’ \cup \{s\}\) ausgedru&#x0308;ckt werden: \(\sum _{\tau \in \T (R),\; s \text { begrenzt } \tau } \deg (\tau )\) (Ru&#x0308;ckwa&#x0308;rtsanalyse).
</p>

<p>
Ist nur die Trapezierung \(\T (R)\) gegeben, so ha&#x0308;tte jede Strecke \(s \in R\) mit gleicher Wahrscheinlichkeit als letzte eingefu&#x0308;gt werden ko&#x0308;nnen. Mit \(r := |R|\) sind die erw. Kosten fu&#x0308;r
das Einfu&#x0308;gen des \(r\)-ten Segments gleich \(\frac {1}{r} \sum _{s \in R} \sum _{\tau \in \T (R),\; s \text { begrenzt } \tau } \deg (\tau ) = \frac {1}{r} \sum _{\tau \in \T (R)} \deg
(\tau ) \sum _{s \in R,\; s \text { begrenzt } \tau } 1\). Weil es ho&#x0308;chstens zwei Segmente \(s \in R\) gibt, die ein Trapez begrenzen ko&#x0308;nnen, ist die innere Summe ho&#x0308;chstens \(2\). Damit
sind die erw. Kosten fu&#x0308;r das \(r\)-te Segment \(\le \frac {2}{r} \sum _{\tau \in \T (R)} \deg (\tau )\)<br />
\(= \frac {2}{r} \cdot \O (n + k_R)\) mit \(k_R\) der Anzahl an Schnittpunkten in \(R\), denn die Trapezierung \(\T (R)\) hat als planarer Graph \(\O (n + k_R)\) viele Ecken, Schnittpunkte und Pseudoecken (bei der
Summerierung werden gleiche Ecken, Schnittpunkte oder Pseudoecken nur \(\O (1)\)-mal mehrfach geza&#x0308;hlt).
</p>

<p>
Es gilt \(\EE [k_R] = \frac {r(r-1)}{n(n-1)} k\) (ein Schnittpunkt ist in \(R\) genau dann, wenn beide Strecken in \(R\) sind). Damit erha&#x0308;lt man \(\frac {2}{r} \cdot \O (n + k_R) = \O (\frac {n}{r} + k
\cdot \frac {r - 1}{n(n-1)})\) und die erwarteten Gesamtkosten betragen \(\sum _{r=1}^n \O (\frac {n}{r} + k \cdot \frac {r - 1}{n(n-1)}) = \O (n \log n + k \cdot \sum _{r=1}^n \frac {r}{n^2}) = \O
(n \log n + k)\). &#x2003;&#x2003;
</p>
<h2 id="lokalisierung-in-planaren-unterteilungen">Lokalisierung in planaren Unterteilungen</h2>

</p>


<p>
<b>Problem</b>: Gegeben sei eine planare Unterteilung \(\P \) mit \(n\) Ecken (als planare Einbettung mit geraden Linien eines planaren Graphs). Gesucht ist fu&#x0308;r einen Punkt \(q \in \real ^2\) die Facette \(f\) von
\(\P \) mit \(q \in f\).
</p>

<p>
Eine naive Lo&#x0308;sung kostet \(\O (n)\) Zeit (ob \(q\) in einem Polygon \(f\) ist, kann in \(\O (1)\) Zeit gepru&#x0308;ft werden, indem ein Strahl in eine beliebige Richtung konstruiert und die Anzahl der Schnittpunkte
mit dem Polygon geza&#x0308;hlt wird).
</p>

<p>
Das Ziel ist die Lokalisierung in \(\O (\log n)\) Zeit mit \(\O (n)\) Speicher.
</p>

<p>
Im Folgenden ist ein Polygon immer ein einfaches Polygon ohne Lo&#x0308;cher (keine Selbstu&#x0308;berschneidungen).
</p>



<h3 id="triangulierung-eines-polygons">Triangulierung eines Polygons</h3>

</p>


<p>
<b>Triangulierung eines Polygons</b>: Aus einer Trapezierung eines Polygons mit \(n\) Ecken kann man in \(\O (n)\) Zeit eine Triangulierung des Polygons berechnen.
</p>
<ul style="list-style-type:none">

<li class="list-item-f14"><p>Konstruiere die Trapezierung der Kanten.
</p>
</li>
<li class="list-item-f15"><p>Fu&#x0308;r jedes Trapez, das Polygonecken auf gegenu&#x0308;berliegenden vertikalen Strahlen besitzt, verbinde diese Ecken, falls sie noch nicht verbunden sind. Das zerlegt das Polygon in <em><span
class="dashuline" >\(x\)-monotone Polygone</span></em> (Polygone, deren Kanten in zwei Teile aufgeteilt werden ko&#x0308;nnen, sodass die \(x\)-Koordinaten jedes Teils monoton steigen oder fallen), deren eine Seite eine
einzelne Kante ist (<em><span class="dashuline" >\(x\)-Kammpolygon</span></em>).
</p>
</li>
<li class="list-item-f16"><p>Trianguliere jedes \(x\)-monotone Polygon.
</p>
</li>
</ul>

<p>
Damit ko&#x0308;nnen Polygone mit \(n\) Ecken in \(\O (n \log n)\) Zeit trianguliert werden.
</p>



<h3 id="kirkpatrick-hierarchie"><span style="font-variant: small-caps;">Kirkpatrick</span>-Hierarchie</h3>

</p>


<p>
<b>Annahmen</b>:
</p>
<ul style="list-style-type:none">

<li class="list-item-f17"><p>Durch obigen Algorithmus kann man annehmen, dass jede Facette von \(\P \) ein Dreieck ist.
</p>
</li>
<li class="list-item-f18"><p>Man kann außerdem annehmen, dass die <em><span class="dashuline" >a&#x0308;ußere Fla&#x0308;che</span></em> (d.&#x202f;h. die Umrandung von \(\P \)) ebenfalls ein Dreieck ist. Falls das nicht der Fall ist,
fu&#x0308;gt man einfach drei Ecken um \(\P \) weit entfernt von den anderen Ecken hinzu und trianguliert neu.
</p>
</li>
</ul>

<p>
Der resultierende Graph ist immer noch planar, d.&#x202f;h. es gibt \(\O (n)\) Kanten und \(\O (n)\) Facetten (\(n\) Anzahl der Ecken).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>unabha&#x0308;ngige Menge</b>: Sei \(G = (V, E)\) ein ungerichteter Graph.<br />
Eine Teilmenge \(I \subset V\) heißt <em><span class="dashuline" >unabha&#x0308;ngig</span></em> (oder <em><span class="dashuline" >stabil</span></em>), falls \(\forall _{x, y \in I}\; \{x, y\} \notin
E\).
</p>

<p>
<b>Lemma</b>: In einem planaren Graph \(G = (V, E)\) existiert eine unabha&#x0308;ngige Menge \(I \subset V\) mit \(|I| \ge \frac {|V|}{24}\) und \(\forall _{x \in I}\; \deg (x) \le 11\).
</p>

<p>
<b>Beweis</b>: Seien \(n := |V|\), \(m := |E|\) und \(k\) die Anzahl der Facetten von \(G\). Fu&#x0308;r eine gegebene Kantenzahl \(m\) bekommt man die maximale Facettenzahl \(k\), wenn der Graph nur aus Dreiecken
besteht und voll trianguliert ist (bei gro&#x0308;ßeren \(n\)-Ecken verschwendet man Kanten). Nutzt man je zwei Kanten zur Bildung eines Dreiecks, so bekommt man \(3k \le 2m\). Aus dem eulerschen Polyedersatz \(n - m + k
= 2\) erha&#x0308;lt man \(m = n + k - 2 \le n + \frac {2m}{3} - 2\), d.&#x202f;h. \(m \le 3n - 6\).
</p>

<p>
Damit gilt \(\sum _{x \in V} \deg (x) = 2m \le 6n - 12\), denn jede Kante ist genau zu zwei Knoten inzident.
</p>

<p>
Es gibt daher \(\ge \frac {n}{2}\) Knoten, die Grad \(\le 11\) haben: Sei \(S := \{x \in V \;|\; \deg (x) \le 11\}\), dann wa&#x0308;re andernfalls \(|S| &lt; \frac {n}{2}\), also \(|V \setminus S| &gt; n -
\frac {n}{2} = \frac {n}{2}\). Daraus folgt \(6n - 12 \ge \sum _{x \in V} \deg (x)\)<br />
\(\ge \sum _{x \in V \setminus S} \deg (x) \ge \sum _{x \in V \setminus S} 12 = 6n\), ein Widerspruch.
</p>

<p>
Indem man nacheinander Ecken aus \(S\) wa&#x0308;hlt, wobei man darauf achtet, keine Ecke zu wa&#x0308;hlen, der zu einer der bereits gewa&#x0308;hlten Ecken benachbart ist, erha&#x0308;lt man eine
unabha&#x0308;ngige Menge \(I\) mit \(I \subset S\). Man wa&#x0308;hlt dabei mindestens jede zwo&#x0308;lfte Ecke, da zu einer Ecke ho&#x0308;chstens \(11\) Ecken benachbart sind. Daher gilt \(|I| \ge \frac
{|S|}{12} \ge \frac {n}{24}\). &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Konstruktion der <span class="textsc" >Kirkpatrick</span>-Hierarchie</b>: Die <em><span class="dashuline" ><span class="textsc" >Kirkpatrick</span>-Hierarchie</span></em> ist eine Folge \(T_0, \dotsc ,
T_h\) von Triangulierungen mit \(h \in \natural _0\) und wird wie folgt konstruiert.
</p>
<ul style="list-style-type:none">

<li class="list-item-f19"><p>Sei \(T_0 := T\) mit \(T\) der urspru&#x0308;nglichen Triangulierung von \(\P \).
</p>
</li>
<li class="list-item-f20"><p>\(T_{i+1}\) erha&#x0308;lt man aus \(T_i\), indem man gema&#x0308;ß dem Lemma eine unabha&#x0308;ngige Menge \(I\) von Knoten aus \(T_i\) findet mit \(|I| \ge \frac {n_i}{24}\) und \(\forall
_{x \in I}\; \deg (x) \le 11\) (mit \(n_i\) der Knotenzahl von \(T_i\)). Anschließend entferne die Knoten von \(I\) aus \(T_i\) und trianguliere die so entstandenen „Lo&#x0308;cher“ neu, um \(T_{i+1}\) zu erhalten.
</p>
</li>
<li class="list-item-f21"><p>Ho&#x0308;re auf, sobald \(n_i\) eine konstante Gro&#x0308;ße erreicht hat.
</p>
</li>
</ul>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Beantwortung einer Anfrage \(q \in \real ^2\)</b>:
</p>
<ul style="list-style-type:none">

<li class="list-item-f22"><p>Lokalisiere \(q\) in \(T_h\).
</p>
</li>
<li class="list-item-f23"><p>Bestimmung der Position in \(T_i\) aus der Position in \(T_{i+1}\), indem die \(\O (1)\) (hier ho&#x0308;chstens elf) Dreiecke untersucht werden, die zu dem Loch geho&#x0308;ren, in dem sich \(q\) in
\(T_{i+1}\) befindet.
</p>
</li>
</ul>

<p>
<b>Zeitaufwand fu&#x0308;r Abfrage</b>: \(\O (\log n)\)
</p>

<p>
<b>Beweis</b>: Es gilt \(h = \O (\log n)\), da \(n_i \le n (\frac {23}{24})^i\). Ho&#x0308;rt man auf, wenn \(n_i &lt; c\) gilt, dann ho&#x0308;rt man spa&#x0308;testens im \(j\)-ten Schritt auf mit \(n (\frac
{23}{24})^j &lt; c\), d.&#x202f;h. \(h \le j &lt; \log _{23/24} \frac {c}{n} = \frac {\log (c/n)}{\log (23/24)}\)<br />
\(= \frac {1}{\log (23/24)} (\log c - \log n) = \O (\log n)\).
</p>

<p>
Jeder Lokalisierungsschritt in obigem Algorithmus kostet \(\O (1)\) Zeit, da immer nur \(\O (1)\) Dreiecke untersucht werden mu&#x0308;ssen. Damit ist der Gesamt-Zeitaufwand \(\O (\log h)\). &#x2003;&#x2003;
</p>

<p>
<b>Platzaufwand</b>: \(\O (n)\)
</p>

<p>
<b>Beweis</b>: Aus \(n_i \le n (\frac {23}{24})^i\) folgt fu&#x0308;r den Platzbedarf \(\sum _{i=0}^{h} n_i \le n \frac {1 - (23/24)^{h+1}}{1 - 23/24} = \O (n (\frac {23}{24})^h)\). Wegen \((\frac
{23}{24})^h \le 1\) erha&#x0308;lt man einen Platzbedarf von \(\O (n (\frac {23}{24})^h) = \O (n)\). &#x2003;&#x2003;
</p>



<h3 id="anwendung-von-polygontriangulierung-sichtbarkeitsprobleme">Anwendung von Polygontriangulierung: Sichtbarkeitsprobleme</h3>

</p>


<p>
<b>Museumswa&#x0308;chterproblem</b>: Gegeben sei ein Museum als ein einfaches Polygon mit \(n\) Ecken. Gesucht ist die minimale Anzahl von omnidirektionalen Wa&#x0308;chtern, sodass das Museum
vollsta&#x0308;ndig u&#x0308;berwacht wird.
</p>

<p>
<b>Lemma</b>: Jedes einfache Polygon mit \(n\) Ecken kann mit \(\left \lfloor \frac {n}{3} \right \rfloor \) Wa&#x0308;chtern u&#x0308;berwacht werden.
</p>

<p>
<b>Beweis</b>: Zuerst konstruiere man eine Triangulierung des Polygons. Dann ist der <em><span class="dashuline" >duale Graph</span></em> (Dreiecke als Knoten, Kanten zwischen benachbarten Dreiecken) ein Baum, da er
zusammenha&#x0308;ngend und kreisfrei ist (ga&#x0308;be es einen Kreis, ha&#x0308;tte das Polygon ein Loch).
</p>

<p>
Anschließend berechne eine \(3\)-Fa&#x0308;rbung der Ecken der Triangulierung, d.&#x202f;h. jede Ecke bekommt eine Farbe \(\text {r}, \text {g}, \text {b}\) zugewiesen, wobei zwei benachbarte Ecken jeweils
verschiedene Farben haben mu&#x0308;ssen. Das geht wie folgt:
</p>
<ul style="list-style-type:none">

<li class="list-item-f24"><p>Wa&#x0308;hle ein beliebiges Dreieck und fa&#x0308;rbe die Ecken in den drei Farben.
</p>
</li>
<li class="list-item-f25"><p>Wa&#x0308;hle ein Dreieck, von dem zwei Ecken bereits gefa&#x0308;rbt sind, und fa&#x0308;rbe die dritte Ecke entsprechend.
</p>
</li>
<li class="list-item-f26"><p>Wiederhole <em>(2)</em>, bis alle Dreiecke gefa&#x0308;rbt sind.
</p>
</li>
</ul>

<p>
Das ist mo&#x0308;glich, weil der duale Graph ein Baum ist: Ga&#x0308;be es zwei benachbarte Ecken mit derselben Farbe, dann ga&#x0308;be es einen Kreis im Baum, ein Widerspruch.
</p>

<p>
Schließlich platziert man Wa&#x0308;chter an den Ecken mit der Farbe, die am seltensten vorkommt. Das sind \(\le \left \lfloor \frac {n}{3} \right \rfloor \)-viele und die Wa&#x0308;chter u&#x0308;berwachen
jedes Dreieck, damit auch das gesamte Polygon. &#x2003;&#x2003;
</p>

<p>
<b>Lemma</b>: Es gibt einfache Polygone mit \(n\) Ecken, die \(\left \lfloor \frac {n}{3} \right \rfloor \) Wa&#x0308;chter beno&#x0308;tigen.
</p>

<p>
<b>Beweis</b>: Stellt man sich einen Kamm vor, der einen schmalen Gang und \(k\) lange Zacken besitzt, so beno&#x0308;tigt jede Zacke einen eigenen Wa&#x0308;chter. Das zugeho&#x0308;rige Polygon hat \(n = 3k\) Ecken,
fu&#x0308;r \(n \equiv _3 1\) bzw. \(n \equiv _3 2\) fu&#x0308;gt man noch 1 bzw. 2 Ecken hinzu, ohne die Struktur zu vera&#x0308;ndern. &#x2003;&#x2003;
</p>



<h3 id="zusatz-polygontriangulierung-in-erwartet-on-log-n">Zusatz: Polygontriangulierung in erwartet O(n log* n)</h3>

</p>


<p>
Im Folgenden wird gezeigt, wie man ein einfaches Polygon mit \(n\) Ecken in Zeit \(\O (n \log ^\ast n)\) trapezieren kann. Daraus folgt dann automatisch, dass ein solches Polygon in Zeit \(\O (n \log ^\ast n)\) trianguliert
werden kann.
</p>

<p>
<b>Idee</b>: Man kann nicht einfach so wie vorher trapezieren, da dies die Endpunkte nebenbei sortiert und Sortierung \(\Omega (n \log n)\) Zeit kostet. Die Idee ist nun, die Trapezierung zu berechnen und nebenbei eine
Datenstruktur zur Punktlokalisierung (fu&#x0308;r die Endpunkte der noch einzufu&#x0308;genden Strecken) in der aktuellen Trapezierung aufzubauen.
</p>

<p>
<b>Datenstruktur</b>: Die Datenstruktur zur Punktlokalisierung ist in jedem Schritt ein gerichteter Graph ohne Zykeln. Sie sieht bauma&#x0308;hnlich aus und besteht aus Knoten der folgenden Arten:
</p>
<ul style="list-style-type:none">

<li class="list-item-f27"><p><em>Trapeze</em>: stellen die Bla&#x0308;tter dar (Knoten mit Ausgangsgrad \(0\))
</p>
</li>
<li class="list-item-f28"><p><em>\(X\)-Knoten</em>: enthalten einen Punkt, stellen eine Unterteilung in zwei Ha&#x0308;lften (mit geraden Ra&#x0308;ndern) dar, gema&#x0308;ß der \(x\)-Koordinate des Knotenpunkts
</p>
</li>
<li class="list-item-f29"><p><em>\(Y\)-Knoten</em>: enthalten eine Strecke stellen eine Unterteilung in zwei Ha&#x0308;lften (mit schiefem Rand) dar, gema&#x0308;ß der Knotenstrecke
</p>
</li>
</ul>

<p>
Der Graph ist i.&#x202f;A. kein Baum, da es Knoten mit Eingangsgrad \(&gt; 1\) geben kann.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Lemma</b>: Seien \(\tau _i, Q_i\) die Trapezierungen bzw. Suchstrukturen, die durch die Einfu&#x0308;gung von \(s_i\) in \(\tau _{i-1}, Q_{i-1}\) entstehen. Ist \(q\) in \(\tau _{i-1}, Q_{i-1}\) lokalisiert
worden, dann ist \(\O (\frac {1}{i})\) der erwartete Aufwand, \(q\) in \(\tau _i, Q_i\) zu lokalisieren.
</p>

<p>
<b>Beweis</b>: Es gibt zwei verschiedene Fa&#x0308;lle.
</p>
<ul style="list-style-type:none">

<li class="list-item-f30"><p>Ist das Trapez, das \(q\) entha&#x0308;lt, identisch in \(\tau _i\) und \(\tau _{i-1}\), dann ist der Aufwand, \(q\) in \(\tau _i\) zu lokalisieren, gleich \(0\).
</p>
</li>
<li class="list-item-f31"><p>Ansonsten ist der Aufwand \(\O (1)\). Dieser Fall tritt mit Wahrscheinlichkeit \(\O (\frac {1}{i})\) ein, da \(s_i\) einer der Grenzen des Trapezes in \(\tau _i\) definieren muss.
</p>
</li>
</ul>

<p>
Daraus ergibt sich ein erwarteter Aufwand von \(\O (\frac {1}{i}) \cdot \O (1) + \O (1 - \frac {1}{i}) \cdot 0 = \O (\frac {1}{i})\). &#x2003;&#x2003;
</p>

<p>
<b>Korollar</b>: Ein Punkt \(q\) kann in \(\tau _i\) in erwartet \(\O (\log i)\) lokalisiert werden (von der Wurzel aus).
</p>

<p>
<b>Beweis</b>: Zuna&#x0308;chst lokalisiert man \(q\) in \(\tau _0\), anschließend induktiv in \(\tau _j\) (ausgehend von \(\tau _{j-1}\)). Das kostet nach dem Lemma insgesamt erwartet \(\sum _{j=1}^i \O (\frac
{1}{j}) = \O (\log i)\). &#x2003;&#x2003;
</p>

<p>
<b>Theorem</b>: Seien \(S\) eine Menge von \(n\) sich nicht schneidenden Strecken (außer ggf. in den Endpunkten) und \(\T (S), Q(S)\) die zu \(S\) geho&#x0308;rige Trapezierung bzw. Suchstruktur. Dann ko&#x0308;nnen
\(\T (S), Q(S)\) in erwartet \(\O (n \log n)\) konstruiert werden. \(Q(S)\) hat dabei die Gro&#x0308;ße \(\O (n)\). Die erwartete Zeit zur Lokalisierung von \(q \in \real ^2\) in \(\T (S), Q(S)\) betra&#x0308;gt \(\O
(\log n)\).
</p>

<p>
<b>Beweis</b>: Der Aufwand zur Konstruktion von \(\T (S), Q(s)\) ist der Aufwand fu&#x0308;r die Aktualisierung der Trapezierung und der Suchstruktur und der Aufwand zur Punktlokalisierung. Weil der erste Aufwand bei
Einfu&#x0308;gung eines Segments erwartet \(\O (1)\) betra&#x0308;gt und die Punktlokalisierung in \(\O (\log i)\) durchgefu&#x0308;hrt werden kann, ist der Gesamtaufwand \(\sum _{i=1}^n \O (\log i) = \O (n
\log n)\). &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Algorithmus zur Polygontriangulierung in erwartet \(\O (n \log ^\ast n)\)</b>:
</p>
<ul style="list-style-type:none">

<li class="list-item-f32"><p>  Bringe die Strecken in eine zufa&#x0308;llige Reihenfolge.
</p>
</li>
<li class="list-item-f33"><p>  Fu&#x0308;ge die ersten \(\frac {n}{\log n}\) Strecken ein.
</p>
</li>
<li class="list-item-f34"><p>  Verfolge das gesamte Polygon durch \(\T _{n/\log n}\) und bestimme dabei die Positionen aller noch nicht eingefu&#x0308;gten Strecken.
</p>
</li>
<li class="list-item-f35"><p>  Fu&#x0308;ge die na&#x0308;chsten \(\frac {n}{\log \log n}\) Strecken ein usw.
</p>
</li>
<li class="list-item-f36"><p>  Wiederhole, bis \(\log \dotsb \log n\) konstant ist (d.&#x202f;h. bis Lokalisierung in konstanter Zeit mo&#x0308;glich ist).
</p>
</li>
</ul>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Lemma</b>: Sei \(R \subset S\) eine zufa&#x0308;llige Teilmenge der Strecken mit \(r := |R|\). Dann ist die erwartete Anzahl an Schnitten zwischen Segmenten aus \(S \setminus R\) und Vertikalen von \(\T (R)\)
ho&#x0308;chstens \(4(n-r)\).
</p>

<p>
<b>Beweis</b>: Fu&#x0308;r \(T \subset S\) und \(s \in T\) sei \(\deg (s, \T (T))\) gleich der Anzahl der Vertikalen, die in \(\T (T)\) an \(s\) anstoßen. Es gilt \(\sum _{s \in T} \deg (s, \T (T)) \le 4|T|\), weil
jedes Segment zwei Endpunkte hat und von jedem Endpunkt zwei Vertikalen ausgehen (die nicht zwangsla&#x0308;ufig in \(\T (T)\) anstoßen mu&#x0308;ssen). Fu&#x0308;r \(R \subset S\) und \(s \notin R\) ist die
Anzahl der von \(s\) geschnittenen Vertikalen von \(\T (R)\) gleich \(\deg (s, \T (R \cup \{s\}))\). Damit ist die erwartete Anzahl an Schnitten zwischen Segmenten aus \(S \setminus R\) und Vertikalen von \(\T (R)\)
gleich \(\frac {1}{\binom {n}{r}} \sum _{R \subset S,\; |R| = r} \sum _{s \in S \setminus R} \deg (s, \T (R \cup \{s\}))\) (die erste Summe beru&#x0308;cksichtigt die Wahl einer zufa&#x0308;lligen
Teilmenge \(R \subset S\) mit \(|R| = r\)). Man kann dies umschreiben zu \(\frac {1}{\binom {n}{r}} \sum _{R’ \subset S,\; |R’| = r+1} \sum _{s \in R’} \deg (s, \T (R’)) \le \frac {1}{\binom {n}{r}}
\sum _{R’ \subset S;\; |R’| = r+1} 4|R’|\)<br />
\(= \frac {1}{\binom {n}{r}} \cdot \binom {n}{r+1} 4(r+1) = \frac {r!(n-r)!}{(r+1)!(n-r-1)!} \cdot 4(r+1) = 4(n-r)\). &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Zeitbedarf</b>: \(\O (n \log ^\ast n)\)
</p>

<p>
<b>Beweis</b>: Schritt <em>(2)</em> kostet erwartet \(n \log n \cdot \O (\log n) = \O (n)\) Zeit. Nach dem Lemma von eben kostet Schritt <em>(3)</em> erwartet \(\O (n)\). Fu&#x0308;r \(i \ge \frac {n}{\log n}\)
ist danach die Lokalisierung in \(\T _i\) in erwartet \(\O (\sum _{j=n/\log n}^i \frac {1}{j}) = \O (\log i - \log (\frac {n}{\log n})) = \O (\log (\log n))\) mo&#x0308;glich. &#x2003;&#x2003;
</p>

{% endraw %}
</div>
{:/nomarkdown}
