
{::nomarkdown}
<div class="lwarp-contents">
{% raw %}
<div class="hidden" >

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\mathllap }[2][]{{#1#2}}\)

\(\newcommand {\mathrlap }[2][]{{#1#2}}\)

\(\newcommand {\mathclap }[2][]{{#1#2}}\)

\(\newcommand {\mathmbox }[1]{#1}\)

\(\newcommand {\clap }[1]{#1}\)

\(\newcommand {\LWRmathmakebox }[2][]{#2}\)

\(\newcommand {\mathmakebox }[1][]{\LWRmathmakebox }\)

\(\newcommand {\cramped }[2][]{{#1#2}}\)

\(\newcommand {\crampedllap }[2][]{{#1#2}}\)

\(\newcommand {\crampedrlap }[2][]{{#1#2}}\)

\(\newcommand {\crampedclap }[2][]{{#1#2}}\)

\(\newenvironment {crampedsubarray}[1]{}{}\)

\(\newcommand {\crampedsubstack }{}\)

\(\newcommand {\smashoperator }[2][]{#2\limits }\)

\(\newcommand {\adjustlimits }{}\)

\(\newcommand {\SwapAboveDisplaySkip }{}\)

\(\require {extpfeil}\)

\(\Newextarrow \xleftrightarrow {10,10}{0x2194}\)

\(\Newextarrow \xLeftarrow {10,10}{0x21d0}\)

\(\Newextarrow \xhookleftarrow {10,10}{0x21a9}\)

\(\Newextarrow \xmapsto {10,10}{0x21a6}\)

\(\Newextarrow \xRightarrow {10,10}{0x21d2}\)

\(\Newextarrow \xLeftrightarrow {10,10}{0x21d4}\)

\(\Newextarrow \xhookrightarrow {10,10}{0x21aa}\)

\(\Newextarrow \xrightharpoondown {10,10}{0x21c1}\)

\(\Newextarrow \xleftharpoondown {10,10}{0x21bd}\)

\(\Newextarrow \xrightleftharpoons {10,10}{0x21cc}\)

\(\Newextarrow \xrightharpoonup {10,10}{0x21c0}\)

\(\Newextarrow \xleftharpoonup {10,10}{0x21bc}\)

\(\Newextarrow \xleftrightharpoons {10,10}{0x21cb}\)

\(\newcommand {\LWRdounderbracket }[3]{\underset {#3}{\underline {#1}}}\)

\(\newcommand {\LWRunderbracket }[2][]{\LWRdounderbracket {#2}}\)

\(\newcommand {\underbracket }[1][]{\LWRunderbracket }\)

\(\newcommand {\LWRdooverbracket }[3]{\overset {#3}{\overline {#1}}}\)

\(\newcommand {\LWRoverbracket }[2][]{\LWRdooverbracket {#2}}\)

\(\newcommand {\overbracket }[1][]{\LWRoverbracket }\)

\(\newcommand {\LaTeXunderbrace }[1]{\underbrace {#1}}\)

\(\newcommand {\LaTeXoverbrace }[1]{\overbrace {#1}}\)

\(\newenvironment {matrix*}[1][]{\begin {matrix}}{\end {matrix}}\)

\(\newenvironment {pmatrix*}[1][]{\begin {pmatrix}}{\end {pmatrix}}\)

\(\newenvironment {bmatrix*}[1][]{\begin {bmatrix}}{\end {bmatrix}}\)

\(\newenvironment {Bmatrix*}[1][]{\begin {Bmatrix}}{\end {Bmatrix}}\)

\(\newenvironment {vmatrix*}[1][]{\begin {vmatrix}}{\end {vmatrix}}\)

\(\newenvironment {Vmatrix*}[1][]{\begin {Vmatrix}}{\end {Vmatrix}}\)

\(\newenvironment {smallmatrix*}[1][]{\begin {matrix}}{\end {matrix}}\)

\(\newenvironment {psmallmatrix*}[1][]{\begin {pmatrix}}{\end {pmatrix}}\)

\(\newenvironment {bsmallmatrix*}[1][]{\begin {bmatrix}}{\end {bmatrix}}\)

\(\newenvironment {Bsmallmatrix*}[1][]{\begin {Bmatrix}}{\end {Bmatrix}}\)

\(\newenvironment {vsmallmatrix*}[1][]{\begin {vmatrix}}{\end {vmatrix}}\)

\(\newenvironment {Vsmallmatrix*}[1][]{\begin {Vmatrix}}{\end {Vmatrix}}\)

\(\newenvironment {psmallmatrix}[1][]{\begin {pmatrix}}{\end {pmatrix}}\)

\(\newenvironment {bsmallmatrix}[1][]{\begin {bmatrix}}{\end {bmatrix}}\)

\(\newenvironment {Bsmallmatrix}[1][]{\begin {Bmatrix}}{\end {Bmatrix}}\)

\(\newenvironment {vsmallmatrix}[1][]{\begin {vmatrix}}{\end {vmatrix}}\)

\(\newenvironment {Vsmallmatrix}[1][]{\begin {Vmatrix}}{\end {Vmatrix}}\)

\(\newcommand {\LWRmultlined }[1][]{\begin {multline*}}\)

\(\newenvironment {multlined}[1][]{\LWRmultlined }{\end {multline*}}\)

\(\let \LWRorigshoveleft \shoveleft \)

\(\renewcommand {\shoveleft }[1][]{\LWRorigshoveleft }\)

\(\let \LWRorigshoveright \shoveright \)

\(\renewcommand {\shoveright }[1][]{\LWRorigshoveright }\)

\(\newenvironment {dcases}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {dcases*}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {rcases}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {rcases*}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {drcases}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {drcases*}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {cases*}{\begin {cases}}{\end {cases}}\)

\(\newcommand {\MoveEqLeft }[1][]{}\)

\(\def \LWRAboxed #1&amp;#2&amp;#3!|!{\fbox {\(#1\)}&amp;\fbox {\(#2\)}} \newcommand {\Aboxed }[1]{\LWRAboxed #1&amp;&amp;!|!} \)

\( \newcommand {\LWRABLines }[1][\Updownarrow ]{#1 \notag \\}\newcommand {\ArrowBetweenLines }{\ifstar \LWRABLines \LWRABLines } \)

\(\newcommand {\shortintertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\vdotswithin }[1]{\hspace {.5em}\vdots }\)

\(\newcommand {\LWRshortvdotswithinstar }[1]{\vdots \hspace {.5em} &amp; \\}\)

\(\newcommand {\LWRshortvdotswithinnostar }[1]{&amp; \hspace {.5em}\vdots \\}\)

\(\newcommand {\shortvdotswithin }{\ifstar \LWRshortvdotswithinstar \LWRshortvdotswithinnostar }\)

\(\newcommand {\MTFlushSpaceAbove }{}\)

\(\newcommand {\MTFlushSpaceBelow }{\\}\)

\(\newcommand \lparen {(}\)

\(\newcommand \rparen {)}\)

\(\newcommand {\ordinarycolon }{:}\)

\(\newcommand {\vcentcolon }{\mathrel {\mathop \ordinarycolon }}\)

\(\newcommand \dblcolon {\vcentcolon \vcentcolon }\)

\(\newcommand \coloneqq {\vcentcolon =}\)

\(\newcommand \Coloneqq {\dblcolon =}\)

\(\newcommand \coloneq {\vcentcolon {-}}\)

\(\newcommand \Coloneq {\dblcolon {-}}\)

\(\newcommand \eqqcolon {=\vcentcolon }\)

\(\newcommand \Eqqcolon {=\dblcolon }\)

\(\newcommand \eqcolon {\mathrel {-}\vcentcolon }\)

\(\newcommand \Eqcolon {\mathrel {-}\dblcolon }\)

\(\newcommand \colonapprox {\vcentcolon \approx }\)

\(\newcommand \Colonapprox {\dblcolon \approx }\)

\(\newcommand \colonsim {\vcentcolon \sim }\)

\(\newcommand \Colonsim {\dblcolon \sim }\)

\(\newcommand {\nuparrow }{\mathrel {\cancel {\uparrow }}}\)

\(\newcommand {\ndownarrow }{\mathrel {\cancel {\downarrow }}}\)

\(\newcommand {\bigtimes }{\mathop {\Large \times }\limits }\)

\(\newcommand {\prescript }[3]{{}^{#1}_{#2}#3}\)

\(\newenvironment {lgathered}{\begin {gathered}}{\end {gathered}}\)

\(\newenvironment {rgathered}{\begin {gathered}}{\end {gathered}}\)

\(\newcommand {\splitfrac }[2]{{}^{#1}_{#2}}\)

\(\let \splitdfrac \splitfrac \)

\(\newcommand {\LWRoverlaysymbols }[2]{\mathord {\smash {\mathop {#2\strut }\limits ^{\smash {\lower 3ex{#1}}}}\strut }}\)

\(\newcommand{\alphaup}{\unicode{x03B1}}\)

\(\newcommand{\betaup}{\unicode{x03B2}}\)

\(\newcommand{\gammaup}{\unicode{x03B3}}\)

\(\newcommand{\digammaup}{\unicode{x03DD}}\)

\(\newcommand{\deltaup}{\unicode{x03B4}}\)

\(\newcommand{\epsilonup}{\unicode{x03F5}}\)

\(\newcommand{\varepsilonup}{\unicode{x03B5}}\)

\(\newcommand{\zetaup}{\unicode{x03B6}}\)

\(\newcommand{\etaup}{\unicode{x03B7}}\)

\(\newcommand{\thetaup}{\unicode{x03B8}}\)

\(\newcommand{\varthetaup}{\unicode{x03D1}}\)

\(\newcommand{\iotaup}{\unicode{x03B9}}\)

\(\newcommand{\kappaup}{\unicode{x03BA}}\)

\(\newcommand{\varkappaup}{\unicode{x03F0}}\)

\(\newcommand{\lambdaup}{\unicode{x03BB}}\)

\(\newcommand{\muup}{\unicode{x03BC}}\)

\(\newcommand{\nuup}{\unicode{x03BD}}\)

\(\newcommand{\xiup}{\unicode{x03BE}}\)

\(\newcommand{\omicronup}{\unicode{x03BF}}\)

\(\newcommand{\piup}{\unicode{x03C0}}\)

\(\newcommand{\varpiup}{\unicode{x03D6}}\)

\(\newcommand{\rhoup}{\unicode{x03C1}}\)

\(\newcommand{\varrhoup}{\unicode{x03F1}}\)

\(\newcommand{\sigmaup}{\unicode{x03C3}}\)

\(\newcommand{\varsigmaup}{\unicode{x03C2}}\)

\(\newcommand{\tauup}{\unicode{x03C4}}\)

\(\newcommand{\upsilonup}{\unicode{x03C5}}\)

\(\newcommand{\phiup}{\unicode{x03D5}}\)

\(\newcommand{\varphiup}{\unicode{x03C6}}\)

\(\newcommand{\chiup}{\unicode{x03C7}}\)

\(\newcommand{\psiup}{\unicode{x03C8}}\)

\(\newcommand{\omegaup}{\unicode{x03C9}}\)

\(\newcommand{\Alphaup}{\unicode{x0391}}\)

\(\newcommand{\Betaup}{\unicode{x0392}}\)

\(\newcommand{\Gammaup}{\unicode{x0393}}\)

\(\newcommand{\Digammaup}{\unicode{x03DC}}\)

\(\newcommand{\Deltaup}{\unicode{x0394}}\)

\(\newcommand{\Epsilonup}{\unicode{x0395}}\)

\(\newcommand{\Zetaup}{\unicode{x0396}}\)

\(\newcommand{\Etaup}{\unicode{x0397}}\)

\(\newcommand{\Thetaup}{\unicode{x0398}}\)

\(\newcommand{\Varthetaup}{\unicode{x03F4}}\)

\(\newcommand{\Iotaup}{\unicode{x0399}}\)

\(\newcommand{\Kappaup}{\unicode{x039A}}\)

\(\newcommand{\Lambdaup}{\unicode{x039B}}\)

\(\newcommand{\Muup}{\unicode{x039C}}\)

\(\newcommand{\Nuup}{\unicode{x039D}}\)

\(\newcommand{\Xiup}{\unicode{x039E}}\)

\(\newcommand{\Omicronup}{\unicode{x039F}}\)

\(\newcommand{\Piup}{\unicode{x03A0}}\)

\(\newcommand{\Varpiup}{\unicode{x03D6}}\)

\(\newcommand{\Rhoup}{\unicode{x03A1}}\)

\(\newcommand{\Sigmaup}{\unicode{x03A3}}\)

\(\newcommand{\Tauup}{\unicode{x03A4}}\)

\(\newcommand{\Upsilonup}{\unicode{x03A5}}\)

\(\newcommand{\Phiup}{\unicode{x03A6}}\)

\(\newcommand{\Chiup}{\unicode{x03A7}}\)

\(\newcommand{\Psiup}{\unicode{x03A8}}\)

\(\newcommand{\Omegaup}{\unicode{x03A9}}\)

\(\newcommand{\alphait}{\unicode{x1D6FC}}\)

\(\newcommand{\betait}{\unicode{x1D6FD}}\)

\(\newcommand{\gammait}{\unicode{x1D6FE}}\)

\(\newcommand{\digammait}{\mathit{\unicode{x03DD}}}\)

\(\newcommand{\deltait}{\unicode{x1D6FF}}\)

\(\newcommand{\epsilonit}{\unicode{x1D716}}\)

\(\newcommand{\varepsilonit}{\unicode{x1D700}}\)

\(\newcommand{\zetait}{\unicode{x1D701}}\)

\(\newcommand{\etait}{\unicode{x1D702}}\)

\(\newcommand{\thetait}{\unicode{x1D703}}\)

\(\newcommand{\varthetait}{\unicode{x1D717}}\)

\(\newcommand{\iotait}{\unicode{x1D704}}\)

\(\newcommand{\kappait}{\unicode{x1D705}}\)

\(\newcommand{\varkappait}{\unicode{x1D718}}\)

\(\newcommand{\lambdait}{\unicode{x1D706}}\)

\(\newcommand{\muit}{\unicode{x1D707}}\)

\(\newcommand{\nuit}{\unicode{x1D708}}\)

\(\newcommand{\xiit}{\unicode{x1D709}}\)

\(\newcommand{\omicronit}{\unicode{x1D70A}}\)

\(\newcommand{\piit}{\unicode{x1D70B}}\)

\(\newcommand{\varpiit}{\unicode{x1D71B}}\)

\(\newcommand{\rhoit}{\unicode{x1D70C}}\)

\(\newcommand{\varrhoit}{\unicode{x1D71A}}\)

\(\newcommand{\sigmait}{\unicode{x1D70E}}\)

\(\newcommand{\varsigmait}{\unicode{x1D70D}}\)

\(\newcommand{\tauit}{\unicode{x1D70F}}\)

\(\newcommand{\upsilonit}{\unicode{x1D710}}\)

\(\newcommand{\phiit}{\unicode{x1D719}}\)

\(\newcommand{\varphiit}{\unicode{x1D711}}\)

\(\newcommand{\chiit}{\unicode{x1D712}}\)

\(\newcommand{\psiit}{\unicode{x1D713}}\)

\(\newcommand{\omegait}{\unicode{x1D714}}\)

\(\newcommand{\Alphait}{\unicode{x1D6E2}}\)

\(\newcommand{\Betait}{\unicode{x1D6E3}}\)

\(\newcommand{\Gammait}{\unicode{x1D6E4}}\)

\(\newcommand{\Digammait}{\mathit{\unicode{x03DC}}}\)

\(\newcommand{\Deltait}{\unicode{x1D6E5}}\)

\(\newcommand{\Epsilonit}{\unicode{x1D6E6}}\)

\(\newcommand{\Zetait}{\unicode{x1D6E7}}\)

\(\newcommand{\Etait}{\unicode{x1D6E8}}\)

\(\newcommand{\Thetait}{\unicode{x1D6E9}}\)

\(\newcommand{\Varthetait}{\unicode{x1D6F3}}\)

\(\newcommand{\Iotait}{\unicode{x1D6EA}}\)

\(\newcommand{\Kappait}{\unicode{x1D6EB}}\)

\(\newcommand{\Lambdait}{\unicode{x1D6EC}}\)

\(\newcommand{\Muit}{\unicode{x1D6ED}}\)

\(\newcommand{\Nuit}{\unicode{x1D6EE}}\)

\(\newcommand{\Xiit}{\unicode{x1D6EF}}\)

\(\newcommand{\Omicronit}{\unicode{x1D6F0}}\)

\(\newcommand{\Piit}{\unicode{x1D6F1}}\)

\(\newcommand{\Rhoit}{\unicode{x1D6F2}}\)

\(\newcommand{\Sigmait}{\unicode{x1D6F4}}\)

\(\newcommand{\Tauit}{\unicode{x1D6F5}}\)

\(\newcommand{\Upsilonit}{\unicode{x1D6F6}}\)

\(\newcommand{\Phiit}{\unicode{x1D6F7}}\)

\(\newcommand{\Chiit}{\unicode{x1D6F8}}\)

\(\newcommand{\Psiit}{\unicode{x1D6F9}}\)

\(\newcommand{\Omegait}{\unicode{x1D6FA}}\)

\(\let \digammaup \Digammaup \)

\(\renewcommand {\digammait }{\mathit {\digammaup }}\)

\(\newcommand {\smallin }{\unicode {x220A}}\)

\(\newcommand {\smallowns }{\unicode {x220D}}\)

\(\newcommand {\notsmallin }{\LWRoverlaysymbols {/}{\unicode {x220A}}}\)

\(\newcommand {\notsmallowns }{\LWRoverlaysymbols {/}{\unicode {x220D}}}\)

\(\newcommand {\rightangle }{\unicode {x221F}}\)

\(\newcommand {\intclockwise }{\unicode {x2231}}\)

\(\newcommand {\ointclockwise }{\unicode {x2232}}\)

\(\newcommand {\ointctrclockwise }{\unicode {x2233}}\)

\(\newcommand {\oiint }{\unicode {x222F}}\)

\(\newcommand {\oiiint }{\unicode {x2230}}\)

\(\newcommand {\ddag }{\unicode {x2021}}\)

\(\newcommand {\P }{\unicode {x00B6}}\)

\(\newcommand {\copyright }{\unicode {x00A9}}\)

\(\newcommand {\dag }{\unicode {x2020}}\)

\(\newcommand {\pounds }{\unicode {x00A3}}\)

\(\newcommand {\iddots }{\unicode {x22F0}}\)

\(\newcommand {\utimes }{\overline {\times }}\)

\(\newcommand {\dtimes }{\underline {\times }}\)

\(\newcommand {\udtimes }{\overline {\underline {\times }}}\)

\(\newcommand {\leftwave }{\left \{}\)

\(\newcommand {\rightwave }{\right \}}\)

\(\newcommand {\toprule }[1][]{\hline }\)

\(\let \midrule \toprule \)

\(\let \bottomrule \toprule \)

\(\newcommand {\cmidrule }[2][]{}\)

\(\newcommand {\morecmidrules }{}\)

\(\newcommand {\specialrule }[3]{\hline }\)

\(\newcommand {\addlinespace }[1][]{}\)

\(\newcommand {\LWRsubmultirow }[2][]{#2}\)

\(\newcommand {\LWRmultirow }[2][]{\LWRsubmultirow }\)

\(\newcommand {\multirow }[2][]{\LWRmultirow }\)

\(\newcommand {\mrowcell }{}\)

\(\newcommand {\mcolrowcell }{}\)

\(\newcommand {\STneed }[1]{}\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\newcommand {\tothe }[1]{^{#1}}\)

\(\newcommand {\raiseto }[2]{{#2}^{#1}}\)

\(\newcommand {\ang }[2][]{(\mathrm {#2})\degree }\)

\(\newcommand {\num }[2][]{\mathrm {#2}}\)

\(\newcommand {\si }[2][]{\mathrm {#2}}\)

\(\newcommand {\LWRSI }[2][]{\mathrm {#1\LWRSInumber \,#2}}\)

\(\newcommand {\SI }[2][]{\def \LWRSInumber {#2}\LWRSI }\)

\(\newcommand {\numlist }[2][]{\mathrm {#2}}\)

\(\newcommand {\numrange }[3][]{\mathrm {#2\,\unicode {x2013}\,#3}}\)

\(\newcommand {\SIlist }[3][]{\mathrm {#2\,#3}}\)

\(\newcommand {\SIrange }[4][]{\mathrm {#2\,#4\,\unicode {x2013}\,#3\,#4}}\)

\(\newcommand {\tablenum }[2][]{\mathrm {#2}}\)

\(\newcommand {\ampere }{\mathrm {A}}\)

\(\newcommand {\candela }{\mathrm {cd}}\)

\(\newcommand {\kelvin }{\mathrm {K}}\)

\(\newcommand {\kilogram }{\mathrm {kg}}\)

\(\newcommand {\metre }{\mathrm {m}}\)

\(\newcommand {\mole }{\mathrm {mol}}\)

\(\newcommand {\second }{\mathrm {s}}\)

\(\newcommand {\becquerel }{\mathrm {Bq}}\)

\(\newcommand {\degreeCelsius }{\unicode {x2103}}\)

\(\newcommand {\coulomb }{\mathrm {C}}\)

\(\newcommand {\farad }{\mathrm {F}}\)

\(\newcommand {\gray }{\mathrm {Gy}}\)

\(\newcommand {\hertz }{\mathrm {Hz}}\)

\(\newcommand {\henry }{\mathrm {H}}\)

\(\newcommand {\joule }{\mathrm {J}}\)

\(\newcommand {\katal }{\mathrm {kat}}\)

\(\newcommand {\lumen }{\mathrm {lm}}\)

\(\newcommand {\lux }{\mathrm {lx}}\)

\(\newcommand {\newton }{\mathrm {N}}\)

\(\newcommand {\ohm }{\mathrm {\Omega }}\)

\(\newcommand {\pascal }{\mathrm {Pa}}\)

\(\newcommand {\radian }{\mathrm {rad}}\)

\(\newcommand {\siemens }{\mathrm {S}}\)

\(\newcommand {\sievert }{\mathrm {Sv}}\)

\(\newcommand {\steradian }{\mathrm {sr}}\)

\(\newcommand {\tesla }{\mathrm {T}}\)

\(\newcommand {\volt }{\mathrm {V}}\)

\(\newcommand {\watt }{\mathrm {W}}\)

\(\newcommand {\weber }{\mathrm {Wb}}\)

\(\newcommand {\day }{\mathrm {d}}\)

\(\newcommand {\degree }{\mathrm {^\circ }}\)

\(\newcommand {\hectare }{\mathrm {ha}}\)

\(\newcommand {\hour }{\mathrm {h}}\)

\(\newcommand {\litre }{\mathrm {l}}\)

\(\newcommand {\liter }{\mathrm {L}}\)

\(\newcommand {\arcminute }{^\prime }\)
\(\newcommand {\minute }{\mathrm {min}}\)

\(\newcommand {\arcsecond }{^{\prime \prime }}\)

\(\newcommand {\tonne }{\mathrm {t}}\)

\(\newcommand {\astronomicalunit }{au}\)

\(\newcommand {\atomicmassunit }{u}\)

\(\newcommand {\bohr }{\mathit {a}_0}\)

\(\newcommand {\clight }{\mathit {c}_0}\)

\(\newcommand {\dalton }{\mathrm {D}_\mathrm {a}}\)

\(\newcommand {\electronmass }{\mathit {m}_{\mathrm {e}}}\)

\(\newcommand {\electronvolt }{\mathrm {eV}}\)

\(\newcommand {\elementarycharge }{\mathit {e}}\)

\(\newcommand {\hartree }{\mathit {E}_{\mathrm {h}}}\)

\(\newcommand {\planckbar }{\mathit {\unicode {x210F}}}\)

\(\newcommand {\angstrom }{\mathrm {\unicode {x212B}}}\)

\(\let \LWRorigbar \bar \)

\(\newcommand {\bar }{\mathrm {bar}}\)

\(\newcommand {\barn }{\mathrm {b}}\)

\(\newcommand {\bel }{\mathrm {B}}\)

\(\newcommand {\decibel }{\mathrm {dB}}\)

\(\newcommand {\knot }{\mathrm {kn}}\)

\(\newcommand {\mmHg }{\mathrm {mmHg}}\)

\(\newcommand {\nauticalmile }{\mathrm {M}}\)

\(\newcommand {\neper }{\mathrm {Np}}\)

\(\newcommand {\yocto }{\mathrm {y}}\)

\(\newcommand {\zepto }{\mathrm {z}}\)

\(\newcommand {\atto }{\mathrm {a}}\)

\(\newcommand {\femto }{\mathrm {f}}\)

\(\newcommand {\pico }{\mathrm {p}}\)

\(\newcommand {\nano }{\mathrm {n}}\)

\(\newcommand {\micro }{\mathrm {\unicode {x00B5}}}\)

\(\newcommand {\milli }{\mathrm {m}}\)

\(\newcommand {\centi }{\mathrm {c}}\)

\(\newcommand {\deci }{\mathrm {d}}\)

\(\newcommand {\deca }{\mathrm {da}}\)

\(\newcommand {\hecto }{\mathrm {h}}\)

\(\newcommand {\kilo }{\mathrm {k}}\)

\(\newcommand {\mega }{\mathrm {M}}\)

\(\newcommand {\giga }{\mathrm {G}}\)

\(\newcommand {\tera }{\mathrm {T}}\)

\(\newcommand {\peta }{\mathrm {P}}\)

\(\newcommand {\exa }{\mathrm {E}}\)

\(\newcommand {\zetta }{\mathrm {Z}}\)

\(\newcommand {\yotta }{\mathrm {Y}}\)

\(\newcommand {\percent }{\mathrm {\%}}\)

\(\newcommand {\meter }{\mathrm {m}}\)

\(\newcommand {\metre }{\mathrm {m}}\)

\(\newcommand {\gram }{\mathrm {g}}\)

\(\newcommand {\kg }{\kilo \gram }\)

\(\newcommand {\of }[1]{_{\mathrm {#1}}}\)

\(\newcommand {\squared }{^2}\)

\(\newcommand {\square }[1]{\mathrm {#1}^2}\)

\(\newcommand {\cubed }{^3}\)

\(\newcommand {\cubic }[1]{\mathrm {#1}^3}\)

\(\newcommand {\per }{/}\)

\(\newcommand {\celsius }{\unicode {x2103}}\)

\(\newcommand {\fg }{\femto \gram }\)

\(\newcommand {\pg }{\pico \gram }\)

\(\newcommand {\ng }{\nano \gram }\)

\(\newcommand {\ug }{\micro \gram }\)

\(\newcommand {\mg }{\milli \gram }\)

\(\newcommand {\g }{\gram }\)

\(\newcommand {\kg }{\kilo \gram }\)

\(\newcommand {\amu }{\mathrm {u}}\)

\(\newcommand {\nm }{\nano \metre }\)

\(\newcommand {\um }{\micro \metre }\)

\(\newcommand {\mm }{\milli \metre }\)

\(\newcommand {\cm }{\centi \metre }\)

\(\newcommand {\dm }{\deci \metre }\)

\(\newcommand {\m }{\metre }\)

\(\newcommand {\km }{\kilo \metre }\)

\(\newcommand {\as }{\atto \second }\)

\(\newcommand {\fs }{\femto \second }\)

\(\newcommand {\ps }{\pico \second }\)

\(\newcommand {\ns }{\nano \second }\)

\(\newcommand {\us }{\micro \second }\)

\(\newcommand {\ms }{\milli \second }\)

\(\newcommand {\s }{\second }\)

\(\newcommand {\fmol }{\femto \mol }\)

\(\newcommand {\pmol }{\pico \mol }\)

\(\newcommand {\nmol }{\nano \mol }\)

\(\newcommand {\umol }{\micro \mol }\)

\(\newcommand {\mmol }{\milli \mol }\)

\(\newcommand {\mol }{\mol }\)

\(\newcommand {\kmol }{\kilo \mol }\)

\(\newcommand {\pA }{\pico \ampere }\)

\(\newcommand {\nA }{\nano \ampere }\)

\(\newcommand {\uA }{\micro \ampere }\)

\(\newcommand {\mA }{\milli \ampere }\)

\(\newcommand {\A }{\ampere }\)

\(\newcommand {\kA }{\kilo \ampere }\)

\(\newcommand {\ul }{\micro \litre }\)

\(\newcommand {\ml }{\milli \litre }\)

\(\newcommand {\l }{\litre }\)

\(\newcommand {\hl }{\hecto \litre }\)

\(\newcommand {\uL }{\micro \liter }\)

\(\newcommand {\mL }{\milli \liter }\)

\(\newcommand {\L }{\liter }\)

\(\newcommand {\hL }{\hecto \liter }\)

\(\newcommand {\mHz }{\milli \hertz }\)

\(\newcommand {\Hz }{\hertz }\)

\(\newcommand {\kHz }{\kilo \hertz }\)

\(\newcommand {\MHz }{\mega \hertz }\)

\(\newcommand {\GHz }{\giga \hertz }\)

\(\newcommand {\THz }{\tera \hertz }\)

\(\newcommand {\mN }{\milli \newton }\)

\(\newcommand {\N }{\newton }\)

\(\newcommand {\kN }{\kilo \newton }\)

\(\newcommand {\MN }{\mega \newton }\)

\(\newcommand {\Pa }{\pascal }\)

\(\newcommand {\kPa }{\kilo \pascal }\)

\(\newcommand {\MPa }{\mega \pascal }\)

\(\newcommand {\GPa }{\giga \pascal }\)

\(\newcommand {\mohm }{\milli \ohm }\)

\(\newcommand {\kohm }{\kilo \ohm }\)

\(\newcommand {\Mohm }{\mega \ohm }\)

\(\newcommand {\pV }{\pico \volt }\)

\(\newcommand {\nV }{\nano \volt }\)

\(\newcommand {\uV }{\micro \volt }\)

\(\newcommand {\mV }{\milli \volt }\)

\(\newcommand {\V }{\volt }\)

\(\newcommand {\kV }{\kilo \volt }\)

\(\newcommand {\W }{\watt }\)

\(\newcommand {\uW }{\micro \watt }\)

\(\newcommand {\mW }{\milli \watt }\)

\(\newcommand {\kW }{\kilo \watt }\)

\(\newcommand {\MW }{\mega \watt }\)

\(\newcommand {\GW }{\giga \watt }\)

\(\newcommand {\J }{\joule }\)

\(\newcommand {\uJ }{\micro \joule }\)

\(\newcommand {\mJ }{\milli \joule }\)

\(\newcommand {\kJ }{\kilo \joule }\)

\(\newcommand {\eV }{\electronvolt }\)

\(\newcommand {\meV }{\milli \electronvolt }\)

\(\newcommand {\keV }{\kilo \electronvolt }\)

\(\newcommand {\MeV }{\mega \electronvolt }\)

\(\newcommand {\GeV }{\giga \electronvolt }\)

\(\newcommand {\TeV }{\tera \electronvolt }\)

\(\newcommand {\kWh }{\kilo \watt \hour }\)

\(\newcommand {\F }{\farad }\)

\(\newcommand {\fF }{\femto \farad }\)

\(\newcommand {\pF }{\pico \farad }\)

\(\newcommand {\K }{\mathrm {K}}\)

\(\newcommand {\dB }{\mathrm {dB}}\)

\(\newcommand {\kibi }{\mathrm {Ki}}\)

\(\newcommand {\mebi }{\mathrm {Mi}}\)

\(\newcommand {\gibi }{\mathrm {Gi}}\)

\(\newcommand {\tebi }{\mathrm {Ti}}\)

\(\newcommand {\pebi }{\mathrm {Pi}}\)

\(\newcommand {\exbi }{\mathrm {Ei}}\)

\(\newcommand {\zebi }{\mathrm {Zi}}\)

\(\newcommand {\yobi }{\mathrm {Yi}}\)

\(\require {mhchem}\)

\(\require {cancel}\)

\(\newcommand {\fint }{âĺŊ}\)

\(\newcommand {\hdots }{\cdots }\)

\(\newcommand {\mathnormal }[1]{#1}\)

\(\newcommand {\vecs }[2]{\vec {#1}_{#2}}\)

\(\newcommand {\EE }{\mathbb {E}}\)

\(\newcommand {\PP }{\mathbb {P}}\)

\(\renewcommand {\C }{\mathcal {C}}\)

\(\renewcommand {\O }{\mathcal {O}}\)

\(\renewcommand {\P }{\mathcal {P}}\)

\(\renewcommand {\S }{\mathcal {S}}\)

\(\renewcommand {\U }{\mathcal {U}}\)

\(\renewcommand {\Cap }{\operatorname {cap}}\)

\(\newcommand {\val }{\operatorname {val}}\)

\(\newcommand {\dcut }{\operatorname {dcut}}\)

\(\newcommand {\opt }{\text {opt}}\)

\(\newcommand {\OPT }{\text {OPT}}\)

\(\newcommand {\OPTLP }{\text {OPT}_\text {LP}}\)

\(\newcommand {\OPTint }{\text {OPT}_\text {int}}\)

\(\newcommand {\OPTprimal }{\text {OPT}_\text {primal}}\)

\(\newcommand {\OPTdual }{\text {OPT}_\text {dual}}\)

\(\newcommand {\code }[1]{\texttt {#1}}\)

\(\newcommand {\name }[1]{\textsc {#1}}\)

\(\newcommand {\smallpmatrix }[1]{\left (\begin {smallmatrix}#1\end {smallmatrix}\right )}\)

\(\newcommand {\matlab }{{\fontfamily {bch}\scshape \selectfont {}Matlab}}\)

\(\newcommand {\innerproduct }[1]{\left \langle {#1}\right \rangle }\)

\(\newcommand {\norm }[1]{\left \Vert {#1}\right \Vert }\)

\(\renewcommand {\natural }{\mathbb {N}}\)

\(\newcommand {\integer }{\mathbb {Z}}\)

\(\newcommand {\rational }{\mathbb {Q}}\)

\(\newcommand {\real }{\mathbb {R}}\)

\(\newcommand {\complex }{\mathbb {C}}\)

\(\renewcommand {\d }{\mathop {}\!\mathrm {d}}\)

\(\newcommand {\dr }{\d {}r}\)

\(\newcommand {\ds }{\d {}s}\)

\(\newcommand {\dt }{\d {}t}\)

\(\newcommand {\du }{\d {}u}\)

\(\newcommand {\dv }{\d {}v}\)

\(\newcommand {\dw }{\d {}w}\)

\(\newcommand {\dx }{\d {}x}\)

\(\newcommand {\dy }{\d {}y}\)

\(\newcommand {\dz }{\d {}z}\)

\(\newcommand {\dsigma }{\d {}\sigma }\)

\(\newcommand {\dphi }{\d {}\phi }\)

\(\newcommand {\dvarphi }{\d {}\varphi }\)

\(\newcommand {\dtau }{\d {}\tau }\)

\(\newcommand {\dxi }{\d {}\xi }\)

\(\newcommand {\dtheta }{\d {}\theta }\)

\(\newcommand {\tp }{\mathrm {T}}\)

</div>

<style type="text/css">
.lwarp-contents li.list-item-f0::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f1::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f2::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f3::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f4::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f5::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f6::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f7::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f8::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f9::marker {
  font-style:italic;
  content:'(4)\00a0\00a0';
}
.lwarp-contents li.list-item-f10::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f11::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f12::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f13::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f14::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f15::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f16::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f17::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f18::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f19::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f20::marker {
  font-style:italic;
  content:'(4)\00a0\00a0';
}
.lwarp-contents li.list-item-f21::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f22::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f23::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f24::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f25::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f26::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f27::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f28::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f29::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f30::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f31::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f32::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f33::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f34::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f35::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f36::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f37::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f38::marker {
  font-style:italic;
  content:'(4)\00a0\00a0';
}
.lwarp-contents li.list-item-f39::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f40::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f41::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f42::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f43::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f44::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f45::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f46::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f47::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f48::marker {
  content:'•\00a0\00a0';
}
</style>
<p>

</p>



<h2 id="maximaler-fluss-maxflow">Maximaler Fluss (MaxFlow)</h2>

</p>


<h3 id="problem">Problem</h3>

</p>


<p>
<b>Netzwerk</b>: Ein <em><span class="dashuline" >Netzwerk</span></em> \(G = (V, E, \Cap , s, t)\) ist ein gerichteter Graph \((V, E)\) zusammen mit zwei verschiedenen, ausgezeichneten Knoten \(s \in V\) und
\(t \in V\) (<em><span class="dashuline" >Quelle</span></em> und <em><span class="dashuline" >Senke</span></em>) und einer <em><span class="dashuline" >Kapazita&#x0308;tsfunktion</span></em> \(\Cap
\colon E \to \natural \).
</p>

<p>
OBdA kann man annehmen, dass \(s\) nur aus- und \(t\) nur eingehende Kanten besitzt.
</p>

<p>
<b>Fluss</b>: Ein <em><span class="dashuline" >Fluss</span></em> im Netzwerk \(G\) ist eine Abbildung \(f\colon E \to \natural _0\) mit
</p>
<ul style="list-style-type:none">

<li class="list-item-f0"><p>\(\forall _{e \in E}\; f(e) \le \Cap (e)\) (<em><span class="dashuline" >Kapazita&#x0308;tsbedingung</span></em>) und
</p>
</li>
<li class="list-item-f1"><p>\(\forall _{v \in V \setminus \{s, t\}}\; \sum _{e = (\cdot , v)} f(e) = \sum _{e = (v, \cdot )} f(e)\) (<em><span class="dashuline" >Flusserhaltung</span></em>).
</p>
</li>
</ul>

<p>
\(f\) hat den <em><span class="dashuline" >Wert</span></em> \(\val (f) := \sum _{e = (s, \cdot )} f(e)\).
</p>

<p>
<b>MaxFlow-Problem</b>: Das <em><span class="dashuline" >MaxFlow-Problem</span></em> lautet wie folgt. Gegeben ist \(G = (V, E, \Cap , s, t)\).<br />
Gesucht ist ein Fluss von \(s\) nach \(t\) mit gro&#x0308;ßtmo&#x0308;glichem Wert (<em><span class="dashuline" >maximaler Fluss</span></em>).
</p>



<h3 id="ford-fulkerson-algorithmus"><span style="font-variant: small-caps;">Ford</span>-<span style="font-variant: small-caps;">Fulkerson</span>-Algorithmus</h3>

</p>


<p>
<b>Idee</b>: Wa&#x0308;hle einen beliebigen Pfad von \(s\) nach \(t\) und schicke einen gro&#x0308;ßtmo&#x0308;glichen Fluss \(f\) entlang dieses Pfads. \(f\) ist i.&#x202f;A. nicht der maximale Fluss. Allerdings kann
man \(f\) sozusagen vom Graphen „abziehen“, d.&#x202f;h. man vera&#x0308;ndert den Graph, sodass jeder Fluss im urspru&#x0308;nglichen Graph gleich einem Fluss im modifizierten Graph plus \(f\) ist. Dazu fu&#x0308;hrt
man umgekehrte Kanten ein, damit ein Teil des Flusses \(f\) wieder „ru&#x0308;ckga&#x0308;ngig“ gemacht werden kann.
</p>

<p>
<b>Residualnetzwerk</b>: Seien \(G = (V, E, \Cap , s, t)\) ein Netzwerk und \(f\) ein Fluss in \(G\).<br />
Dann ist das <em><span class="dashuline" >Residualnetzwerk</span></em> \(G_f := (V, E_f, \Cap _f, s, t)\) ein Netzwerk mit denselben Knoten, wobei die Kanten mit ihren Kapazita&#x0308;ten wie folgt definiert sind:
</p>
<ul style="list-style-type:none">

<li class="list-item-f2"><p>Fu&#x0308;r jede Kante \(e \in E\) mit \(f(e) &lt; \Cap (e)\) sei \(e \in E_f\) mit \(\Cap _f(e) := \Cap (e) - f(e)\).
</p>
</li>
<li class="list-item-f3"><p>Fu&#x0308;r jede Kante \(e = (v, w) \in E\) mit \(f(e) &gt; 0\) sei \(e’ := (w, v) \in E_f\) mit \(\Cap _f(e’) := f(e)\).
</p>
</li>
</ul>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b><span class="textsc" >Ford</span>-<span class="textsc" >Fulkerson</span>-Algorithmus</b>:<br />
Der <em><span class="dashuline" ><span class="textsc" >Ford</span>-<span class="textsc" >Fulkerson</span>-Alg.</span></em> bestimmt einen maximalen Fluss in einem Netzwerk \(G\) wie folgt.
</p>
<ul style="list-style-type:none">

<li class="list-item-f4"><p>Starte mit \(f\) als Nullfluss.
</p>
</li>
<li class="list-item-f5"><p>Konstruiere das Residualnetzwerk \(G_f = G\).
</p>
</li>
<li class="list-item-f6"><p>Solange es einen <em><span class="dashuline" >augmentierenden Pfad</span></em> \(\pi \) in \(G_f\) von \(s\) nach \(t\) gibt, wiederhole:
</p>
<ul style="list-style-type:none">

<li class="list-item-f7"><p>Sende den <em><span class="dashuline" >Flaschenhals-Wert</span></em> von \(\pi \) von \(s\) nach \(t\) u&#x0308;ber \(\pi \), addiere den Fluss auf \(f\).
</p>
</li>
<li class="list-item-f8"><p>Berechne \(G_f\) neu.
</p>
</li>
</ul>
</li>
<li class="list-item-f9"><p>Gebe \(f\) zuru&#x0308;ck.
</p>
</li>
</ul>

<p>
<b>Lemma (Terminiertheit)</b>: Der Algorithmus terminiert stets.
</p>

<p>
<b>Beweis</b>: In jeder Runde vergro&#x0308;ßert sich der Wert von \(f\) um mindestens \(1\). Allerdings ist der Wert begrenzt durch \(\sum _{e = (s, \cdot )} \Cap (e)\). &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
Die Korrektheit ist etwas schwieriger zu zeigen.
</p>

<p>
<b>gerichteter Schnitt</b>: Seien \(G = (V, E, \Cap )\) ein ger. Graph mit Kapazita&#x0308;tsfkt. \(\Cap \) und \(A \subset V\).<br />
Dann heißt \(\dcut (A, G) := \{(v, w) \in E \;|\; v \in A,\; w \in V \setminus A\}\) von \(A\) induz. <em><span class="dashuline" >gerichteter Schnitt</span></em>.
</p>

<p>
<b>Lemma</b>: Sei \(A \subset V\) mit \(s \in A\) und \(t \notin A\). Dann ist der Wert jeden Flusses von \(s\) nach \(t\) in \(G\) nach oben beschra&#x0308;nkt durch \(\sum _{e \in \dcut (A, G)} \Cap (e)\).
</p>

<p>
<b>Beweis</b>: Der Fluss kann nur in den Kanten in \(\dcut (A, G)\) von \(A\) nach \(V \setminus A\) u&#x0308;bergehen. &#x2003;&#x2003;
</p>

<p>
<b>Lemma (Korrektheit)</b>: Der Algorithmus arbeitet korrekt.
</p>

<p>
<b>Beweis</b>: Sei \(f\) der Fluss, der durch den Algorithmus ausgegeben wird. Im Folgenden wird \(A \subset V\) bestimmt mit \(s \in A\), \(t \notin A\) und \(\sum _{e \in \dcut (A, G)} \Cap (e) = \val (f)\).
Weil die linke Seite eine obere Schranke fu&#x0308;r den Wert eines optimalen Flusses ist, muss \(f\) dann maximal sein.
</p>

<p>
Sei dazu \(A\) die Menge der Knoten, die im letzten Residualnetzwerk \(G_f\) von \(s\) aus erreichbar sind. Dann gilt \(s \in A\) und \(t \notin A\) (sonst ha&#x0308;tte der Algorithmus in dem Schritt nicht terminiert).
Betrachte nun das Ausgangsnetzwerk \(G = (V, E, \Cap )\).
</p>
<ul style="list-style-type:none">

<li class="list-item-f10"><p>Fu&#x0308;r jede aus \(A\) ausgehende Kante \(e = (v, w)\) (also \(v \in A\), \(w \in V \setminus A\)) gilt \(f(e) = \Cap (e)\).<br />
Sonst wu&#x0308;rde aus \(f(e) &lt; \Cap (e)\) folgen, dass \(e\) auch eine Kante in \(G_f\) wa&#x0308;re. Dann wa&#x0308;re \(w\) von \(s\) aus in \(G_f\) erreichbar, ein Widerspruch zu \(w \notin A\).
</p>
</li>
<li class="list-item-f11"><p>Fu&#x0308;r jede in \(A\) eingehende Kante \(e = (v, w)\) (also \(v \in V \setminus A\), \(w \in A\)) gilt \(f(e) = 0\).<br />
Sonst wu&#x0308;rde aus \(f(e) &gt; 0\) folgen, dass \(e’ = (w, v)\) eine Kante in \(G_f\) wa&#x0308;re. Dann wa&#x0308;re \(v\) von \(s\) aus in \(G_f\) erreichbar, ein Widerspruch zu \(v \notin A\).
</p>
</li>
</ul>

<p>
Damit muss der Wert \(\val (f)\) von \(f\) gleich \(\sum _{e \in \dcut (A, G)} \Cap (e)\) sein. &#x2003;&#x2003;
</p>

<p>
Der Ford-Fulkerson-Algorithmus liefert mit dem gerichteten Schnitt \(A\) aus dem Beweis von eben ein <em><span class="dashuline" >Zertifikat der Optimalita&#x0308;t</span></em>, weil leicht nachvollzogen werden kann,
dass alle von \(A\) ausgehenden Kanten in \(G\) bis zu ihrer Kapazita&#x0308;t ausgenutzt werden (und die eingehenden gar nicht).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Zeitbedarf</b>: Wenn der augmentierende Pfad mithilfe Breiten- oder Tiefensuche bestimmt wird, so beno&#x0308;tigt der Algorithmus fu&#x0308;r jede Pfadbestimmung \(\O (m + n)\) Zeit (mit \(n := |V|\) und \(m :=
|E|\)). Auch die Konstruktion eines Residualnetzwerks kostet \(\O (m + n)\) Zeit. Weil aber momentan nur bekannt ist, dass der Wert des Flusses \(f\) sich in jedem Schritt nur um mindestens \(1\) vergro&#x0308;ßert, kann die
Laufzeit des Ford-Fulkerson-Algorithmus nur durch<br />
\(\O ((m + n) \cdot (\text {optimaler Flusswert})) \subset \O (C(m + n))\) mit \(C := \sum _{e = (s, \cdot )} \Cap (e)\) beschra&#x0308;nkt werden. Das kann sehr groß sein, insbesondere ist der optimale
Flusswert i.&#x202f;A. nicht polynomiell in der Eingabela&#x0308;nge.
</p>



<h3 id="capacity-scaling">Capacity Scaling</h3>

</p>


<p>
<b>Idee</b>: Suche zuna&#x0308;chst augmentierende Pfade mit einem hohen „Flaschenhals-Wert“. Es wenn es solche Pfade nicht mehr gibt, erlaube auch Pfade mit einem kleineren Wert.
</p>

<p>
<b><span class="textsc" >Ford</span>-<span class="textsc" >Fulkerson</span> mit Capacity Scaling</b>:<br />
Der Ford-Fulkerson-Algorithmus mit <em><span class="dashuline" >Capacity Scaling</span></em> sieht wie folgt aus.
</p>
<ul style="list-style-type:none">

<li class="list-item-f12"><p>Starte mit \(f\) als Nullfluss.
</p>
</li>
<li class="list-item-f13"><p>Wa&#x0308;hle \(D\) als die gro&#x0308;ßte Zweierpotenz kleiner als \(C := \max _{e \in E} \Cap (e)\) (d.&#x202f;h. \(D := 2^{\lfloor \log _2 C \rfloor }\)).
</p>
</li>
<li class="list-item-f14"><p>Wiederhole Folgendes, solange \(D \ge 1\) ist:
</p>
<ul style="list-style-type:none">

<li class="list-item-f15"><p>Konstruiere das Residualnetzwerk \(G_f(D)\) von \(G\) bzgl. \(f\), eingeschra&#x0308;nkt auf die Kanten mit Kapazita&#x0308;t \(\ge D\).
</p>
</li>
<li class="list-item-f16"><p>Solange es einen Pfad \(\pi \) in \(G_f(D)\) von \(s\) nach \(t\) gibt, wiederhole:
</p>
<ul style="list-style-type:none">

<li class="list-item-f17"><p>  Augmentiere \(f\) um den maximalen Fluss entlang \(\pi \).
</p>
</li>
<li class="list-item-f18"><p>  Berechne \(G_f(D)\) neu.
</p>
</li>
</ul>
</li>
<li class="list-item-f19"><p>  Halbiere \(D\).
</p>
</li>
</ul>
</li>
<li class="list-item-f20"><p>  Gebe \(f\) zuru&#x0308;ck.
</p>
</li>
</ul>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
Die a&#x0308;ußere Schleife wird \((\log D)\)-mal ausgefu&#x0308;hrt. Fu&#x0308;r die innere Schleife muss etwas bewiesen werden.
</p>

<p>
<b>Lemma</b>: Sei \(f_D\) der Fluss aus dem Algorithmus, nachdem alle Augmentierungen mit Kapazita&#x0308;tsschranke \(D\) durchgefu&#x0308;hrt wurden.<br />
Dann ist der maximale Flusswert in \(G\) beschra&#x0308;nkt durch \(\val (f_D) + mD\).
</p>

<p>
<b>Beweis</b>: Betrachte das Residualnetzwerk \(G_{f_D}\) nach der letzten Augmentierung mit Kapazita&#x0308;tsschranke \(D\) (mit allen Kanten, d.&#x202f;h. auch mit denen mit Kapazita&#x0308;t \(&lt; D\)). Dann
induziert die Menge \(A\) aller Knoten, die von \(s\) u&#x0308;ber einen Pfad, der nur Kanten von Kapazita&#x0308;t \(\ge D\) entha&#x0308;lt, erreichbar sind, einen gerichteten Schnitt \(\dcut (A, G)\), der \(s\) von \(t\)
trennt. Sei \(c\) die Kapazita&#x0308;t des gerichteten Schnitts. Zieht man von den Kapazita&#x0308;ten der Kanten aus \(\dcut (A, G)\) den Fluss \(f_D\) ab, so haben diese Kanten jeweils eine Kapazita&#x0308;t \(&lt; D\),
d.&#x202f;h. \(c - \val (f_D) &lt; mD\). Weil \(c\) eine obere Schranke fu&#x0308;r den maximalen Flusswert ist, folgt die Behauptung. &#x2003;&#x2003;
</p>

<p>
<b>Lemma</b>: Fu&#x0308;r festes \(D\) wird die innere Schleife ho&#x0308;chstens \(2m\)-mal durchlaufen.
</p>

<p>
<b>Beweis</b>: Beginnt man fu&#x0308;r festes \(D\) den ersten Durchgang der inneren Schleife mit dem Fluss \(f\), dann ist der maximale Flusswert von \(G\) nach dem Lemma von eben \(\le \val (f) + 2Dm\) (wegen der
vorherigen Runde der a&#x0308;ußeren Schleife mit Kapazita&#x0308;tsschranke \(2D\)). In jeder Runde der inneren Schleife erho&#x0308;ht sich der Flusswert um mindestens \(D\), d.&#x202f;h. es kann ho&#x0308;chstens
\(2m\)-viele Runden geben. &#x2003;&#x2003;
</p>

<p>
<b>Zeitbedarf</b>: FF mit Capacity Scaling beno&#x0308;tigt die Laufzeit \(\O ((m + n)m \cdot \log C) = \O (m^2 \log C)\), wobei \(C := \max _{e \in E} \Cap (e)\).
</p>

<p>
<b>Beweis</b>: Die a&#x0308;ußere Schleife wird \((\log D)\)-mal durchlaufen, wobei \(\O (\log C) = \O (\log D)\). Die innere Schleife wird \(\O (m)\)-mal durchlaufen und jede Pfadberechnung kostet \(\O (m + n)\)
Zeit. &#x2003;&#x2003;
</p>

<p>
Die Laufzeitschranke \(\O (m^2 \log C)\) ist zwar polynomiell in der Eingabela&#x0308;nge, allerdings ha&#x0308;ngt sie immer noch von den Kapazita&#x0308;tszahlen ab, was man gerne vermeiden wu&#x0308;rde.
</p>



<h3 id="edmonds-karp-algorithmus"><span style="font-variant: small-caps;">Edmonds</span>-<span style="font-variant: small-caps;">Karp</span>-Algorithmus</h3>

</p>


<p>
<b><span class="textsc" >Edmonds</span>-<span class="textsc" >Karp</span>-Algorithmus</b>: Der <em><span class="dashuline" ><span class="textsc" >Edmonds</span>-<span class="textsc"
>Karp</span>-Algorithmus</span></em> verwendet wieder den<br />
urspru&#x0308;nglichen FF-Algorithmus, nur mit der Maßgabe, dass immer der ku&#x0308;rzeste Pfad (im Sinne von Anzahl der verwendeten Kanten) als augmentierender Pfad verwendet werden soll. Ein solcher Pfad kann mit
Breitensuche ebenfalls in \(\O (m + n)\) Zeit gefunden werden.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Lemma</b>: Wa&#x0308;hrend des Verlaufs des Algorithmus verringert sich die La&#x0308;nge der augmentierenden Pfade nie.
</p>

<p>
<b>Beweis</b>: Seien \(\ell (v)\) die Distanz von \(s\) zu \(v \in V\) im Residualnetzwerk und \(G_\ell \) der Teilgraph des Residualnetzwerks, der die Kanten \((u, v)\) mit \(\ell (v) = \ell (u) + 1\)
entha&#x0308;lt. Ein Pfad \(\pi \) zwischen \(s\) und einem Knoten \(v\) im Residualnetzwerk ist am ku&#x0308;rzesten genau dann, wenn \(\pi \) auch ein Pfad in \(G_\ell \) ist. Wa&#x0308;hrend der Augmentierung von
\(f\) entlang eines Pfades \(\pi \) ko&#x0308;nnen prinzipiell zwei Ereignisse auftreten:
</p>
<ul style="list-style-type:none">

<li class="list-item-f21"><p>Kanten im Residualnetzwerk ko&#x0308;nnen verschwinden (wegen voller Kapazita&#x0308;t) oder
</p>
</li>
<li class="list-item-f22"><p>Ru&#x0308;ckwa&#x0308;rtskanten, die vorher noch nicht da waren, ko&#x0308;nnen erstellt werden.
</p>
</li>
</ul>

<p>
In beiden Fa&#x0308;llen verringert sich die Distanz von \(s\) zu den Knoten nicht, was insb. fu&#x0308;r \(t\) gilt. &#x2003;&#x2003;
</p>

<p>
<b>Lemma</b>: Nach ho&#x0308;chstens \(\O (m)\) Augmentierungen erho&#x0308;ht sich die La&#x0308;nge des augmentierenden Pfads um mindestens \(1\).
</p>

<p>
<b>Beweis</b>: Sei \(E_k\) die Menge aller Kanten im Residualnetzwerk am Anfang einer „Phase“, bei der die Distanz zwischen \(s\) und \(t\) genau \(k\) betra&#x0308;gt. Sobald der ku&#x0308;rzeste Pfad von \(s\) nach
\(t\) eine Kante benutzt, die nicht in \(E_k\) liegt, hat der Pfad eine La&#x0308;nge \(&gt; k\). Weil mit jeder Augmentierung mindestens eine Kante (die Flaschenhals-Kante) aus \(E_k\) eliminiert wird, muss sich die
La&#x0308;nge des ku&#x0308;rzesten Pfads von \(s\) nach \(t\) nach ho&#x0308;chstens \(|E_k| = \O (m)\) Schritten vergro&#x0308;ßern. &#x2003;&#x2003;
</p>

<p>
<b>Zeitbedarf</b>: Der Edmonds-Karp-Algorithmus terminiert nach \(\O (mn)\) Schritten.<br />
Damit hat der Algorithmus einen Zeitbedarf von \(\O ((m+n)mn) = \O (m^2 n)\).
</p>

<p>
<b>Beweis</b>: Jeweils nach \(\O (m)\) Runden erho&#x0308;ht sich nach dem letzten Lemma die La&#x0308;nge des augmentierenden Pfads um mindestens \(1\). Weil jeder Pfad im Residualnetzwerk ho&#x0308;chstens \(\O
(n)\) beteiligte Knoten haben kann, geht das ho&#x0308;chstens \(\O (n)\)-mal. &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>nicht-ganzzahlige Kapazita&#x0308;ten</b>: Bisher wurde immer angenommen, dass die Kapazita&#x0308;ten des Netzwerks ganzzahlig sind. Wenn man allgemein nur reelle Zahlen voraussetzt, muss der FF-Algorithmus
nicht terminieren. Es gibt sogar einfache Beispiele, bei denen der FF-Algorithmus nicht einmal gegen einen maximalen Fluss konvergiert.
</p>



<h2 id="fluss-minimaler-kosten-mincostflow">Fluss minimaler Kosten (MinCostFlow)</h2>

</p>


<h3 id="problem">Problem</h3>

</p>


<p>
<b>MinCostFlow-Problem</b>: Das <em><span class="dashuline" >MinCostFlow-Problem</span></em> ist eine Verallgemeinerung des MaxFlow-Problems. Gegeben ist ein <em><span class="dashuline" >erweitertes
Netzwerk</span></em> \(G = (V, E, b, c, \Cap )\) mit
</p>
<ul style="list-style-type:none">

<li class="list-item-f23"><p><em><span class="dashuline" >U&#x0308;berschussfunktion</span></em> \(b\colon V \to \integer \),
</p>
</li>
<li class="list-item-f24"><p><em><span class="dashuline" >Kostenfunktion</span></em> \(c\colon E \to \integer \) und
</p>
</li>
<li class="list-item-f25"><p><em><span class="dashuline" >Kapazita&#x0308;tsfunktion</span></em> \(\Cap \colon E \to \natural \),
</p>
</li>
</ul>

<p>
wobei \(\sum _{v \in V} b(v) = 0\) gelten soll (<em><span class="dashuline" >Gesamtu&#x0308;berschuss gleich Gesamtbedarf</span></em>).<br />
Gesucht ist wie beim MaxFlow-Problem ein <em><span class="dashuline" >zula&#x0308;ssiger Fluss</span></em> \(f\colon E \to \natural _0\), d.&#x202f;h.
</p>
<ul style="list-style-type:none">

<li class="list-item-f26"><p>\(\forall _{e \in E}\; f(e) \le \Cap (e)\) (<em><span class="dashuline" >Kapazita&#x0308;tsbedingung</span></em>) und
</p>
</li>
<li class="list-item-f27"><p>\(\forall _{v \in V}\; b(v) + \sum _{e = (\cdot , v)} f(e) = \sum _{e = (v, \cdot )} f(e)\) (<em><span class="dashuline" >Flusserhaltung</span></em>),
</p>
</li>
</ul>

<p>
sodass \(\sum _{e \in E} f(e)c(e)\) minimiert wird (<em><span class="dashuline" >Fluss minimaler Kosten</span></em>).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Berechnung eines zula&#x0308;ssigen Flusses</b>: Zur Berechnung eines zula&#x0308;ssigen Flusses erstellt man das Netzwerk \(G’ = (V’, E’, \Cap ’, s, t)\) mit
</p>
<ul style="list-style-type:none">

<li class="list-item-f28"><p>\(V’ := V \cup \{s, t\}\) (wobei \(s \notin V\) die <em><span class="dashuline" >Superquelle</span></em> und \(t \notin V\) die <em><span class="dashuline" >Supersenke</span></em> ist),
</p>
</li>
<li class="list-item-f29"><p>\(E’ := E \cup \{(s, v) \;|\; v \in V,\; b(v) &gt; 0\} \cup \{(w, t) \;|\; w \in V,\; b(w) &lt; 0\}\) sowie
</p>
</li>
<li class="list-item-f30"><p>\(\Cap ’(e) := e\) fu&#x0308;r \(e \in E\), \(\Cap ’((s, v)) := b(v)\) und \(\Cap ’((w, t)) := -b(w)\).
</p>
</li>
</ul>

<p>
Dann gibt es in \(G\) einen zula&#x0308;ssigen Fluss genau dann, wenn der maximale Flusswert in \(G’\) gleich \(\sum _{v \in V,\; b(v) &gt; 0} b(v)\) ist. Durch Berechnung eines maximalen Flusses in \(G’\) mit dem
FF-Algorithmus erha&#x0308;lt man so einen zula&#x0308;ssigen Fluss in \(G\) (nach Einschra&#x0308;nkung von \(E\)).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
Zur Berechnung eines Flusses minimaler Kosten wird wieder das Residualnetzwerk definiert.
</p>

<p>
<b>Residualnetzwerk</b>: Seien \(G = (V, E, b, c, \Cap )\) ein Netzwerk und \(f\) ein Fluss in \(G\).<br />
Dann ist das <em><span class="dashuline" >Residualnetzwerk</span></em> \(G_f := (V, E_f, b, c_f, \Cap _f)\) ein Netzwerk mit denselben Knoten, wobei die Kanten mit ihren Kapazita&#x0308;ten wie folgt definiert
sind:
</p>
<ul style="list-style-type:none">

<li class="list-item-f31"><p>Fu&#x0308;r jede Kante \(e \in E\) mit \(f(e) &lt; \Cap (e)\) sei \(e \in E_f\) mit<br />
\(\Cap _f(e) := \Cap (e) - f(e)\) und \(c_f(e) := c(e)\).
</p>
</li>
<li class="list-item-f32"><p>Fu&#x0308;r jede Kante \(e = (v, w) \in E\) mit \(f(e) &gt; 0\) sei \(e’ := (w, v) \in E_f\) mit<br />
\(\Cap _f(e’) := f(e)\) und \(c_f(e) := -c(e)\).
</p>
</li>
</ul>



<h3 id="cycle-canceling">Cycle Canceling</h3>

</p>


<p>
<b>negativer Kreis</b>: Ein <em><span class="dashuline" >negativer Kreis</span></em> ist ein Pfad \((v_0, \dotsc , v_k)\) mit \(k \in \natural \), \(v_0 = v_k\), \(v_i \not = v_j\) fu&#x0308;r \(i, j \ge 1\)
und \(\sum _{i=1}^k c((v_{i-1}, v_i)) &lt; 0\).
</p>

<p>
<b>Cycle-Canceling-Algorithmus</b>: Der <em><span class="dashuline" >Cycle-Canceling-Algorithmus</span></em> bestimmt einen Fluss minimaler Kosten in einem Netzwerk \(G\) wie folgt.
</p>
<ul style="list-style-type:none">

<li class="list-item-f33"><p>Berechne einen zula&#x0308;ssigen Fluss \(f\) wie oben.
</p>
</li>
<li class="list-item-f34"><p>Konstruiere das Residualnetzwerk \(G_f\).
</p>
</li>
<li class="list-item-f35"><p>Solange es einen negativen Kreis \(\pi \) in \(G_f\) gibt, wiederhole:
</p>
<ul style="list-style-type:none">

<li class="list-item-f36"><p>Sende den Flaschenhals-Wert u&#x0308;ber \(\pi \) und addiere den Fluss auf \(f\).
</p>
</li>
<li class="list-item-f37"><p>Berechne \(G_f\) neu.
</p>
</li>
</ul>
</li>
<li class="list-item-f38"><p>Gebe \(f\) zuru&#x0308;ck.
</p>
</li>
</ul>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Lemma (Terminiertheit)</b>: Der Algorithmus terminiert stets.
</p>

<p>
<b>Beweis</b>: Die Kosten jedes zula&#x0308;ssigen Flusses \(f\) sind nach unten durch \(\sum _{e \in E,\; c(e) &lt; 0} \Cap (e) c(e)\) beschra&#x0308;nkt. Weil die Kosten von \(f\) in jeder Runde um mindestens
\(1\) verringert werden, terminiert der Algorithmus nach endlich vielen Runden. &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Satz (Korrektheit)</b>: Sei \(f\) ein zula&#x0308;ssiger Fluss in \(G\).<br />
Dann ist \(f\) ein Fluss minimaler Kosten genau dann, wenn \(G_f\) keinen negativen Kreis entha&#x0308;lt.
</p>

<p>
<b>Beweis</b>: „\(\implies \)“: Angenommen, \(f\) besitzt minimale Kosten, aber \(G_f\) entha&#x0308;lt einen negativen Kreis. Dann sende mindestens \(1\) Fluss-Einheit entlang dieses Kreises, was die Kosten von \(f\) um
mindestens \(1\) reduziert, ein Widerspruch zur Minimalita&#x0308;t von \(f\).
</p>

<p>
„\(\impliedby \)“: Angenommen, \(G_f\) entha&#x0308;lt keinen negativen Kreis, aber \(f\) besitzt nicht minimale Kosten. Dann gibt es einen zula&#x0308;ssigen Fluss \(f^\ast \) mit \(c(f^\ast ) &lt; c(f)\). Betrachte
nun die Flussdifferenz \(f’ := f^\ast - f\). Dann gilt \(c(f’) &lt; 0\) und an jedem Knoten \(v \in V\) ist der eingehende Fluss genauso groß wie der ausgehende Fluss. Daher kann man \(f’\) in eine Menge \(\C \) von
Zykeln zerlegen. Es gilt \(\sum _{C \in \C } c(C) = c(f’) &lt; 0\), d.&#x202f;h. es gibt ein \(C_0 \in \C \) mit \(c(C_0) &lt; 0\). Man kann sich u&#x0308;berlegen, dass \(C_0\) ebenfalls ein negativer Kreis in \(G_f\)
ist, was aber ein Widerspruch zur Annahme ist, dass \(G_f\) keine negativen Kreise entha&#x0308;lt. &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Erkennung von negativen Kreisen</b>: Gegeben sei ein Graph \(G = (V, E, c)\) mit Kostenfunktion \(c\colon E \to \integer \) (\(c(e) &lt; 0\) ausdru&#x0308;cklich mo&#x0308;glich) mit \(n := |V|\) und \(m
:= |E|\). Um negative Kreise zu finden, kann man einen <em><span class="dashuline" >geschichteten Graphen</span></em> mit \(n\) Schichten erstellen, wobei jede Schicht eine Kopie von \(V\) entha&#x0308;lt und es eine
Kante zwischen \(v\) in Schicht \(i\) und \(w\) in Schicht \(i+1\) gibt genau dann, wenn \((v, w) \in E\) (wobei die Kantenkosten identisch seien). Nun ist ein Knoten \(v\) Teil eines negativen Kreises genau dann, wenn es
einen Pfad mit negativen Kosten von \(v\) in der ersten Schicht zu \(v\) in einer anderen Schicht gibt.
</p>

<p>
<b>Komplexita&#x0308;t</b>: Der geschichtete Graph hat die Gro&#x0308;ße \(\O (nm)\). Der naive Weg, um negative Kreise zu finden (Distanzen mit ku&#x0308;rzesten Pfaden von jedem Knoten in der ersten Schicht zu sich
selbst in einer anderen Schicht in \(\O (nm)\)), kostet Zeit \(\O (n^2 m)\). Besser ist der <em><span class="dashuline" ><span class="textsc" >Bellman</span>-<span class="textsc"
>Ford</span>Algorithmus</span></em>, der in \(\O (nm)\) la&#x0308;uft. Es gibt aber auch Algorithmen, die in Polynomialzeit laufen und einen negativen Kreis \(C\) zuru&#x0308;ckgeben, der \(\frac {c(C)}{|C|}\)
minimiert (mit \(|C|\) der Pfadla&#x0308;nge).
</p>



<h3 id="successive-shortest-paths">Successive Shortest Paths</h3>

</p>


<p>
<b>Idee</b>:
</p>
<ul style="list-style-type:none">

<li class="list-item-f39"><p>Der Cycle-Canceling-Algorithmus startet mit einem zula&#x0308;ssigen Fluss (nicht kostenoptimal) und verkleinert dann die Kosten, wa&#x0308;hrenddessen die Zula&#x0308;ssigkeit erhalten bleibt.
</p>
</li>
<li class="list-item-f40"><p>Der SSP-Algorithmus startet mit dem Nullfluss und erho&#x0308;ht schrittweise den Fluss, um Knoten-U&#x0308;berschuss/-Nachfrage zu decken, wa&#x0308;hrend die Kostenoptimalita&#x0308;t erhalten bleibt.
</p>
</li>
</ul>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Successive-Shortest-Paths-Algorithmus</b>: Der <em><span class="dashuline" >Successive-Shortest-Paths-Alg.</span></em> bestimmt einen Fluss minimaler Kosten in einem Netzwerk \(G\) ohne negative Kreise wie folgt.
</p>
<ul style="list-style-type:none">

<li class="list-item-f41"><p>Starte mit \(f\) als Nullfluss und konstruiere das Residualnetzwerk \(G_f = G\).
</p>
</li>
<li class="list-item-f42"><p>Wiederhole Folgendes:
</p>
<ul style="list-style-type:none">

<li class="list-item-f43"><p>Berechne einen ku&#x0308;rzesten Pfad \(\pi \) (bzgl. Kosten) im Residualnetzwerk \(G_f\) zwischen Knoten \(v, w \in V\) mit \(b(v) &gt; 0\) und \(b(w) &lt; 0\).<br />
Gibt es keinen solchen Pfad, dann ist \(\forall _{v \in V}\; b(v) = 0\) und gebe \(f\) zuru&#x0308;ck.
</p>
</li>
<li class="list-item-f44"><p>Sende so viel wie mo&#x0308;glich von \(v\) nach \(w\) (d.&#x202f;h. \(\min \{\text {Flaschenhals}(\pi ), b(v), -b(w)\}\)).
</p>
</li>
<li class="list-item-f45"><p>Aktualisiere \(b(v), b(w), f\) und berechne \(G_f\) neu.
</p>
</li>
</ul>
</li>
</ul>

<p>
Die in jedem Schritt zu berechnenden Knoten \(v, w\) ko&#x0308;nnen durch eine einzige Ku&#x0308;rzester-Pfad-Operation identifiziert werden, indem man eine Superquelle \(s\) einfu&#x0308;hrt, sie mit Kanten der
Kapazita&#x0308;t \(\infty \) und Kosten \(0\) mit allen U&#x0308;berschussknoten (d.&#x202f;h. \(v \in V\) mit \(b(v) &gt; 0\)) verbindet und analog eine Supersenke \(t\) einfu&#x0308;hrt.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b><span class="textsc" >Johnson</span>-Lemma</b>: Sei \(G = (V, E, c)\) ein gerichteter Graph mit mo&#x0308;glicherweise negativer Kostenfunktion \(c\colon E \to \integer \), der keine negativen Kreise
besitzt. Dann gibt es eine <em><span class="dashuline" >Potentialfunktion</span></em> \(\phi \colon V \to \integer \), sodass fu&#x0308;r \(c’\colon E \to \integer \), \(c’(v, w) := c(v, w) + \phi (v) -
\phi (w)\) gilt, dass \(\forall _{e \in E}\; c’(e) \ge 0\) und ein Pfad \(\pi \) ist am ku&#x0308;rzesten bzgl. \(c\) \(\iff \) \(\pi \) ist am ku&#x0308;rzesten bzgl. \(c’\).
</p>

<p>
<b>Beweis</b>: OBdA gebe es einen Knoten \(s \in V\), von dem aus alle anderen Knoten erreichbar sind. Sei \(d_s(v) \in \integer \) fu&#x0308;r \(v \in V\) die Distanz des ku&#x0308;rzesten Pfads von \(s\) nach
\(v\). \(d_s(v)\) ist wohldefiniert, weil \(G\) keine negativen Kreise entha&#x0308;lt, und kann z.&#x202f;B. mit Bellman-Ford in \(\O (mn)\) Zeit berechnet werden. Definiere \(\phi (v) := d_s(v)\). Fu&#x0308;r \((v, w)
\in E\) ist dann \(d_s(w) \le d_s(v) + c(v, w)\), also<br />
\(c’(v, w) := c(v, w) + \phi (v) - \phi (w) \ge 0\). Sei nun ein Pfad \(\pi = v_0 \dotsb v_k\) in \(G\) gegeben. Die Kosten von \(\pi \) bzgl. \(c’\) sind gleich \(\sum _{i=0}^{k-1} c’(v_i, v_{i+1}) = \sum
_{i=0}^{k-1} (c(v_i, v_{i+1}) + \phi (v_i) - \phi (v_{i+1}))\)<br />
\(= \sum _{i=0}^{k-1} c(v_i, v_{i+1}) + \phi (v_0) - \phi (v_k)\), wobei der erste Summand die Kosten von \(\pi \) bzgl. \(c\) darstellt. Damit ist \(\pi \) am ku&#x0308;rzesten bzgl. \(c\) ist genau dann, wenn
\(\pi \) am ku&#x0308;rzesten bzgl. \(c’\) ist. &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Satz (Korrektheit)</b>: Jedes Residualnetzwerk ist frei von negativen Kreisen.
</p>

<p>
<b>Beweis</b>: Betrachte die erste Augmentierung nach dem Nullfluss. Im entsprechenden Residualnetzwerk \(G_f\) ko&#x0308;nnen sich Kanten mit negativen Kosten nur auf dem Augmentierungspfad \(\pi \) befinden.
Angenommen, \(G_f\) besitzt einen negativen Kreis \(C\), dann muss \(C\) auch ein paar Ru&#x0308;ckwa&#x0308;rtskanten von \(\pi \) benutzen. \(C\) la&#x0308;sst sich daher zerlegen in einen Pfad \(C_1\), der mit einer
Kante mit negativen Kosten beginnt und endet, und einen Pfad \(C_2\), der nur Kanten mit nicht-negativen Kosten entha&#x0308;lt. OBdA enthalte \(C_1\) nur Ru&#x0308;ckwa&#x0308;rtskanten von \(v\) nach \(w\) (\(\ast
\)). Es gilt \(c(C_1) + c(C_2) = c(C) &lt; 0\) und \(c(C_2) &gt; 0\). \(C_2\) liefert einen Pfad von \(w\) nach \(v\) mit Kosten \(0 &lt; c(C_2) &lt; -c(C_1)\), was aber dem widerspricht, dass \(\pi \) ein
ku&#x0308;rzester Pfad war.
</p>

<p>
Fu&#x0308;r die spa&#x0308;teren Augmentierungen ko&#x0308;nnen Kanten mit negativen Kosten u&#x0308;berall in \(G_f\) verteilt sein. Daher wendet man das Johnson-Lemma nach jeder Augmentierung an.
&#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Begru&#x0308;ndung fu&#x0308;r (\(\ast \))</b>: Angenommen, \(C_2\) geht von \(v_6\) nach \(v_0\).
</p>
<ul style="list-style-type:none">

<li class="list-item-f46"><p>Wenn \(C_1\) den augmentierenden Pfad in \(v_1\) vor \(v_0\) verla&#x0308;sst, aber in \(v_5\) nach \(v_6\) wieder betritt und dann nach \(v_6\) la&#x0308;uft, dann kann \(C_1\) einfach durch \(v_0 \rightsquigarrow
v_1 \rightsquigarrow v_5 \rightsquigarrow v_6\) ersetzt werden (Kosten kleiner als \(c(C_2) &lt; 0\)), wobei „\(v_1 \rightsquigarrow v_5\)“ den Teil auf dem augm. Pfad meint.
</p>
</li>
<li class="list-item-f47"><p>Wenn \(C_1\) in \(v_1\) vor \(v_0\) den augmentierenden Pfad verla&#x0308;sst, dann aber in \(v_3\) vor \(v_6\) wieder betritt, in \(v_4\) vor \(v_3\) wieder verla&#x0308;sst, in \(v_5\) nach \(v_6\) wieder betritt und
dann nach \(v_6\) la&#x0308;uft, muss man etwas argumentieren. Es gilt \(c(v_3 \rightsquigarrow v_4), c(v_5 \rightsquigarrow v_6), c(v_0 \rightsquigarrow v_1) &lt; 0\) und \(c(v_1 \rightsquigarrow v_3),
c(v_4 \rightsquigarrow v_5), c(v_6 \rightsquigarrow v_0) &gt; 0\). Dann folgt \(|c(v_5 \rightsquigarrow v_6)| + |c(v_3 \rightsquigarrow v_4)| \le c(v_4 \rightsquigarrow v_5)\), weil \(v_4
\rightsquigarrow v_3 \rightsquigarrow v_6 \rightsquigarrow v_5\) der ku&#x0308;rzeste Pfad von \(v_4\) nach \(v_5\) war (Teilpfade des augmentierenden Pfads) und \(v_5 \rightsquigarrow v_6\) und \(v_3
\rightsquigarrow v_4\) Ru&#x0308;ckwa&#x0308;rts-Teilpfade von \(v_4 \rightsquigarrow v_3 \rightsquigarrow v_6 \rightsquigarrow v_5\) sind. Analog gilt \(|c(v_0 \rightsquigarrow v_1)| \le c(v_6
\rightsquigarrow v_0)\), weil \(v_6 \rightsquigarrow v_5 \rightsquigarrow v_1 \rightsquigarrow v_0\) der ku&#x0308;rzeste Pfad von \(v_6\) nach \(v_0\) war. Daraus folgt \(c(C) = (-|c(v_5 \rightsquigarrow
v_6)| - |c(v_3 \rightsquigarrow v_4)| + c(v_4 \rightsquigarrow v_5))\)<br />
\(+\; (-|c(v_0 \rightsquigarrow v_1)| + c(v_6 \rightsquigarrow v_0)) + c(v_1 \rightsquigarrow v_3) \ge c(v_1 \rightsquigarrow v_3) \ge 0\), ein Widerspruch zu \(C\) negativer Kreis.
</p>
</li>
<li class="list-item-f48"><p>Die anderen Fa&#x0308;lle gehen a&#x0308;hnlich.
</p>
</li>
</ul>



<h2 id="anwendungen-der-netzwerkfluss-berechnung">Anwendungen der Netzwerkfluss-Berechnung</h2>
<b>ku&#x0308;rzester Pfad zwischen zwei Knoten</b>: Gegeben sei ein Graph \(G = (V, E, c)\) mit Kosten \(c\) und zwei Knoten \(s, t \in V\) mit \(s \not = t\). Gesucht ist der bzgl. \(c\) ku&#x0308;rzeste Pfad von
\(s\) nach \(t\).
</p>

<p>
<b>Lo&#x0308;sung</b>: Setze \(b(s) := 1\), \(b(t) := -1\), \(\forall _{v \not = s, t}\; b(v) := 0\) und \(\forall _{e \in E}\; \Cap (e) := 1\).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Transport-Problem</b>: Gegeben seien \(m\) Einrichtungen \(f_1, \dotsc , f_m\), die jeweils \(s_i\) Einheiten einer Ware anbieten. \(n\) Kunden \(u_1, \dotsc , u_n\) haben jeweils einen Bedarf an \(d_j\) Einheiten
der Ware, wobei \(\sum _{i=1}^m s_i = \sum _{j=1}^n d_j\) gelten soll. Das Versenden einer Einheit der Ware von \(f_i\) nach \(u_j\) kostet \(c_{i,j}\). Gesucht ist eine Verteilung der Ware mit minimalen Kosten, sodass
alle Wu&#x0308;nsche der Kunden erfu&#x0308;llt sind.
</p>

<p>
<b>Lo&#x0308;sung</b>: Erstelle einen vollsta&#x0308;ndigen bipartiten Graph, d.&#x202f;h. Knotenmenge<br />
\(V := \{f_1, \dotsc , f_m\} \cup \{u_1, \dotsc , u_n\}\) und Kantenmenge \(E := \{f_1, \dotsc , f_m\} \times \{u_1, \dotsc , u_n\}\),<br />
wobei \(b(f_i) := s_i\) und \(b(u_j) := -d_j\) sowie \(\Cap (f_i, u_j) := \infty \) und \(c(f_i, u_j) := c_{i,j}\).
</p>

<p>
<b>Spezialfall</b>: Fu&#x0308;r \(n = m\) und \(s_i := d_j := 1\) fu&#x0308;r alle \(i, j = 1, \dotsc , n\) erha&#x0308;lt man das <em><span class="dashuline" >Zuweisungsproblem</span></em>. Beispielsweise
gibt es \(n\) Arbeitspla&#x0308;tze und \(n\) Arbeiter, wobei Arbeiter \(i\) an Arbeitsplatz \(j\) zu den Kosten \(c_{i,j}\) arbeiten kann. Obige Lo&#x0308;sung liefert dann eine Eins-zu-Eins-Zuweisung der Arbeiter auf die
Arbeitspla&#x0308;tze mit minimalen Kosten.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Airplane-Hopping-Problem</b>: Ein Flugzeug fliegt eine feste Route mit \(n\) Zwischenhalten \(v_1, \dotsc ,\)<br />
\(v_n\) und kann ho&#x0308;chstens \(p\) Passagiere tragen. Es gibt \(t_{i,j}\) Passagiere, die von \(v_i\) nach \(v_j\) reisen wollen und dafu&#x0308;r \(f_{i,j}\) ausgeben (wobei \(i &lt; j\)). Gesucht sind die Anteile
an den \(t_{i,j}\)-vielen Passagieren, die die Fluglinie jeweils mitnehmen soll, um ihren Gewinn zu maximieren, ohne jemals mehr als \(p\) Passagiere mitfliegen zu lassen.
</p>

<p>
<b>Lo&#x0308;sung</b>: Fu&#x0308;hre Knoten \(v_i\) und \(w_{i,j}\) (fu&#x0308;r \(i = 1, \dotsc , n\) und \(i &lt; j\)), wobei \(w_{i,j}\) die Passagiere darstellt, die von \(v_i\) nach \(v_j\) reisen wollen.
Setze \(b(v_j) :=-\sum _{i&lt;j} t_{i,j}\) und \(b(w_{i,j}) := t_{i,j}\).<br />
Verbinde \(v_i, v_{i+1}\) durch eine Kante mit Kapazita&#x0308;t \(p\) und Kosten \(0\). Erstelle zudem<br />
Kanten \((w_{i,j}, v_i)\) mit \(\Cap (w_{i,j}, v_i) := \infty \) und \(c(w_{i,j}, v_i) := -f_{i,j}\) sowie<br />
Kanten \((w_{i,j}, v_j)\) mit \(\Cap (w_{i,j}, v_j) := \infty \) und \(c(w_{i,j}, v_j) := 0\).
</p>

{% endraw %}
</div>
{:/nomarkdown}
