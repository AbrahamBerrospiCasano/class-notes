
{::nomarkdown}
<div class="lwarp-contents">
{% raw %}
<div class="hidden" >

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\mathllap }[2][]{{#1#2}}\)

\(\newcommand {\mathrlap }[2][]{{#1#2}}\)

\(\newcommand {\mathclap }[2][]{{#1#2}}\)

\(\newcommand {\mathmbox }[1]{#1}\)

\(\newcommand {\clap }[1]{#1}\)

\(\newcommand {\LWRmathmakebox }[2][]{#2}\)

\(\newcommand {\mathmakebox }[1][]{\LWRmathmakebox }\)

\(\newcommand {\cramped }[2][]{{#1#2}}\)

\(\newcommand {\crampedllap }[2][]{{#1#2}}\)

\(\newcommand {\crampedrlap }[2][]{{#1#2}}\)

\(\newcommand {\crampedclap }[2][]{{#1#2}}\)

\(\newenvironment {crampedsubarray}[1]{}{}\)

\(\newcommand {\crampedsubstack }{}\)

\(\newcommand {\smashoperator }[2][]{#2\limits }\)

\(\newcommand {\adjustlimits }{}\)

\(\newcommand {\SwapAboveDisplaySkip }{}\)

\(\require {extpfeil}\)

\(\Newextarrow \xleftrightarrow {10,10}{0x2194}\)

\(\Newextarrow \xLeftarrow {10,10}{0x21d0}\)

\(\Newextarrow \xhookleftarrow {10,10}{0x21a9}\)

\(\Newextarrow \xmapsto {10,10}{0x21a6}\)

\(\Newextarrow \xRightarrow {10,10}{0x21d2}\)

\(\Newextarrow \xLeftrightarrow {10,10}{0x21d4}\)

\(\Newextarrow \xhookrightarrow {10,10}{0x21aa}\)

\(\Newextarrow \xrightharpoondown {10,10}{0x21c1}\)

\(\Newextarrow \xleftharpoondown {10,10}{0x21bd}\)

\(\Newextarrow \xrightleftharpoons {10,10}{0x21cc}\)

\(\Newextarrow \xrightharpoonup {10,10}{0x21c0}\)

\(\Newextarrow \xleftharpoonup {10,10}{0x21bc}\)

\(\Newextarrow \xleftrightharpoons {10,10}{0x21cb}\)

\(\newcommand {\LWRdounderbracket }[3]{\underset {#3}{\underline {#1}}}\)

\(\newcommand {\LWRunderbracket }[2][]{\LWRdounderbracket {#2}}\)

\(\newcommand {\underbracket }[1][]{\LWRunderbracket }\)

\(\newcommand {\LWRdooverbracket }[3]{\overset {#3}{\overline {#1}}}\)

\(\newcommand {\LWRoverbracket }[2][]{\LWRdooverbracket {#2}}\)

\(\newcommand {\overbracket }[1][]{\LWRoverbracket }\)

\(\newcommand {\LaTeXunderbrace }[1]{\underbrace {#1}}\)

\(\newcommand {\LaTeXoverbrace }[1]{\overbrace {#1}}\)

\(\newenvironment {matrix*}[1][]{\begin {matrix}}{\end {matrix}}\)

\(\newenvironment {pmatrix*}[1][]{\begin {pmatrix}}{\end {pmatrix}}\)

\(\newenvironment {bmatrix*}[1][]{\begin {bmatrix}}{\end {bmatrix}}\)

\(\newenvironment {Bmatrix*}[1][]{\begin {Bmatrix}}{\end {Bmatrix}}\)

\(\newenvironment {vmatrix*}[1][]{\begin {vmatrix}}{\end {vmatrix}}\)

\(\newenvironment {Vmatrix*}[1][]{\begin {Vmatrix}}{\end {Vmatrix}}\)

\(\newenvironment {smallmatrix*}[1][]{\begin {matrix}}{\end {matrix}}\)

\(\newenvironment {psmallmatrix*}[1][]{\begin {pmatrix}}{\end {pmatrix}}\)

\(\newenvironment {bsmallmatrix*}[1][]{\begin {bmatrix}}{\end {bmatrix}}\)

\(\newenvironment {Bsmallmatrix*}[1][]{\begin {Bmatrix}}{\end {Bmatrix}}\)

\(\newenvironment {vsmallmatrix*}[1][]{\begin {vmatrix}}{\end {vmatrix}}\)

\(\newenvironment {Vsmallmatrix*}[1][]{\begin {Vmatrix}}{\end {Vmatrix}}\)

\(\newenvironment {psmallmatrix}[1][]{\begin {pmatrix}}{\end {pmatrix}}\)

\(\newenvironment {bsmallmatrix}[1][]{\begin {bmatrix}}{\end {bmatrix}}\)

\(\newenvironment {Bsmallmatrix}[1][]{\begin {Bmatrix}}{\end {Bmatrix}}\)

\(\newenvironment {vsmallmatrix}[1][]{\begin {vmatrix}}{\end {vmatrix}}\)

\(\newenvironment {Vsmallmatrix}[1][]{\begin {Vmatrix}}{\end {Vmatrix}}\)

\(\newcommand {\LWRmultlined }[1][]{\begin {multline*}}\)

\(\newenvironment {multlined}[1][]{\LWRmultlined }{\end {multline*}}\)

\(\let \LWRorigshoveleft \shoveleft \)

\(\renewcommand {\shoveleft }[1][]{\LWRorigshoveleft }\)

\(\let \LWRorigshoveright \shoveright \)

\(\renewcommand {\shoveright }[1][]{\LWRorigshoveright }\)

\(\newenvironment {dcases}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {dcases*}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {rcases}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {rcases*}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {drcases}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {drcases*}{\begin {cases}}{\end {cases}}\)

\(\newenvironment {cases*}{\begin {cases}}{\end {cases}}\)

\(\newcommand {\MoveEqLeft }[1][]{}\)

\(\def \LWRAboxed #1&amp;#2&amp;#3!|!{\fbox {\(#1\)}&amp;\fbox {\(#2\)}} \newcommand {\Aboxed }[1]{\LWRAboxed #1&amp;&amp;!|!} \)

\( \newcommand {\LWRABLines }[1][\Updownarrow ]{#1 \notag \\}\newcommand {\ArrowBetweenLines }{\ifstar \LWRABLines \LWRABLines } \)

\(\newcommand {\shortintertext }[1]{\text {#1}\notag \\}\)

\(\newcommand {\vdotswithin }[1]{\hspace {.5em}\vdots }\)

\(\newcommand {\LWRshortvdotswithinstar }[1]{\vdots \hspace {.5em} &amp; \\}\)

\(\newcommand {\LWRshortvdotswithinnostar }[1]{&amp; \hspace {.5em}\vdots \\}\)

\(\newcommand {\shortvdotswithin }{\ifstar \LWRshortvdotswithinstar \LWRshortvdotswithinnostar }\)

\(\newcommand {\MTFlushSpaceAbove }{}\)

\(\newcommand {\MTFlushSpaceBelow }{\\}\)

\(\newcommand \lparen {(}\)

\(\newcommand \rparen {)}\)

\(\newcommand {\ordinarycolon }{:}\)

\(\newcommand {\vcentcolon }{\mathrel {\mathop \ordinarycolon }}\)

\(\newcommand \dblcolon {\vcentcolon \vcentcolon }\)

\(\newcommand \coloneqq {\vcentcolon =}\)

\(\newcommand \Coloneqq {\dblcolon =}\)

\(\newcommand \coloneq {\vcentcolon {-}}\)

\(\newcommand \Coloneq {\dblcolon {-}}\)

\(\newcommand \eqqcolon {=\vcentcolon }\)

\(\newcommand \Eqqcolon {=\dblcolon }\)

\(\newcommand \eqcolon {\mathrel {-}\vcentcolon }\)

\(\newcommand \Eqcolon {\mathrel {-}\dblcolon }\)

\(\newcommand \colonapprox {\vcentcolon \approx }\)

\(\newcommand \Colonapprox {\dblcolon \approx }\)

\(\newcommand \colonsim {\vcentcolon \sim }\)

\(\newcommand \Colonsim {\dblcolon \sim }\)

\(\newcommand {\nuparrow }{\mathrel {\cancel {\uparrow }}}\)

\(\newcommand {\ndownarrow }{\mathrel {\cancel {\downarrow }}}\)

\(\newcommand {\bigtimes }{\mathop {\Large \times }\limits }\)

\(\newcommand {\prescript }[3]{{}^{#1}_{#2}#3}\)

\(\newenvironment {lgathered}{\begin {gathered}}{\end {gathered}}\)

\(\newenvironment {rgathered}{\begin {gathered}}{\end {gathered}}\)

\(\newcommand {\splitfrac }[2]{{}^{#1}_{#2}}\)

\(\let \splitdfrac \splitfrac \)

\(\newcommand {\LWRoverlaysymbols }[2]{\mathord {\smash {\mathop {#2\strut }\limits ^{\smash {\lower 3ex{#1}}}}\strut }}\)

\(\newcommand{\alphaup}{\unicode{x03B1}}\)

\(\newcommand{\betaup}{\unicode{x03B2}}\)

\(\newcommand{\gammaup}{\unicode{x03B3}}\)

\(\newcommand{\digammaup}{\unicode{x03DD}}\)

\(\newcommand{\deltaup}{\unicode{x03B4}}\)

\(\newcommand{\epsilonup}{\unicode{x03F5}}\)

\(\newcommand{\varepsilonup}{\unicode{x03B5}}\)

\(\newcommand{\zetaup}{\unicode{x03B6}}\)

\(\newcommand{\etaup}{\unicode{x03B7}}\)

\(\newcommand{\thetaup}{\unicode{x03B8}}\)

\(\newcommand{\varthetaup}{\unicode{x03D1}}\)

\(\newcommand{\iotaup}{\unicode{x03B9}}\)

\(\newcommand{\kappaup}{\unicode{x03BA}}\)

\(\newcommand{\varkappaup}{\unicode{x03F0}}\)

\(\newcommand{\lambdaup}{\unicode{x03BB}}\)

\(\newcommand{\muup}{\unicode{x03BC}}\)

\(\newcommand{\nuup}{\unicode{x03BD}}\)

\(\newcommand{\xiup}{\unicode{x03BE}}\)

\(\newcommand{\omicronup}{\unicode{x03BF}}\)

\(\newcommand{\piup}{\unicode{x03C0}}\)

\(\newcommand{\varpiup}{\unicode{x03D6}}\)

\(\newcommand{\rhoup}{\unicode{x03C1}}\)

\(\newcommand{\varrhoup}{\unicode{x03F1}}\)

\(\newcommand{\sigmaup}{\unicode{x03C3}}\)

\(\newcommand{\varsigmaup}{\unicode{x03C2}}\)

\(\newcommand{\tauup}{\unicode{x03C4}}\)

\(\newcommand{\upsilonup}{\unicode{x03C5}}\)

\(\newcommand{\phiup}{\unicode{x03D5}}\)

\(\newcommand{\varphiup}{\unicode{x03C6}}\)

\(\newcommand{\chiup}{\unicode{x03C7}}\)

\(\newcommand{\psiup}{\unicode{x03C8}}\)

\(\newcommand{\omegaup}{\unicode{x03C9}}\)

\(\newcommand{\Alphaup}{\unicode{x0391}}\)

\(\newcommand{\Betaup}{\unicode{x0392}}\)

\(\newcommand{\Gammaup}{\unicode{x0393}}\)

\(\newcommand{\Digammaup}{\unicode{x03DC}}\)

\(\newcommand{\Deltaup}{\unicode{x0394}}\)

\(\newcommand{\Epsilonup}{\unicode{x0395}}\)

\(\newcommand{\Zetaup}{\unicode{x0396}}\)

\(\newcommand{\Etaup}{\unicode{x0397}}\)

\(\newcommand{\Thetaup}{\unicode{x0398}}\)

\(\newcommand{\Varthetaup}{\unicode{x03F4}}\)

\(\newcommand{\Iotaup}{\unicode{x0399}}\)

\(\newcommand{\Kappaup}{\unicode{x039A}}\)

\(\newcommand{\Lambdaup}{\unicode{x039B}}\)

\(\newcommand{\Muup}{\unicode{x039C}}\)

\(\newcommand{\Nuup}{\unicode{x039D}}\)

\(\newcommand{\Xiup}{\unicode{x039E}}\)

\(\newcommand{\Omicronup}{\unicode{x039F}}\)

\(\newcommand{\Piup}{\unicode{x03A0}}\)

\(\newcommand{\Varpiup}{\unicode{x03D6}}\)

\(\newcommand{\Rhoup}{\unicode{x03A1}}\)

\(\newcommand{\Sigmaup}{\unicode{x03A3}}\)

\(\newcommand{\Tauup}{\unicode{x03A4}}\)

\(\newcommand{\Upsilonup}{\unicode{x03A5}}\)

\(\newcommand{\Phiup}{\unicode{x03A6}}\)

\(\newcommand{\Chiup}{\unicode{x03A7}}\)

\(\newcommand{\Psiup}{\unicode{x03A8}}\)

\(\newcommand{\Omegaup}{\unicode{x03A9}}\)

\(\newcommand{\alphait}{\unicode{x1D6FC}}\)

\(\newcommand{\betait}{\unicode{x1D6FD}}\)

\(\newcommand{\gammait}{\unicode{x1D6FE}}\)

\(\newcommand{\digammait}{\mathit{\unicode{x03DD}}}\)

\(\newcommand{\deltait}{\unicode{x1D6FF}}\)

\(\newcommand{\epsilonit}{\unicode{x1D716}}\)

\(\newcommand{\varepsilonit}{\unicode{x1D700}}\)

\(\newcommand{\zetait}{\unicode{x1D701}}\)

\(\newcommand{\etait}{\unicode{x1D702}}\)

\(\newcommand{\thetait}{\unicode{x1D703}}\)

\(\newcommand{\varthetait}{\unicode{x1D717}}\)

\(\newcommand{\iotait}{\unicode{x1D704}}\)

\(\newcommand{\kappait}{\unicode{x1D705}}\)

\(\newcommand{\varkappait}{\unicode{x1D718}}\)

\(\newcommand{\lambdait}{\unicode{x1D706}}\)

\(\newcommand{\muit}{\unicode{x1D707}}\)

\(\newcommand{\nuit}{\unicode{x1D708}}\)

\(\newcommand{\xiit}{\unicode{x1D709}}\)

\(\newcommand{\omicronit}{\unicode{x1D70A}}\)

\(\newcommand{\piit}{\unicode{x1D70B}}\)

\(\newcommand{\varpiit}{\unicode{x1D71B}}\)

\(\newcommand{\rhoit}{\unicode{x1D70C}}\)

\(\newcommand{\varrhoit}{\unicode{x1D71A}}\)

\(\newcommand{\sigmait}{\unicode{x1D70E}}\)

\(\newcommand{\varsigmait}{\unicode{x1D70D}}\)

\(\newcommand{\tauit}{\unicode{x1D70F}}\)

\(\newcommand{\upsilonit}{\unicode{x1D710}}\)

\(\newcommand{\phiit}{\unicode{x1D719}}\)

\(\newcommand{\varphiit}{\unicode{x1D711}}\)

\(\newcommand{\chiit}{\unicode{x1D712}}\)

\(\newcommand{\psiit}{\unicode{x1D713}}\)

\(\newcommand{\omegait}{\unicode{x1D714}}\)

\(\newcommand{\Alphait}{\unicode{x1D6E2}}\)

\(\newcommand{\Betait}{\unicode{x1D6E3}}\)

\(\newcommand{\Gammait}{\unicode{x1D6E4}}\)

\(\newcommand{\Digammait}{\mathit{\unicode{x03DC}}}\)

\(\newcommand{\Deltait}{\unicode{x1D6E5}}\)

\(\newcommand{\Epsilonit}{\unicode{x1D6E6}}\)

\(\newcommand{\Zetait}{\unicode{x1D6E7}}\)

\(\newcommand{\Etait}{\unicode{x1D6E8}}\)

\(\newcommand{\Thetait}{\unicode{x1D6E9}}\)

\(\newcommand{\Varthetait}{\unicode{x1D6F3}}\)

\(\newcommand{\Iotait}{\unicode{x1D6EA}}\)

\(\newcommand{\Kappait}{\unicode{x1D6EB}}\)

\(\newcommand{\Lambdait}{\unicode{x1D6EC}}\)

\(\newcommand{\Muit}{\unicode{x1D6ED}}\)

\(\newcommand{\Nuit}{\unicode{x1D6EE}}\)

\(\newcommand{\Xiit}{\unicode{x1D6EF}}\)

\(\newcommand{\Omicronit}{\unicode{x1D6F0}}\)

\(\newcommand{\Piit}{\unicode{x1D6F1}}\)

\(\newcommand{\Rhoit}{\unicode{x1D6F2}}\)

\(\newcommand{\Sigmait}{\unicode{x1D6F4}}\)

\(\newcommand{\Tauit}{\unicode{x1D6F5}}\)

\(\newcommand{\Upsilonit}{\unicode{x1D6F6}}\)

\(\newcommand{\Phiit}{\unicode{x1D6F7}}\)

\(\newcommand{\Chiit}{\unicode{x1D6F8}}\)

\(\newcommand{\Psiit}{\unicode{x1D6F9}}\)

\(\newcommand{\Omegait}{\unicode{x1D6FA}}\)

\(\let \digammaup \Digammaup \)

\(\renewcommand {\digammait }{\mathit {\digammaup }}\)

\(\newcommand {\smallin }{\unicode {x220A}}\)

\(\newcommand {\smallowns }{\unicode {x220D}}\)

\(\newcommand {\notsmallin }{\LWRoverlaysymbols {/}{\unicode {x220A}}}\)

\(\newcommand {\notsmallowns }{\LWRoverlaysymbols {/}{\unicode {x220D}}}\)

\(\newcommand {\rightangle }{\unicode {x221F}}\)

\(\newcommand {\intclockwise }{\unicode {x2231}}\)

\(\newcommand {\ointclockwise }{\unicode {x2232}}\)

\(\newcommand {\ointctrclockwise }{\unicode {x2233}}\)

\(\newcommand {\oiint }{\unicode {x222F}}\)

\(\newcommand {\oiiint }{\unicode {x2230}}\)

\(\newcommand {\ddag }{\unicode {x2021}}\)

\(\newcommand {\P }{\unicode {x00B6}}\)

\(\newcommand {\copyright }{\unicode {x00A9}}\)

\(\newcommand {\dag }{\unicode {x2020}}\)

\(\newcommand {\pounds }{\unicode {x00A3}}\)

\(\newcommand {\iddots }{\unicode {x22F0}}\)

\(\newcommand {\utimes }{\overline {\times }}\)

\(\newcommand {\dtimes }{\underline {\times }}\)

\(\newcommand {\udtimes }{\overline {\underline {\times }}}\)

\(\newcommand {\leftwave }{\left \{}\)

\(\newcommand {\rightwave }{\right \}}\)

\(\newcommand {\toprule }[1][]{\hline }\)

\(\let \midrule \toprule \)

\(\let \bottomrule \toprule \)

\(\newcommand {\cmidrule }[2][]{}\)

\(\newcommand {\morecmidrules }{}\)

\(\newcommand {\specialrule }[3]{\hline }\)

\(\newcommand {\addlinespace }[1][]{}\)

\(\newcommand {\LWRsubmultirow }[2][]{#2}\)

\(\newcommand {\LWRmultirow }[2][]{\LWRsubmultirow }\)

\(\newcommand {\multirow }[2][]{\LWRmultirow }\)

\(\newcommand {\mrowcell }{}\)

\(\newcommand {\mcolrowcell }{}\)

\(\newcommand {\STneed }[1]{}\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\newcommand {\tothe }[1]{^{#1}}\)

\(\newcommand {\raiseto }[2]{{#2}^{#1}}\)

\(\newcommand {\ang }[2][]{(\mathrm {#2})\degree }\)

\(\newcommand {\num }[2][]{\mathrm {#2}}\)

\(\newcommand {\si }[2][]{\mathrm {#2}}\)

\(\newcommand {\LWRSI }[2][]{\mathrm {#1\LWRSInumber \,#2}}\)

\(\newcommand {\SI }[2][]{\def \LWRSInumber {#2}\LWRSI }\)

\(\newcommand {\numlist }[2][]{\mathrm {#2}}\)

\(\newcommand {\numrange }[3][]{\mathrm {#2\,\unicode {x2013}\,#3}}\)

\(\newcommand {\SIlist }[3][]{\mathrm {#2\,#3}}\)

\(\newcommand {\SIrange }[4][]{\mathrm {#2\,#4\,\unicode {x2013}\,#3\,#4}}\)

\(\newcommand {\tablenum }[2][]{\mathrm {#2}}\)

\(\newcommand {\ampere }{\mathrm {A}}\)

\(\newcommand {\candela }{\mathrm {cd}}\)

\(\newcommand {\kelvin }{\mathrm {K}}\)

\(\newcommand {\kilogram }{\mathrm {kg}}\)

\(\newcommand {\metre }{\mathrm {m}}\)

\(\newcommand {\mole }{\mathrm {mol}}\)

\(\newcommand {\second }{\mathrm {s}}\)

\(\newcommand {\becquerel }{\mathrm {Bq}}\)

\(\newcommand {\degreeCelsius }{\unicode {x2103}}\)

\(\newcommand {\coulomb }{\mathrm {C}}\)

\(\newcommand {\farad }{\mathrm {F}}\)

\(\newcommand {\gray }{\mathrm {Gy}}\)

\(\newcommand {\hertz }{\mathrm {Hz}}\)

\(\newcommand {\henry }{\mathrm {H}}\)

\(\newcommand {\joule }{\mathrm {J}}\)

\(\newcommand {\katal }{\mathrm {kat}}\)

\(\newcommand {\lumen }{\mathrm {lm}}\)

\(\newcommand {\lux }{\mathrm {lx}}\)

\(\newcommand {\newton }{\mathrm {N}}\)

\(\newcommand {\ohm }{\mathrm {\Omega }}\)

\(\newcommand {\pascal }{\mathrm {Pa}}\)

\(\newcommand {\radian }{\mathrm {rad}}\)

\(\newcommand {\siemens }{\mathrm {S}}\)

\(\newcommand {\sievert }{\mathrm {Sv}}\)

\(\newcommand {\steradian }{\mathrm {sr}}\)

\(\newcommand {\tesla }{\mathrm {T}}\)

\(\newcommand {\volt }{\mathrm {V}}\)

\(\newcommand {\watt }{\mathrm {W}}\)

\(\newcommand {\weber }{\mathrm {Wb}}\)

\(\newcommand {\day }{\mathrm {d}}\)

\(\newcommand {\degree }{\mathrm {^\circ }}\)

\(\newcommand {\hectare }{\mathrm {ha}}\)

\(\newcommand {\hour }{\mathrm {h}}\)

\(\newcommand {\litre }{\mathrm {l}}\)

\(\newcommand {\liter }{\mathrm {L}}\)

\(\newcommand {\arcminute }{^\prime }\)
\(\newcommand {\minute }{\mathrm {min}}\)

\(\newcommand {\arcsecond }{^{\prime \prime }}\)

\(\newcommand {\tonne }{\mathrm {t}}\)

\(\newcommand {\astronomicalunit }{au}\)

\(\newcommand {\atomicmassunit }{u}\)

\(\newcommand {\bohr }{\mathit {a}_0}\)

\(\newcommand {\clight }{\mathit {c}_0}\)

\(\newcommand {\dalton }{\mathrm {D}_\mathrm {a}}\)

\(\newcommand {\electronmass }{\mathit {m}_{\mathrm {e}}}\)

\(\newcommand {\electronvolt }{\mathrm {eV}}\)

\(\newcommand {\elementarycharge }{\mathit {e}}\)

\(\newcommand {\hartree }{\mathit {E}_{\mathrm {h}}}\)

\(\newcommand {\planckbar }{\mathit {\unicode {x210F}}}\)

\(\newcommand {\angstrom }{\mathrm {\unicode {x212B}}}\)

\(\let \LWRorigbar \bar \)

\(\newcommand {\bar }{\mathrm {bar}}\)

\(\newcommand {\barn }{\mathrm {b}}\)

\(\newcommand {\bel }{\mathrm {B}}\)

\(\newcommand {\decibel }{\mathrm {dB}}\)

\(\newcommand {\knot }{\mathrm {kn}}\)

\(\newcommand {\mmHg }{\mathrm {mmHg}}\)

\(\newcommand {\nauticalmile }{\mathrm {M}}\)

\(\newcommand {\neper }{\mathrm {Np}}\)

\(\newcommand {\yocto }{\mathrm {y}}\)

\(\newcommand {\zepto }{\mathrm {z}}\)

\(\newcommand {\atto }{\mathrm {a}}\)

\(\newcommand {\femto }{\mathrm {f}}\)

\(\newcommand {\pico }{\mathrm {p}}\)

\(\newcommand {\nano }{\mathrm {n}}\)

\(\newcommand {\micro }{\mathrm {\unicode {x00B5}}}\)

\(\newcommand {\milli }{\mathrm {m}}\)

\(\newcommand {\centi }{\mathrm {c}}\)

\(\newcommand {\deci }{\mathrm {d}}\)

\(\newcommand {\deca }{\mathrm {da}}\)

\(\newcommand {\hecto }{\mathrm {h}}\)

\(\newcommand {\kilo }{\mathrm {k}}\)

\(\newcommand {\mega }{\mathrm {M}}\)

\(\newcommand {\giga }{\mathrm {G}}\)

\(\newcommand {\tera }{\mathrm {T}}\)

\(\newcommand {\peta }{\mathrm {P}}\)

\(\newcommand {\exa }{\mathrm {E}}\)

\(\newcommand {\zetta }{\mathrm {Z}}\)

\(\newcommand {\yotta }{\mathrm {Y}}\)

\(\newcommand {\percent }{\mathrm {\%}}\)

\(\newcommand {\meter }{\mathrm {m}}\)

\(\newcommand {\metre }{\mathrm {m}}\)

\(\newcommand {\gram }{\mathrm {g}}\)

\(\newcommand {\kg }{\kilo \gram }\)

\(\newcommand {\of }[1]{_{\mathrm {#1}}}\)

\(\newcommand {\squared }{^2}\)

\(\newcommand {\square }[1]{\mathrm {#1}^2}\)

\(\newcommand {\cubed }{^3}\)

\(\newcommand {\cubic }[1]{\mathrm {#1}^3}\)

\(\newcommand {\per }{/}\)

\(\newcommand {\celsius }{\unicode {x2103}}\)

\(\newcommand {\fg }{\femto \gram }\)

\(\newcommand {\pg }{\pico \gram }\)

\(\newcommand {\ng }{\nano \gram }\)

\(\newcommand {\ug }{\micro \gram }\)

\(\newcommand {\mg }{\milli \gram }\)

\(\newcommand {\g }{\gram }\)

\(\newcommand {\kg }{\kilo \gram }\)

\(\newcommand {\amu }{\mathrm {u}}\)

\(\newcommand {\nm }{\nano \metre }\)

\(\newcommand {\um }{\micro \metre }\)

\(\newcommand {\mm }{\milli \metre }\)

\(\newcommand {\cm }{\centi \metre }\)

\(\newcommand {\dm }{\deci \metre }\)

\(\newcommand {\m }{\metre }\)

\(\newcommand {\km }{\kilo \metre }\)

\(\newcommand {\as }{\atto \second }\)

\(\newcommand {\fs }{\femto \second }\)

\(\newcommand {\ps }{\pico \second }\)

\(\newcommand {\ns }{\nano \second }\)

\(\newcommand {\us }{\micro \second }\)

\(\newcommand {\ms }{\milli \second }\)

\(\newcommand {\s }{\second }\)

\(\newcommand {\fmol }{\femto \mol }\)

\(\newcommand {\pmol }{\pico \mol }\)

\(\newcommand {\nmol }{\nano \mol }\)

\(\newcommand {\umol }{\micro \mol }\)

\(\newcommand {\mmol }{\milli \mol }\)

\(\newcommand {\mol }{\mol }\)

\(\newcommand {\kmol }{\kilo \mol }\)

\(\newcommand {\pA }{\pico \ampere }\)

\(\newcommand {\nA }{\nano \ampere }\)

\(\newcommand {\uA }{\micro \ampere }\)

\(\newcommand {\mA }{\milli \ampere }\)

\(\newcommand {\A }{\ampere }\)

\(\newcommand {\kA }{\kilo \ampere }\)

\(\newcommand {\ul }{\micro \litre }\)

\(\newcommand {\ml }{\milli \litre }\)

\(\newcommand {\l }{\litre }\)

\(\newcommand {\hl }{\hecto \litre }\)

\(\newcommand {\uL }{\micro \liter }\)

\(\newcommand {\mL }{\milli \liter }\)

\(\newcommand {\L }{\liter }\)

\(\newcommand {\hL }{\hecto \liter }\)

\(\newcommand {\mHz }{\milli \hertz }\)

\(\newcommand {\Hz }{\hertz }\)

\(\newcommand {\kHz }{\kilo \hertz }\)

\(\newcommand {\MHz }{\mega \hertz }\)

\(\newcommand {\GHz }{\giga \hertz }\)

\(\newcommand {\THz }{\tera \hertz }\)

\(\newcommand {\mN }{\milli \newton }\)

\(\newcommand {\N }{\newton }\)

\(\newcommand {\kN }{\kilo \newton }\)

\(\newcommand {\MN }{\mega \newton }\)

\(\newcommand {\Pa }{\pascal }\)

\(\newcommand {\kPa }{\kilo \pascal }\)

\(\newcommand {\MPa }{\mega \pascal }\)

\(\newcommand {\GPa }{\giga \pascal }\)

\(\newcommand {\mohm }{\milli \ohm }\)

\(\newcommand {\kohm }{\kilo \ohm }\)

\(\newcommand {\Mohm }{\mega \ohm }\)

\(\newcommand {\pV }{\pico \volt }\)

\(\newcommand {\nV }{\nano \volt }\)

\(\newcommand {\uV }{\micro \volt }\)

\(\newcommand {\mV }{\milli \volt }\)

\(\newcommand {\V }{\volt }\)

\(\newcommand {\kV }{\kilo \volt }\)

\(\newcommand {\W }{\watt }\)

\(\newcommand {\uW }{\micro \watt }\)

\(\newcommand {\mW }{\milli \watt }\)

\(\newcommand {\kW }{\kilo \watt }\)

\(\newcommand {\MW }{\mega \watt }\)

\(\newcommand {\GW }{\giga \watt }\)

\(\newcommand {\J }{\joule }\)

\(\newcommand {\uJ }{\micro \joule }\)

\(\newcommand {\mJ }{\milli \joule }\)

\(\newcommand {\kJ }{\kilo \joule }\)

\(\newcommand {\eV }{\electronvolt }\)

\(\newcommand {\meV }{\milli \electronvolt }\)

\(\newcommand {\keV }{\kilo \electronvolt }\)

\(\newcommand {\MeV }{\mega \electronvolt }\)

\(\newcommand {\GeV }{\giga \electronvolt }\)

\(\newcommand {\TeV }{\tera \electronvolt }\)

\(\newcommand {\kWh }{\kilo \watt \hour }\)

\(\newcommand {\F }{\farad }\)

\(\newcommand {\fF }{\femto \farad }\)

\(\newcommand {\pF }{\pico \farad }\)

\(\newcommand {\K }{\mathrm {K}}\)

\(\newcommand {\dB }{\mathrm {dB}}\)

\(\newcommand {\kibi }{\mathrm {Ki}}\)

\(\newcommand {\mebi }{\mathrm {Mi}}\)

\(\newcommand {\gibi }{\mathrm {Gi}}\)

\(\newcommand {\tebi }{\mathrm {Ti}}\)

\(\newcommand {\pebi }{\mathrm {Pi}}\)

\(\newcommand {\exbi }{\mathrm {Ei}}\)

\(\newcommand {\zebi }{\mathrm {Zi}}\)

\(\newcommand {\yobi }{\mathrm {Yi}}\)

\(\require {mhchem}\)

\(\require {cancel}\)

\(\newcommand {\fint }{âĺŊ}\)

\(\newcommand {\hdots }{\cdots }\)

\(\newcommand {\mathnormal }[1]{#1}\)

\(\newcommand {\vecs }[2]{\vec {#1}_{#2}}\)

\(\renewcommand {\O }{\ensuremath {\mathcal {O}}}\)

\(\renewcommand {\P }{\ensuremath {\mathcal {P}}}\)

\(\newcommand {\Abl }{\ensuremath {\text {Abl}}}\)

\(\newcommand {\REG }{\ensuremath {\text {REG}}}\)

\(\newcommand {\CFL }{\ensuremath {\text {CFL}}}\)

\(\newcommand {\DCFL }{\ensuremath {\text {DCFL}}}\)

\(\newcommand {\DEA }{\ensuremath {\text {DEA}}}\)

\(\newcommand {\NEA }{\ensuremath {\text {NEA}}}\)

\(\newcommand {\DTM }{\ensuremath {\text {DTM}}}\)

\(\newcommand {\NTM }{\ensuremath {\text {NTM}}}\)

\(\newcommand {\LBA }{\ensuremath {\text {LBA}}}\)

\(\newcommand {\coLBA }{\ensuremath {\text {co-LBA}}}\)

\(\newcommand {\DLBA }{\ensuremath {\text {DLBA}}}\)

\(\newcommand {\TypNull }{\ensuremath {\text {Typ-0}}}\)

\(\newcommand {\RegExp }{\ensuremath {\text {RegExp}}}\)

\(\newcommand {\Synt }{\ensuremath {\text {Synt}}}\)

\(\newcommand {\dollar }{\ensuremath {\$}}\)

\(\newcommand {\FOR }{\ensuremath {\mathbf {for}\;}}\)

\(\newcommand {\FORALL }{\ensuremath {\mathbf {forall}\;}}\)

\(\newcommand {\REPEAT }{\ensuremath {\mathbf {repeat}\;}}\)

\(\newcommand {\UNTIL }{\ensuremath {\mathbf {until}\;}}\)

\(\newcommand {\OR }{\ensuremath {\mathbf {or}\;}}\)

\(\newcommand {\IF }{\ensuremath {\mathbf {if}\;}}\)

\(\newcommand {\THEN }{\ensuremath {\mathbf {then}\;}}\)

\(\newcommand {\ELSE }{\ensuremath {\mathbf {else}\;}}\)

\(\newcommand {\END }{\ensuremath {\mathbf {end}\;}}\)

\(\newcommand {\TO }{\ensuremath {\mathbf {to}\;}}\)

\(\newcommand {\DO }{\ensuremath {\mathbf {do}\;}}\)

\(\newcommand {\name }[1]{\textsc {#1}}\)

\(\newcommand {\smallpmatrix }[1]{\left (\begin {smallmatrix}#1\end {smallmatrix}\right )}\)

\(\newcommand {\matlab }{{\fontfamily {bch}\scshape \selectfont {}Matlab}}\)

\(\newcommand {\innerproduct }[1]{\left \langle {#1}\right \rangle }\)

\(\newcommand {\norm }[1]{\left \Vert {#1}\right \Vert }\)

\(\renewcommand {\natural }{\mathbb {N}}\)

\(\newcommand {\integer }{\mathbb {Z}}\)

\(\newcommand {\rational }{\mathbb {Q}}\)

\(\newcommand {\real }{\mathbb {R}}\)

\(\newcommand {\complex }{\mathbb {C}}\)

\(\renewcommand {\d }{\mathop {}\!\mathrm {d}}\)

\(\newcommand {\dr }{\d {}r}\)

\(\newcommand {\ds }{\d {}s}\)

\(\newcommand {\dt }{\d {}t}\)

\(\newcommand {\du }{\d {}u}\)

\(\newcommand {\dv }{\d {}v}\)

\(\newcommand {\dw }{\d {}w}\)

\(\newcommand {\dx }{\d {}x}\)

\(\newcommand {\dy }{\d {}y}\)

\(\newcommand {\dz }{\d {}z}\)

\(\newcommand {\dsigma }{\d {}\sigma }\)

\(\newcommand {\dphi }{\d {}\phi }\)

\(\newcommand {\dvarphi }{\d {}\varphi }\)

\(\newcommand {\dtau }{\d {}\tau }\)

\(\newcommand {\dxi }{\d {}\xi }\)

\(\newcommand {\dtheta }{\d {}\theta }\)

\(\newcommand {\tp }{\mathrm {T}}\)

</div>

<style type="text/css">
.lwarp-contents li.list-item-f0::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f1::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f2::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f3::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f4::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f5::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f6::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f7::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f8::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f9::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f10::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f11::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f12::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f13::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f14::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f15::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f16::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f17::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f18::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f19::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f20::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f21::marker {
  content:'•\00a0\00a0';
}
.lwarp-contents li.list-item-f22::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f23::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f24::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f25::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f26::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f27::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f28::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f29::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f30::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
.lwarp-contents li.list-item-f31::marker {
  font-style:italic;
  content:'(4)\00a0\00a0';
}
.lwarp-contents li.list-item-f32::marker {
  font-style:italic;
  content:'(1)\00a0\00a0';
}
.lwarp-contents li.list-item-f33::marker {
  font-style:italic;
  content:'(2)\00a0\00a0';
}
.lwarp-contents li.list-item-f34::marker {
  font-style:italic;
  content:'(3)\00a0\00a0';
}
</style>
<p>

</p>



<h2 id="deterministische-automaten">Deterministische Automaten</h2>

</p>


<p>
<em>Bemerkung</em>: Wa&#x0308;hrend Grammatiken mit vordefinierten Regeln Wo&#x0308;rter einer Sprache <em>erzeugen</em> ko&#x0308;nnen, tun Automaten in gewisser Weise das Gegenteil. Automaten
<em>erkennen</em> Wo&#x0308;rter, d.&#x202f;h. man gibt ein Wort ein und der Automat gibt zuru&#x0308;ck, ob das Wort erkannt wurde (zu einer bestimmten Sprache geho&#x0308;rt) oder nicht.<br />
Das Ziel der folgenden Abschnitte wird es sein zu zeigen, dass DEAs dasselbe „ko&#x0308;nnen“ wie Typ-3-Grammatiken. Dafu&#x0308;r wird das Hilfsmittel des NEAs eingefu&#x0308;hrt, der ebenfalls genau so viel kann wie
DEAs.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>deterministischer endlicher Automat (DEA)</b>:&#x2003;<br />
Ein <em><span class="dashuline" >deterministischer endlicher Automat (DEA)</span></em> oder <em><span class="dashuline" >DFA</span></em> ist ein \(5\)-Tupel \(M = (Z, \Sigma , \delta , z_0, E)\) mit
</p>
<ul style="list-style-type:none">

<li class="list-item-f0"><p>\(Z\) einer endlichen, nicht-leeren Menge (die Menge der <em><span class="dashuline" >Zusta&#x0308;nde</span></em>),
</p>
</li>
<li class="list-item-f1"><p>\(\Sigma \) einer endlichen, nicht-leeren Menge mit \(Z \cap \Sigma = \emptyset \) (das <em><span class="dashuline" >Alphabet</span></em>),
</p>
</li>
<li class="list-item-f2"><p>\(\delta \colon Z \times \Sigma \rightarrow Z\) (die <em><span class="dashuline" >U&#x0308;berfu&#x0308;hrungsfunktion</span></em>),
</p>
</li>
<li class="list-item-f3"><p>\(z_0 \in Z\) (der <em><span class="dashuline" >Startzustand</span></em>) und
</p>
</li>
<li class="list-item-f4"><p>\(E \subset Z\) (die <em><span class="dashuline" >akzeptierenden Endzusta&#x0308;nde</span></em>).
</p>
</li>
</ul>

<p>
<em>Bemerkung</em>: Bildhaft kann man sich einen Automat vorstellen als eine Maschine, die von einem endlichen Eingabeband Zeichen fu&#x0308;r Zeichen einliest. Die Maschine hat einen Lesekopf, der sich zu Beginn am Anfang
des Eingabebands befindet, und speichert sich den aktuellen Zustand \(q\), der anfangs \(z_0\) ist. Die Maschine liest ein Zeichen \(y\) und ermittelt durch \(\delta (q, y)\) den Zustand, der als na&#x0308;chstes angenommen
wird. Diesen speichert sie sich als neuen Zustand und setzt den Lesekopf um ein Zeichen weiter. Ist das Ende das Bands erreicht, so zeigt die Maschine an, ob der erreichte Zustand \(q\) ein Endzustand ist (d.&#x202f;h. \(q \in
E\)).
</p>

<p>
<em>Bemerkung</em>: Automaten kann man durch gerichtete, beschriftete Graphen (den <em><span class="dashuline" >Zustandsgraphen</span></em>) darstellen. Die Zusta&#x0308;nde entsprechen den Knoten. Der dem
Startzustand entsprechende Knoten wird durch einen eingehenden Pfeil („aus dem Nichts“) besonders markiert. Endzusta&#x0308;nde werden durch doppelte Kreise gekennzeichnet. Die Kanten veranschaulichen \(\delta \):<br
/>
Fu&#x0308;r alle \(z_1 \in Z\) und \(a \in \Sigma \) geht eine mit \(a\) beschriftete Kante von \(z_1\) nach \(z_2 = \delta (z_1, a)\).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>akzeptierte Sprache</b>:&#x2003; Sei \(M = (Z, \Sigma , \delta , z_0, E)\) ein DEA.<br />
Man definiert induktiv die Abbildung \(\widehat {\delta }\colon Z \times \Sigma ^\ast \rightarrow Z\) durch \(\widehat {\delta }(z, \varepsilon ) := z\) fu&#x0308;r alle \(z \in Z\)<br />
und \(\widehat {\delta }(z, ax) := \widehat {\delta }(\delta (z, a), x)\) fu&#x0308;r alle \(z \in Z\), \(a \in \Sigma \) und \(x \in \Sigma ^\ast \).<br />
Die von \(M\) <em><span class="dashuline" >akzeptierte Sprache</span></em> ist \(T(M) := \{x \in \Sigma ^\ast \;|\; \widehat {\delta }(z_0, x) \in E\}\).
</p>

<p>
<em>Bemerkung</em>: Die Abbildung \(\widehat {\delta }\) gibt an, in welchen Zustand man gelangt, wenn man von einem bestimmten Zustand startet und ein Wort aus \(\Sigma ^\ast \) eingelesen wird. In der Tat gilt<br />
\(\widehat {\delta }(z, a_1 \dotsb a_n) = z’ \;\Leftrightarrow \; \exists _{q_1, \dotsc , q_n \in Z}\; \delta (z, a_1) = q_1,\; \delta (q_i, a_{i+1}) = q_{i+1}, i = 1, \dotsc , n - 1, q_n =
z’\).<br />
Außerdem folgt aus \(x, y \in \Sigma ^\ast \), dass \(\widehat {\delta }(z, xy) = \widehat {\delta }(\widehat {\delta }(z, x), y)\) fu&#x0308;r alle \(z \in Z\).<br />
Diese Aussagen folgen direkt aus \(\widehat {\delta }(z, a_1 \dotsb a_n) = \delta (\delta (\dotsb \delta (\delta (z, a_1), a_2)\dotsb , a_{n-1}), a_n)\), was man induktiv beweisen kann.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>\(\DEA \)</b>:&#x2003; Die Menge \(\DEA := \{L \subset \Sigma ^\ast \;|\; \exists _{\text {det. endl. Automat } M}\; T(M) = L\}\) ist die Menge aller Sprachen, die von DEAs akzeptiert werden.
</p>

<p>
<b>\(\REG \)</b>:&#x2003; Die Menge \(\REG := \{L \subset \Sigma ^\ast \;|\; \exists _{\text {Typ-3-Grammatik } G}\; L(G) = L\}\) ist die Menge aller Typ-3-Sprachen.
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >obere Schranke fu&#x0308;r DEA</span>):</span> Es gilt \(\DEA \subset \REG \)<br />
(d.&#x202f;h. fu&#x0308;r jeden DEA \(M\) gibt es eine Typ-3-Grammatik \(G\) mit \(L(G) = T(M)\)).
</p>

<p>
<b>Beweis</b>: Sei \(M = (Z, \Sigma , \delta , z_0, E)\) ein DEA. Definiere \(G = (V, \Sigma , P, S)\) mit \(V = Z\), \(S = z_0\) und \(P\) wie folgt: Fu&#x0308;r alle \(p, q \in Z\) und \(a \in \Sigma \) mit
\(q = \delta (p, a)\) wird die Regel \(p \rightarrow aq\) in \(P\) aufgenommen. Ist zusa&#x0308;tzlich \(q \in E\), so wird auch noch \(p \rightarrow a\) in \(P\) aufgenommen. \(G\) ist regula&#x0308;r.
</p>

<p>
Zu zeigen ist \(T(M) = L(G)\). Sei \(x = a_1 \dotsb a_n\). Dann gilt \(x \in T(M) \iff \widehat {\delta }(z_0, x) \in E\)<br />
\(\iff \exists _{q_1, \dotsc , q_n \in Z}\; \delta (z_0, a_1) = q_1,\; \delta (q_i, a_{i+1}) = q_{i+1}\; (i = 1, \dotsc , n - 1),\; q_n \in E\)<br />
\(\iff \exists _{q_1, \dotsc , q_n \in V}\; z_0 \rightarrow a_1 q_1 \in P,\; q_i \rightarrow a_{i+1} q_{i+1} \in P\; (i = 1, \dotsc , n - 1),\; q_{n-1} \rightarrow a_n \in P\)<br />
\(\iff \exists _{q_1, \dotsc , q_n \in V}\; z_0 \Rightarrow _G a_1 q_1 \Rightarrow _G a_1 a_2 q_2 \Rightarrow _G \dotsb \Rightarrow _G a_1 a_2 \dotsb a_{n-1} q_{n-1} \Rightarrow _G a_1 a_2
\dotsb a_{n-1} a_n = x\)<br />
\(\iff x \in L(G)\). &#x2003;&#x2003;
</p>



<h2 id="nichtdeterministische-automaten">Nichtdeterministische Automaten</h2>

</p>


<p>
<b>nichtdeterministischer endlicher Automat (NEA)</b>:&#x2003; Ein <em><span class="dashuline" >nichtdeterministischer<br />
endlicher Automat (NEA)</span></em> oder <em><span class="dashuline" >NFA</span></em> ist ein \(5\)-Tupel \(M = (Z, \Sigma , \delta , Z_0, E)\), wobei
</p>
<ul style="list-style-type:none">

<li class="list-item-f5"><p>\(Z\) eine endliche, nicht-leere Menge (die Menge der <em><span class="dashuline" >Zusta&#x0308;nde</span></em>),
</p>
</li>
<li class="list-item-f6"><p>\(\Sigma \) eine endliche, nicht-leere Menge mit \(Z \cap \Sigma = \emptyset \) (das <em><span class="dashuline" >Alphabet</span></em>),
</p>
</li>
<li class="list-item-f7"><p>\(\delta \colon Z \times \Sigma \rightarrow \P (Z)\) (die <em><span class="dashuline" >U&#x0308;berfu&#x0308;hrungsfunktion</span></em>),
</p>
</li>
<li class="list-item-f8"><p>\(Z_0 \subset Z\) (die <em><span class="dashuline" >Startzusta&#x0308;nde</span></em>) und
</p>
</li>
<li class="list-item-f9"><p>\(E \subset Z\) (die <em><span class="dashuline" >akzeptierenden Endzusta&#x0308;nde</span></em>).
</p>
</li>
</ul>

<p>
<em>Bemerkung</em>: Auch NEAs ko&#x0308;nnen durch Zustandsgraphen dargestellt werden. Es gibt nun jedoch evtl. mehrere Startzusta&#x0308;nde und von jedem Knoten ko&#x0308;nnen mehrere mit demselben Buchstaben
beschriftete Kanten ausgehen (oder auch keine).
</p>

<p>
<b>akzeptierte Sprache</b>:&#x2003; Sei \(M = (Z, \Sigma , \delta , z_0, E)\) ein NEA.<br />
Man definiert induktiv die Abbildung \(\widehat {\delta }\colon \P (Z) \times \Sigma ^\ast \rightarrow \P (Z)\) durch \(\widehat {\delta }(Q, \varepsilon ) := Q\) fu&#x0308;r alle \(Q \subset Z\) und
\(\widehat {\delta }(Q, ax) := \bigcup _{q \in Q} \widehat {\delta }(\delta (q, a), x)\) fu&#x0308;r alle \(Q \subset Z\), \(a \in \Sigma \) und \(x \in \Sigma ^\ast \).<br />
Die von \(M\) <em><span class="dashuline" >akzeptierte Sprache</span></em> ist \(T(M) := \{x \in \Sigma ^\ast \;|\; \widehat {\delta }(Z_0, x) \cap E \not = \emptyset \}\).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>\(\NEA \)</b>:&#x2003; Die Menge \(\NEA := \{L \subset \Sigma ^\ast \;|\; \exists _{\text {nichtdet. endl. Automat } M}\; T(M) = L\}\) ist die Menge aller Sprachen, die von NEAs akzeptiert werden.
</p>

<p>
<em>Bemerkung</em>: Es ist klar, dass \(\DEA \subset \NEA \) gilt.
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >Satz von <span class="textsc" >Rabin</span> und <span class="textsc" >Scott</span></span>):</span> Es gilt \(\NEA \subset \DEA \)<br />
(d.&#x202f;h. fu&#x0308;r jeden NEA \(M\) gibt es einen DEA \(M’\) mit \(T(M’) = T(M)\)).
</p>

<p>
<b>Beweis</b>: Sei \(M = (Z, \Sigma , \delta , Z_0, E)\) ein NEA. Definiere den DEA \(M’ = (\P (Z), \Sigma , \delta ’, Z_0, E’)\) wie folgt: \(\delta ’(Q, a) := \widehat {\delta }(Q, a) = \bigcup _{q
\in Q} \delta (q, a)\) und \(E’ := \{Q \in \P (Z) \;|\; Q \cap E \not = \emptyset \}\).
</p>

<p>
Zuna&#x0308;chst beweist man folgendes Lemma: Fu&#x0308;r alle \(Q \subset Z\) und \(w \in \Sigma ^\ast \) gilt \(\widehat {\delta }(Q, w) = \widehat {\delta ’}(Q, w)\).<br />
Der Beweis erfolgt u&#x0308;ber Induktion u&#x0308;ber \(n = |w| \in \natural _0\).<br />
Der Induktionsanfang ist klar (\(Q = \widehat {\delta }(Q, \varepsilon ) = \widehat {\delta ’}(Q, \varepsilon ) = Q\)).<br />
Beim Induktionsschritt \(n \rightarrow n + 1\) ist die Induktionsvoraussetzung, dass \(\widehat {\delta }(Q, x) = \widehat {\delta ’}(Q, x)\) fu&#x0308;r alle \(Q \subset Z\) und \(x \in \Sigma ^\ast \) mit
\(|x| \le n\). Fu&#x0308;r beliebige \(P \subset Z\) und \(a \in \Sigma \) gilt somit<br />
\(\widehat {\delta }(P, ax) = \widehat {\delta }(\delta (P, a), x) = \widehat {\delta ’}(\delta (P, a), x) = \widehat {\delta ’}(\widehat {\delta }(P, a), x) = \widehat {\delta ’}(\delta ’(P,
a), x) = \widehat {\delta ’}(P, ax)\).
</p>

<p>
Zu zeigen ist \(T(M) = T(M’)\). Mit der Hilfsbehauptung ergibt sich<br />
\(w \in T(M) \iff \widehat {\delta }(Z_0, w) \cap E \not = \emptyset \iff \widehat {\delta ’}(Z_0, w) \cap E \not = \emptyset \iff \widehat {\delta ’}(Z_0, w) \in E’\)<br />
\(\iff w \in T(M’)\). &#x2003;&#x2003;
</p>

<p>
<em>Bemerkung</em>: Somit ist \(\DEA = \NEA \), d.&#x202f;h. DEAs und NEAs „ko&#x0308;nnen“ dasselbe.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Potenzmengenkonstruktion</b>:&#x2003; Die Konstruktion eines DEA \(M’\) aus einem NEA \(M\) mit \(L(M’) = L(M)\) wie im Beweis vom Satz von Rabin und Scott bezeichnet man als<br />
<em><span class="dashuline" >Potenzmengenkonstruktion</span></em>.
</p>

<p>
<em>Bemerkung</em>: Fu&#x0308;r \(M = (Z, \Sigma , \delta , Z_0, E)\) hat \(M’\) dann \(|\P (Z)| = 2^{|Z|}\) viele Zusta&#x0308;nde.<br />
Im Allgemeinen geht es nicht viel besser, d.&#x202f;h. selbst minimale DEAs haben \(\O (2^{|Z|})\) viele Zusta&#x0308;nde (<em><span class="dashuline" >Blow-Up</span></em>). Betrachte dafu&#x0308;r die Sprache
\(L_k = \{x0y \in \{0, 1\}^\ast \;|\; |y| = k - 1\}\) fu&#x0308;r \(k \in \natural \) fest. Ein NEA la&#x0308;sst sich mit \(k + 1\) Zusta&#x0308;nden konstruieren.<br />
Nach der Potenzmengenkonstruktion gibt es einen DEA mit \(2^{k+1}\) Zusta&#x0308;nden, allerdings kann es keinen DEA geben, der weniger als \(2^k\) Zusta&#x0308;nde besitzt, da dieser sich die letzten \(k\) Buchstaben
„merken“ muss (um zu entscheiden, ob der momentan \(k\)-letzte Buchstabe eine \(0\) ist).<br />
Um dies zu beweisen, zeigt man \(\widehat {\delta }(z_0, w_1) \not = \widehat {\delta }(z_0, w_2)\) fu&#x0308;r \(w_1 \not = w_2\) mit \(|w_1| = |w_2| = k\) (somit muss es mindestens so viele
Zusta&#x0308;nde geben wie Wo&#x0308;rter der La&#x0308;nge \(k\)). Wegen \(w_1 \not = w_2\) gilt \(w_1 = x0y_1\) und \(w_2 = x1y_2\) fu&#x0308;r bestimmte \(x, y_1, y_2 \in \Sigma ^\ast \). Wa&#x0308;re
\(\widehat {\delta }(z_0, w_1) = \widehat {\delta }(z_0, w_2)\), dann wa&#x0308;re \(\widehat {\delta }(z_0, w_1 x) = \widehat {\delta }(z_0, w_2 x)\). Der \(k\)-letzte Buchstabe von \(w_1 x\) ist \(0\)
(da \(|0y_1 x| = |x0y_1| = k\)), der von \(w_2 x\) ist \(1\), d.&#x202f;h. \(\widehat {\delta }(z_0, w_1 x) \in E\) und \(\widehat {\delta }(z_0, w_2 x) \notin E\), ein Widerspruch.
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >obere Schranke fu&#x0308;r \(\REG \)</span>):</span> Es gilt \(\REG \subset \NEA \)<br />
(d.&#x202f;h. fu&#x0308;r jede Typ-3-Grammatik \(G\) existiert ein NEA \(M\) mit \(T(M) = L(G)\)).
</p>

<p>
<b>Beweis</b>: Sei \(G = (V, \Sigma , P, S)\) eine Typ-3-Grammatik. Definiere den NEA<br />
\(M = (V \cup \{X\}, \Sigma , \delta , \{S\}, E)\) mit \(X \notin V\) durch<br />
\(E := \{X\}\) fu&#x0308;r \(\varepsilon \notin L(G)\) und \(E := \{S, X\}\) fu&#x0308;r \(\varepsilon \in L(G)\) sowie<br />
\(\delta (A, a) := \{B \in V \;|\; A \rightarrow aB \in P\}\) fu&#x0308;r \(A \rightarrow a \notin P\) und<br />
\(\delta (A, a) := \{B \in V \;|\; A \rightarrow aB \in P\} \cup \{X\}\) fu&#x0308;r \(A \rightarrow a \in P\).
</p>

<p>
Man kann sich leicht u&#x0308;berlegen, dass \(T(M) = L(G)\). &#x2003;&#x2003;
</p>

<p>
<em>Bemerkung</em>: Damit gilt \(\REG = \DEA = \NEA \).
</p>



<h2 id="regulaere-ausdruecke">Reguläre Ausdrücke</h2>

</p>


<p>
<b>regula&#x0308;re Ausdru&#x0308;cke</b>:&#x2003; Sei \(\Sigma \) ein Alphabet.<br />
Die Menge \(\RegExp \) aller <em><span class="dashuline" >regula&#x0308;ren Ausdru&#x0308;cke</span></em> u&#x0308;ber \(\Sigma \) ist wie folgt definiert:
</p>
<ul style="list-style-type:none">

<li class="list-item-f10"><p>\(\emptyset \in \RegExp \)
</p>
</li>
<li class="list-item-f11"><p>\(\varepsilon \in \RegExp \)
</p>
</li>
<li class="list-item-f12"><p>\(a \in \RegExp \) fu&#x0308;r alle \(a \in \Sigma \)
</p>
</li>
</ul>

<p>
Diese regula&#x0308;ren Ausdru&#x0308;cke heißen <em><span class="dashuline" >atomar</span></em>. Fu&#x0308;r \(\alpha , \beta \in \RegExp \) sei:
</p>
<ul style="list-style-type:none">

<li class="list-item-f13"><p>\(\alpha \beta \in \RegExp \)
</p>
</li>
<li class="list-item-f14"><p>\((\alpha |\beta ) \in \RegExp \)
</p>
</li>
<li class="list-item-f15"><p>\((\alpha )^\ast \in \RegExp \)
</p>
</li>
</ul>

<p>
Klammern du&#x0308;rfern ggf. weggelassen werden.<br />
(Rein formal definiert man \(\RegExp _0 := \{\emptyset , \varepsilon \} \cup \{a \;|\; a \in \Sigma \}\) und \(\RegExp _{i+1} :=\)<br />
\(\RegExp _i \cup \{\alpha \beta \;|\; \alpha , \beta \in \RegExp _i\} \cup \{(\alpha |\beta ) \;|\; \alpha , \beta \in \RegExp _i\} \cup \{(\alpha )^\ast \;|\; \alpha \in \RegExp _i\}\)
fu&#x0308;r \(i \in \natural _0\) und schließlich \(\RegExp := \bigcup _{i=0}^\infty \RegExp _i\).)
</p>

<p>
\(\emptyset \), \(\varepsilon \) und \(a\) sind zuna&#x0308;chst einmal nur Zeichen ohne Bedeutung (syntaktische Definition).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Semantik regula&#x0308;rer Ausdru&#x0308;cke</b>:&#x2003;<br />
Jedem regula&#x0308;ren Ausdruck \(\alpha \in \RegExp \) u&#x0308;ber \(\Sigma \) ordnet man eine Sprache \(L(\alpha ) \subset \Sigma ^\ast \) zu:
</p>
<ul style="list-style-type:none">

<li class="list-item-f16"><p>\(L(\emptyset ) := \emptyset \)
</p>
</li>
<li class="list-item-f17"><p>\(L(\varepsilon ) := \{\varepsilon \}\)
</p>
</li>
<li class="list-item-f18"><p>\(L(a) := \{a\}\) fu&#x0308;r alle \(a \in \Sigma \)
</p>
</li>
</ul>

<p>
Außerdem sei fu&#x0308;r \(\alpha , \beta \in \RegExp \):
</p>
<ul style="list-style-type:none">

<li class="list-item-f19"><p>\(L(\alpha \beta ) := L(\alpha ) L(\beta ) = \{xy \;|\; x \in L(\alpha ),\; y \in L(\beta )\}\)
</p>
</li>
<li class="list-item-f20"><p>\(L((\alpha |\beta )) := L(\alpha ) \cup L(\beta )\)
</p>
</li>
<li class="list-item-f21"><p>\(L((\alpha )^\ast ) := L(\alpha )^\ast = \{a_1 \dotsc a_n \;|\; n \in \natural _0, a_1, \dotsc , a_n \in L(\alpha )\}\)
</p>
</li>
</ul>

<p>
<em>Bemerkung</em>: Es gilt \(\varepsilon \in L(\alpha )^\ast \) fu&#x0308;r alle \(\alpha \in \RegExp \), d.&#x202f;h. insbesondere \(\varepsilon \in L(\emptyset )^\ast \).<br />
Beispiele fu&#x0308;r korrekte regula&#x0308;re Ausdru&#x0308;cke u&#x0308;ber \(\{0, 1\}\) sind \(0111010\), \(11|0^\ast \) und \((11|0)^\ast \) (man beachte die Klammerung).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >Satz von &#x202f;<span class="textsc" >Kleene</span></span>):</span><br />
Die Menge der durch regula&#x0308;re Ausdru&#x0308;cke beschreibbaren Sprachen ist gleich \(\REG \).
</p>

<p>
<b>Beweis</b>: Sei \(\gamma \in \RegExp \). Man zeigt induktiv, dass es einen NEA \(M\) gibt mit \(T(M) = L(\gamma )\).<br />
NEAs fu&#x0308;r \(L(\emptyset ) = \emptyset \), \(L(\varepsilon ) = \{\varepsilon \}\) und \(L(a) = \{a\}\) sind klar (kein Endzustand, Anfangs- gleich Endzustand bzw. einfacher Automat mit zwei
Zusta&#x0308;nden).<br />
Seien also \(M_1\) ein NEA fu&#x0308;r \(L(\alpha )\) und \(M_2\) ein NEA fu&#x0308;r \(L(\beta )\). Konstruiere einen NEA fu&#x0308;r \(L(\alpha )L(\beta )\) durch Zusammenschalten der zwei NEAs: Fu&#x0308;r
\(\varepsilon \notin L(\alpha )\) wird jeder U&#x0308;bergang \(p \xrightarrow {a} e\) mit \(e\) Endzustand in \(M_1\) erga&#x0308;nzt durch \(p \xrightarrow {a} q\) fu&#x0308;r alle Startzusta&#x0308;nde
\(q\) von \(M_2\). Startzusta&#x0308;nde des neuen Automaten sind die von \(M_1\), Endzusta&#x0308;nde sind die von \(M_2\). Fu&#x0308;r \(\varepsilon \in L(M_1)\) fu&#x0308;gt man einen zusa&#x0308;tzlichen
(isolierten) Zustand ein, der gleichzeitig Start- und Endzustand ist.<br />
Fu&#x0308;r \(L(\alpha ) \cup L(\beta )\) „vereinigt“ man die beiden Automaten (Zusta&#x0308;nde, Startzusta&#x0308;nde, Endzusta&#x0308;nde usw., Annahme: Automaten sind disjunkt).<br />
Fu&#x0308;r \((L(\alpha ))^\ast \) verfa&#x0308;hrt man a&#x0308;hnlich wie fu&#x0308;r \(L(\alpha )L(\beta )\), nur dass man hier den Automaten \(L_1\) mit sich selbst zusammenschaltet.
</p>

<p>
Fu&#x0308;r die andere Richtung geht man von einem DEA \(M = (Z, \Sigma , \delta , z_1, E)\) mit \(Z = \{z_1, \dotsc , z_n\}\) aus und konstruiert einen regula&#x0308;ren Ausdruck \(\gamma \in \RegExp \) mit
\(L(\gamma ) = T(M)\).<br />
Definiere \(R_{i,j}^k := \{x \in \Sigma ^\ast \;|\; \widehat {\delta }(z_i, x) = z_j \text { über Zwischenzustände mit Index} \le k\}\).<br />
Man zeigt nun durch Induktion u&#x0308;ber \(k \in \natural _0\), dass es fu&#x0308;r alle \(R_{i,j}^k\) regula&#x0308;re Ausdru&#x0308;cke gibt, die diese Sprachen beschreiben. Klar ist, dass fu&#x0308;r alle
\(R_{i,j}^0\) solche regula&#x0308;ren Ausdru&#x0308;cke existieren, da \(R_{i,j}^0 = \{a \in \Sigma \;|\; \delta (z_i, a) = z_j\}\) endlich und somit durch regula&#x0308;re Ausdru&#x0308;cke beschreibbar
ist.<br />
Wenn fu&#x0308;r alle \(R_{i,j}^k\) die Behauptung gezeigt ist, dann gilt sie auch fu&#x0308;r \(R_{i,j}^{k+1}\), denn:<br />
Fu&#x0308;r \(w \in R_{i,j}^{k+1}\) ist \(\widehat {\delta }(z_i, w) = z_j\) u&#x0308;ber Zwischenzusta&#x0308;nde mit Index \(\le k + 1\). Fu&#x0308;r den Fall, dass die Zwischenzusta&#x0308;nde sogar alle
Index \(\le k\) besitzen, la&#x0308;sst sich die Induktionsvoraussetzung direkt anwenden. Andernfalls la&#x0308;sst sich \(w\) zerlegen zu \(w = w_1 x_1 \dotsb x_r w_2\) mit \(w_1 \in R_{i,k+1}^k\), \(w_2 \in
R_{k+1,j}^k\) und \(x_i \in R_{k+1,k+1}^k\) fu&#x0308;r \(i = 1, \dotsc , r\). Also gilt \(R_{i,j}^{k+1} = R_{i,j}^k \cup R_{i,k+1}^k (R_{k+1,k+1}^k)^\ast R_{k+1,j}^k\) und die Induktionsvoraussetzung
la&#x0308;sst sich anwenden.<br />
Da \(T(M) = \bigcup _{z_j \in E} R_{1,j}^n\) gilt, ist somit auch \(T(M)\) durch einen regula&#x0308;ren Ausdruck \(\gamma \in \RegExp \) beschreibbar (mittels \((\dotsb |\dotsb )\)). &#x2003;&#x2003;
</p>



<h2 id="das-pumping-lemma">Das Pumping-Lemma</h2>

</p>


<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >Pumping-Lemma</span>):</span> Sei \(L \subset \Sigma ^\ast \) eine regula&#x0308;re Sprache.<br />
Dann gilt \(\exists _{n \in \natural } \forall _{x \in L,\; |x| \ge n} \exists _{u, v, w \in \Sigma ^\ast ,\; uvw = x}\; (1. \land 2. \land 3.)\) mit
</p>
<ul style="list-style-type:none">

<li class="list-item-f22"><p>\(|v| \ge 1\)
</p>
</li>
<li class="list-item-f23"><p>\(|uv| \le n\)
</p>
</li>
<li class="list-item-f24"><p>\(\forall _{i \in \natural _0}\; u v^i w \in L\)
</p>
</li>
</ul>

<p>
<b>Beweis</b>: Sei \(L\) eine regula&#x0308;re Sprache. Dann gibt es wegen \(\REG = \DEA \) einen DEA<br />
\(M = (Z, \Sigma , \delta , z_0, E)\) mit \(L(M) = L\). Setze \(n := |Z|\).<br />
Sei \(x \in L\) mit \(|x| \ge n\), z.&#x202f;B. \(x = x_1 \dotsb x_m\) mit \(m \ge n\). Setze \(q_j := \widehat {\delta }(z_0, x_1 \dotsb x_j)\) fu&#x0308;r \(j = 0, \dotsc , m\). Unter den \(n + 1\)
Zusta&#x0308;nden \(q_0, \dotsc , q_n\) mu&#x0308;ssen zwei gleiche sein, da \(|Z| = n\). Wa&#x0308;hle \(j, k \in \natural _0\), sodass \(0 \le j &lt; k \le n\) und \(q_j = q_k\). Setze \(u := x_1 \dotsb
x_j\), \(v := x_{j+1} \dotsb x_k\) und \(w := x_{k+1} \dotsb x_m\).
</p>

<p>
Es gilt \(x = uvw\) und
</p>
<ul style="list-style-type:none">

<li class="list-item-f25"><p>\(|v| \ge 1\), da \(j &lt; k\) und somit \(x_{j+1} \dotsb x_k \not = \varepsilon \),
</p>
</li>
<li class="list-item-f26"><p>\(|uv| \le n\), da \(k \le n\), sowie
</p>
</li>
<li class="list-item-f27"><p>\(\forall _{i \in \natural _0}\; u v^i w \in L\), da aus \(\widehat {\delta }(z_0, u) = q_j = q_k = \widehat {\delta }(z_0, uv) = \widehat {\delta }(\widehat {\delta }(z_0, u), v)\)
mit \(p := \widehat {\delta }(z_0, u)\) folgt, dass \(\widehat {\delta }(p, v) = p\), also \(\widehat {\delta }(p, v^i) = p\) fu&#x0308;r alle \(i \in \natural _0\). Wegen \(\widehat {\delta }(p, w) =
\widehat {\delta }(z_0, uvw) \in E\) gilt somit \(\widehat {\delta }(z_0, u v^i w) = \widehat {\delta }(\widehat {\delta }(p, v^i), w) = \widehat {\delta }(p, w) \in E\) fu&#x0308;r alle \(i \in
\natural _0\).
</p>
</li>
</ul>

<p>
&#x2003;&#x2003;

<p>
<em>Bemerkung</em>: Das Pumping-Lemma ist keine Charakterisierung von regula&#x0308;ren Sprachen, d.&#x202f;h. es gibt nicht-regula&#x0308;re Sprachen, die trotzdem die Eigenschaft des Pumping-Lemmas
erfu&#x0308;llen.<br />
Das Pumping-Lemma kann benutzt werden, um u&#x0308;ber einen Widerspruch die Nicht-Regula&#x0308;rita&#x0308;t von Sprachen zu beweisen. (Auch dies geht nicht fu&#x0308;r alle nicht-regula&#x0308;ren Sprachen.)
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<em>Beispiel</em>: \(L = \{a^m b^m \;|\; m \ge 1\}\) ist nicht regula&#x0308;r, denn andernfalls ga&#x0308;be es nach dem Pumping-Lemma ein \(n \in \natural \), sodass fu&#x0308;r alle Wo&#x0308;rter \(x \in
L\) mit \(|x| \ge n\) es Wo&#x0308;rter \(u, v, w \in \Sigma ^\ast \) mit \(uvw = x\) und 1., 2. und 3. geben wu&#x0308;rde. Wa&#x0308;hlt man \(x = a^n b^n \in L\) (es gilt \(|a^n b^n| = 2n \ge n\)), dann gilt
\(a^n b^n = uvw\) mit \(|v| \ge 1\) und \(|uv| \le n\). \(v\) kann also nur aus \(a\)’s bestehen (mindestens jedoch aus einem \(a\)). Es gilt allerdings \(uv^2 w = a^{n + |v|} b^n \notin L\), da \(n + |v| &gt; n\),
somit gilt 3. nicht.
</p>

<p>
<em>Beispiel</em>: \(L = \{0^{m^2} \;|\; m \ge 1\}\) ist nicht regula&#x0308;r, denn andernfalls gilt A&#x0308;hnliches wie eben. Wa&#x0308;hlt man \(x = 0^{n^2} \in L\) (es gilt \(|0^{n^2}| = n^2 \ge n\)), dann
gilt \(0^{n^2} = uvw\) mit \(u = 0^a\), \(v = 0^b\) und \(w = 0^c\), sodass \(b \ge 1\) und \(a + b \le n\), insbesondere gilt \(1 \le b \le n\). Es gilt allerdings \(uv^2 w = 0^{n^2 + b} \notin L\), da aufgrund \(n^2
&lt; n^2 + b &lt; n^2 + n + 1 &lt; (n + 1)^2\) die Zahl \(n^2 + b\) keine Quadratzahl ist.
</p>

<p>
<em>Beispiel</em>: \(L = \{0^p \;|\; p \text { prim}\}\) ist nicht regula&#x0308;r, denn andernfalls gilt A&#x0308;hnliches wie eben. Wa&#x0308;hlt man \(x = 0^p \in L\), wobei \(p\) eine Primzahl mit \(p &gt; n +
2\) ist (es gilt \(|0^p| = p \ge n\)), dann gilt \(0^p = uvw\) mit \(u = 0^a\), \(v = 0^b\) und \(w = 0^c\), sodass \(b \ge 1\) und \(a + b \le n\), insbesondere gilt \(1 \le b \le n\). Fu&#x0308;r \(i = a + c\) gilt
allerdings \(uv^i w = 0^{a + b(a + c) + c} \notin L\), da \(a + b(a + c) + c = (b + 1)(a + c)\) keine Primzahl ist.
</p>



<h2 id="aequivalenzrelation-und-minimalautomat">Äquivalenzrelation und Minimalautomat</h2>

</p>


<p>
<b>A&#x0308;quivalenzrelation \(R_L\)</b>:&#x2003; Fu&#x0308;r eine gegebene Sprache \(L \subset \Sigma ^\ast \) definiert man eine <em><span class="dashuline" >Relation \(R_L\)</span></em> auf \(\Sigma
^\ast \) durch \(x R_L y\) fu&#x0308;r \(x, y \in \Sigma ^\ast \), falls \(\forall _{z \in \Sigma ^\ast }\; (xz \in L \iff yz \in L)\).<br />
Diese Relation ist eine A&#x0308;quivalenzrelation.
</p>

<p>
<em>Bemerkung</em>: Die A&#x0308;quivalenzklassen von \(R_L\) teilen nicht die „Grenze“ zwischen \(L\) und \(\Sigma ^\ast \setminus L\), d.&#x202f;h. \(\lnot (\exists _{x, y \in \Sigma ^\ast ,\; [x] = [y]}\;
x \in L,\; y \notin L)\), denn fu&#x0308;r \(x R_L y\) folgt mit \(z = \varepsilon \), dass \(x \in L \iff y \in L\).
</p>

<p>
<em>Lemma</em> (<span class="textsl" >Verfeinerung von \(R_L\)</span>): Fu&#x0308;r jede regula&#x0308;re Sprache \(L = L(M)\) mit dem DEA<br />
\(M = (Z, \Sigma , \delta , z_0, E)\) gilt \(\forall _{x, y \in \Sigma ^\ast }\; (\widehat {\delta }(z_0, x) = \widehat {\delta }(z_0, y) \;\Rightarrow \; x R_L y)\).
</p>

<p>
<b>Beweis</b>: Seien \(x, y \in \Sigma ^\ast \) mit \(\widehat {\delta }(z_0, x) = \widehat {\delta }(z_0, y)\) und \(z \in \Sigma ^\ast \) beliebig.<br />
Dann gilt \(xz \in L \iff \widehat {\delta }(z_0, xz) \in E \iff \widehat {\delta }(\widehat {\delta }(z_0, x), z) \in E \iff \widehat {\delta }(\widehat {\delta }(z_0, y), z) \in E\)<br />
\(\iff \widehat {\delta }(z_0, yz) \in E \iff yz \in L\). &#x2003;&#x2003;
</p>

<p>
<b>A&#x0308;quivalenzrelation \(R_M\)</b>:&#x2003; Fu&#x0308;r einen DEA \(M = (Z, \Sigma , \delta , z_0, E)\) definiert man eine <em><span class="dashuline" >Relation \(R_M\)</span></em> auf \(\Sigma
^\ast \) durch \(x R_M y\) fu&#x0308;r \(x, y \in \Sigma ^\ast \), falls \(\widehat {\delta }(z_0, x) = \widehat {\delta }(z_0, y)\).<br />
Diese Relation ist eine A&#x0308;quivalenzrelation und es gilt \(R_M \subset R_L\), d.&#x202f;h. \(R_M\) ist eine Verfeinerung von \(R_L\). (die A&#x0308;quivalenzklassen von \(R_L\) werden durch \(R_M\) „verfeinert“).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Index</b>:&#x2003; Seien \(M\) eine Menge und \(R \subset M \times M\) eine A&#x0308;quivalenzrelation. Dann heißt die Anzahl \(|\{[m]_R \;|\; m \in M\}|\) der A&#x0308;quivalenzklassen <em><span
class="dashuline" >Index</span></em> der A&#x0308;quivalenzrelation \(R\).
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >Satz von <span class="textsc" >Myhill</span> und <span class="textsc" >Nerode</span></span>):</span><br />
Eine Sprache \(L\) ist regula&#x0308;r genau dann, wenn die zugeho&#x0308;rige Relation \(R_L\) endlichen Index hat.
</p>

<p>
<b>Beweis</b>: „\(\Rightarrow \)“: Sei \(L = L(M)\) mit dem DEA \(M = (Z, \Sigma , \delta , z_0, E)\). Dann gilt nach obigem Lemma \(R_M \subset R_L\), also ist der Index von \(R_L\) kleiner oder gleich dem Index
von \(R_M\). Dieser ist allerdings maximal \(|Z|\) (aufgrund der Definition von \(R_M\)) und damit endlich.
</p>

<p>
„\(\Leftarrow \)“: Sei \(L \subset \Sigma ^\ast \) eine Sprache, sodass \(R_L\) endlichen Index \(k\) hat. Man wa&#x0308;hlt \(k\) Repra&#x0308;sentanten \(x_1, \dotsc , x_k \in \Sigma ^\ast \) der
A&#x0308;quivalenzklassen (d.&#x202f;h. es gilt \(\Sigma ^\ast = [x_1] \cup \dotsb \cup [x_k]\)) und setzt oBdA \(\varepsilon \in [x_1]\). Nun konstruiert man einen DEA \(M = (Z, \Sigma , \delta , z_0, E)\)
mit \(T(M) = L\) wie folgt:<br />
\(Z := \{[x_1], \dotsc , [x_k]\}\), \(z_0 := [x_1] = [\varepsilon ]\), \(E := \{[x_i] \;|\; x_i \in L\}\) und \(\delta ([x_i], a) := [x_i a]\).<br />
\(E\) ist wohldefiniert, da \([x] = [y]\) impliziert, dass \(x \in L \iff y \in L\) (siehe oben).<br />
\(\delta \) ist wohldefiniert, denn aus \([x] = [y]\) folgt \([xa] = [ya]\) fu&#x0308;r alle \(a \in \Sigma \) (fu&#x0308;r \(z \in \Sigma ^\ast \) beliebig ist \(xaz \in L \iff yaz \in L\) aufgrund \(xz’ \in L
\iff yz’ \in L\) fu&#x0308;r alle \(z’ \in \Sigma ^\ast \), also auch fu&#x0308;r \(z’ = az\)).<br />
Es gilt \(x \in T(M) \iff \widehat {\delta }(z_0, x) = \widehat {\delta }([\varepsilon ], x) = [x] \in E \iff x \in L\), also ist \(L\) regula&#x0308;r. &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<em>Beispiel</em>: Sei \(L = \{0^{m^2} \;|\; m \ge 1\}\). \(R_L\) muss unendlich viele A&#x0308;quivalenzklassen besitzen, denn \(L\) ist nicht regula&#x0308;r (siehe oben). Dies kann man auch direkt nachweisen:
Fu&#x0308;r \(m &lt; n\) gilt \([0^{m^2}] \not = [0^{n^2}]\), denn wa&#x0308;hlt man \(z = 0^{2m + 1}\), so gilt \(0^{m^2} z = 0^{(m+1)^2} \in L\), aber \(0^{n^2} z \notin L\).
</p>

<p>
<em>Beispiel</em>: Betrachtet man \(L = \{x \in \{a, b\}^\ast \;|\; x \text { enthält } abb\}\), so sind die paarweise disjunkten A&#x0308;quivalenzklassen \(\Sigma ^\ast = [abb] \cup [\varepsilon ] \cup
[a] \cup [ab]\), denn: \([abb] = L\) und \(\lnot (\varepsilon R_L a)\) (mit \(z = ab\)), \(\lnot (\varepsilon R_L ab)\) und \(\lnot (a R_L ab)\) (jeweils mit \(z = b\)). Wegen \(\varepsilon , a, ab \notin L
= [abb]\) sind die A&#x0308;quivalenzklassen disjunkt. Es gibt keine weiteren, da fu&#x0308;r jedes Wort \(x \in \Sigma ^\ast \setminus L\) gilt, dass \(x \in [ab]\), falls \(x\) mit \(ab\) endet, dass \(x \in [a]\), falls
\(x\) mit \(a\) endet, und dass \(x \in [\varepsilon ]\), falls \(x\) mit \(b\) endet, aber nicht mit \(ab\) (in diesem Fall kann \(x\) nur aus \(b\)’s bestehen oder leer sein). Somit ist \(L\) regula&#x0308;r.
</p>

<p>
<em>Beispiel</em>: Fu&#x0308;r \(L = \{x \in \{a, b, c\}^\ast \;|\; |x|_a - |x|_b \equiv 3 \mod 5\}\) sind die disjunkten A&#x0308;quivalenzklassen \(\Sigma ^\ast = [aaa] \cup [\varepsilon ] \cup [a]
\cup [aa] \cup [aaaa]\), d.&#x202f;h. auch diese Sprache ist regula&#x0308;r (auch siehe oben).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>minimaler Automat</b>:&#x2003; Sei \(L \subset \Sigma ^\ast \) eine regula&#x0308;re Sprache.<br />
Ein DEA bzw. NEA \(M\) heißt <em><span class="dashuline" >minimal</span></em>, falls \(T(M) = L\) und es keinen DEA bzw. NEA gibt, der dieselbe Sprache erkennt und weniger Zusta&#x0308;nde besitzt.
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >Minimalita&#x0308;t des A&#x0308;quivalenzklassen-DEA</span>):</span> Der im Beweis des Satzes von Myhill und Nerode konstruierte
A&#x0308;quivalenzklassenautomat ist ein minimaler DEA fu&#x0308;r jede regula&#x0308;re Sprache.<br />
Der Minimalautomat ist bis auf Isomorphie (Umbenennen der Zusta&#x0308;nde) eindeutig bestimmt.
</p>

<p>
<b>Beweis</b>: Sei \(M_0\) der A&#x0308;quivalenzklassen-DEA und \(M\) ein weiterer DEA mit \(T(M) = L\).<br />
Dann gilt \(R_M \subset R_L = R_{M_0}\) (\(R_{M_0} \subset R_L\) klar, \(R_L \subset R_{M_0}\) gilt, da aus \(x R_L y\) folgt, dass<br />
\(\widehat {\delta }(z_0, x) = [x] = [y] = \widehat {\delta }(z_0, y)\)). Also ist \(R_M\) eine Verfeinerung von \(R_{M_0}\), die Zahl der Zusta&#x0308;nde von \(M\) kann also nicht kleiner als die von \(M_0\) sein
(Anzahl der Zusta&#x0308;nde von \(M_0\) \(=\) Anzahl der vom Startzustand erreichbaren Zusta&#x0308;nde von \(M_0\) \(=\) Index von \(R_{M_0}\) \(\le \) Index von \(R_M\) \(=\) Anzahl der vom Startzustand
erreichbaren Zusta&#x0308;nde von \(M\) \(\le \) Anzahl der Zusta&#x0308;nde von \(M\)).<br />
Falls \(M\) die minimale Zustandszahl besitzt, gilt \(R_M = R_L\). &#x2003;&#x2003;
</p>

<p>
<em>Bemerkung</em>:<br />
Der minimale NEA fu&#x0308;r eine gegebene regula&#x0308;re Sprache ist <em>nicht</em> eindeutig bestimmt.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>Algorithmus zur Bestimmung des Minimalautomaten</b>:&#x2003; Der <em><span class="dashuline" >Algorithmus zur Bestimmung des minimalen DEA</span></em> bekommt als Eingabe einen DEA, in dem alle
Zusta&#x0308;nde erreichbar sind, und gibt Teilmengen von der Zustandsmenge \(Z\) aus, die verschmolzen werden ko&#x0308;nnen.<br />
Dazu legt sich der Algorithmus eine Matrix \(Z \times Z\) an und verfa&#x0308;hrt folgendermaßen:
</p>
<ul style="list-style-type:none">

<li class="list-item-f28"><p>   Markiere alle Paare \((z, z’)\) mit \(z \in E \land z’ \notin E\) oder \(z \notin E \land z’ \in E\).
</p>
</li>
<li class="list-item-f29"><p>   Markiere jedes Zustandspaar \((p, q)\) mit \(\delta (p, a) = z\), \(\delta (q, a) = z’\) und \((z, z’)\) bereits markiert fu&#x0308;r ein \(a \in \Sigma \).
</p>
</li>
<li class="list-item-f30"><p>   Wiederhole 2., bis sich nichts mehr a&#x0308;ndert.
</p>
</li>
<li class="list-item-f31"><p>   Die nun unmarkierten Paare von Zusta&#x0308;nden ko&#x0308;nnen jeweils zu einem Zustand verschmolzen werden.
</p>
</li>
</ul>

<p>
<em>Bemerkung</em>: Man kann sich den Algorithmus herleiten, indem man sich u&#x0308;berlegt, dass ein Automat dann nicht minimal ist, wenn es zwei verschiedene Zusta&#x0308;nde \(z, z’\) gibt mit \(\widehat {\delta
}(z, x) \in E \iff \widehat {\delta }(z’, x) \in E\) fu&#x0308;r alle \(x \in \Sigma ^\ast \) (es reicht dabei, nur Wo&#x0308;rter mit \(|x| \le |Z|\) zu betrachten).
</p>



<h2 id="einschub-erkennung-durch-monoide">Einschub: Erkennung durch Monoide</h2>

</p>


<p>
<b>Monoid</b>:&#x2003; Das Paar \((M, \ast )\) heißt <em><span class="dashuline" >Monoid</span></em>, falls \(M\) eine Menge und \(\ast \colon M \times M \rightarrow M\) eine Abbildung ist mit \(\forall
_{a, b, c \in M}\; a \ast (b \ast c) = (a \ast b) \ast c\) und \(\exists _{e \in M} \forall _{a \in M}\; e \ast a = a = a \ast e\).
</p>

<p>
<b>Monoidhomomorphismus</b>:&#x2003; Seien \((M_1, \ast _1)\) und \((M_2, \ast _2)\) Monoide.<br />
Eine Abbildung \(\varphi \colon M_1 \rightarrow M_2\) heißt <em><span class="dashuline" >Monoidhomomorphismus</span></em>, falls \(\varphi (m \ast _1 n) = \varphi (m) \ast _2 \varphi (n)\) fu&#x0308;r
alle \(m, n \in M_1\) und \(\varphi (e_1) = e_2\).
</p>

<p>
<b>Erkennung durch Monoide</b>:&#x2003; Seien \(L \subset \Sigma ^\ast \) eine Sprache und \(M\) ein Monoid.<br />
\(M\) <em><span class="dashuline" >erkennt</span></em> \(L\), falls es eine Teilmenge \(A \subset M\) und einen Homomorphismus \(\varphi \colon \Sigma ^\ast \rightarrow M\) gibt mit \(L = \varphi ^{-1}(A)\)
(d.&#x202f;h. \(w \in L \iff \varphi (w) \in A\)).
</p>

<p>
<em>Bemerkung</em>: Alternativ kann man definieren, dass ein Homomorphismus \(\varphi \colon \Sigma ^\ast \rightarrow M\) existieren soll mit \(L = \varphi ^{-1}(\varphi (L))\) (hier ist \(A = \varphi (L)\)).
</p>

<p>
<b>erkennbar</b>:&#x2003;<br />
Eine Sprache heißt <em><span class="dashuline" >erkennbar</span></em>, falls sie von einem endlichen Monoid erkannt wird.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<b>syntaktische Kongruenz</b>:&#x2003; Sei \(L \subset \Sigma ^\ast \) eine Sprache. Zwei Wo&#x0308;rter \(w_1, w_2 \in \Sigma ^\ast \) heißen <em><span class="dashuline"
>a&#x0308;quivalent</span></em>, falls \(\forall _{x, y \in \Sigma ^\ast }\; x w_1 y \in L \iff x w_2 y \in L\). Man schreibt dafu&#x0308;r auch \(w_1 \equiv _L w_2\) oder \(w_1 \equiv w_2\). \(\equiv
_L\) ist eine A&#x0308;quivalenzrelation und sogar eine <em><span class="dashuline" >Kongruenz</span></em>, d.&#x202f;h.<br />
\(w_1 \equiv _L w_2 \iff \forall _{x, y \in \Sigma ^\ast }\; x w_1 y \equiv _L x w_2 y\). Man nennt \(\equiv _L\) daher auch <em><span class="dashuline" >syntaktische Kongruenz</span></em>.
</p>

<p>
<em>Bemerkung</em>: \(\equiv _L\) ist eine Verfeinerung von \(R_L\), d.&#x202f;h. \(w_1 \equiv _L w_2 \;\Rightarrow \; w_1 R_L w_2\).
</p>

<p>
<b>syntaktisches Monoid</b>:&#x2003; Das Quotientenmonoid \(\Synt (L) := \Sigma ^\ast /\!\!\equiv _L \;= \{[w]_{\equiv _L} \;|\; w \in \Sigma ^\ast \}\) heißt <em><span class="dashuline"
>syntaktisches Monoid</span></em> von \(L\).
</p>

<p>
<em>Bemerkung</em>: Um zu zeigen, dass dies auch tatsa&#x0308;chlich wieder ein Monoid ist, muss man zuna&#x0308;chst die Wohldefiniertheit der Monoidoperation zeigen. Fu&#x0308;r \([a] = [a’]\) und \([b] = [b’]\)
ist \(a \equiv _L a’\) und \(b \equiv _L b’\), d.&#x202f;h. fu&#x0308;r \(x, y \in \Sigma ^\ast \) beliebig gilt \(x ab y \in L \iff x a’b y \in L \iff x a’b’ y \in L\), also \([ab] = [a’b’]\). Die
Assoziativita&#x0308;t gilt wegen der Assoziativita&#x0308;t in \(\Sigma ^\ast \), außerdem ist \([\varepsilon ]\) neutral. Damit ist \(\Synt (L)\) ein Monoid.
</p>

<p>
<em>Bemerkung</em>: \(\Synt (L)\) erkennt \(L\), denn wa&#x0308;hle als Homomorphismus die Quotientenabbildung \(\varphi \colon \Sigma ^\ast \rightarrow \Synt (L)\), \(\varphi (a) = [a]\) und als Menge \(A
= \{[a] \;|\; a \in L\}\).<br />
Dann gilt \(L = \varphi ^{-1}(A)\), denn \(a \in L \iff \varphi (a) = [a] \in A\) („\(\Leftarrow \)“: \([a] = [b]\) fu&#x0308;r ein \(b \in L\), also \(a \equiv _L b\), daraus folgt wegen \(b \in L\), dass auch
\(a \in L\) gilt).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >Zusammenhang des syntaktischen Monoids mit regula&#x0308;ren Sprachen</span>):</span><br />
Sei \(L \subset \Sigma ^\ast \) eine Sprache. Dann sind folgende Aussagen a&#x0308;quivalent:
</p>
<ul style="list-style-type:none">

<li class="list-item-f32"><p>\(L\) ist regula&#x0308;r.
</p>
</li>
<li class="list-item-f33"><p>\(L\) ist erkennbar.
</p>
</li>
<li class="list-item-f34"><p>\(\Synt (L)\) ist endlich.
</p>
</li>
</ul>

<p>
<b>Beweis</b>: 3. \(\Rightarrow \) 2. klar, da \(\Synt (L)\) die Sprache \(L\) erkennt.<br />
3. \(\Rightarrow \) 1. gilt, weil \(\equiv _L\) einen endlichen Index hat, wenn \(\Synt (L)\) endlich ist. Da aber \(\equiv _L\) eine Verfeinerung von \(R_L\) ist, ist der Index von \(R_L\) ho&#x0308;chstens so groß wie der
von \(\equiv _L\), d.&#x202f;h. \(R_L\) hat endlichen Index und somit ist \(L\) regula&#x0308;r. &#x2003;&#x2003;
</p>



<h2 id="abschlusseigenschaften">Abschlusseigenschaften</h2>

</p>


<p>
<span class="uline" ><em>Satz</em> (<span class="textsl" >Abschluss von \(\REG \)</span>):</span><br />
Die Klasse \(\REG \) der regula&#x0308;ren Sprachen ist abgeschlossen unter Vereinigung, Schnitt und Komplement (<em><span class="dashuline" ><span class="textsc" >boole</span>sche Operationen</span></em>)
sowie unter Produkt (Konkatenation) und Stern.
</p>

<p>
<b>Beweis</b>: Abschluss unter Vereinigung: Sind \(L_1\) und \(L_2\) regula&#x0308;r, dann gibt es regula&#x0308;re Ausdru&#x0308;cke \(\alpha _1\) und \(\alpha _2\) mit \(L(\alpha _1) = L_1\) und \(L(\alpha
_2) = L_2\). Es gilt \(L(\alpha _1 | \alpha _2) = L_1 \cup L_2\), d.&#x202f;h. \(L_1 \cup L_2\) ist regula&#x0308;r.
</p>

<p>
Abschluss unter Komplement: Ist \(L\) regula&#x0308;r, so gibt es ein endliches Monoid \(M\), einen Homomorphismus \(\varphi \colon \Sigma ^\ast \rightarrow M\) und eine Teilmenge \(A \subset M\) mit \(L = \varphi
^{-1}(A)\). Dann gilt aber auch \(\Sigma ^\ast \setminus L = \varphi ^{-1}(M \setminus A)\), d.&#x202f;h. \(\Sigma ^\ast \setminus L\) wird von demselben endlichen Monoid erkannt und ist somit regula&#x0308;r.
(Alternativ kann man in einem DEA \(M\) mit \(T(M) = L\) Endzusta&#x0308;nde und Nicht-Endzusta&#x0308;nde vertauschen, um einen DEA \(M’\) mit \(T(M’) = \Sigma ^\ast \setminus L\) zu erhalten.)
</p>

<p>
Somit folgt der Abschluss unter booleschen Operationen, denn alle booleschen Operationen (auch der Durchschnitt) sind mit Vereinigung und Komplement darstellbar. (Alternativ kann man zu zwei Automaten \(M_1 = (Z_1, \Sigma
, \delta _1, z_{01}, E_1)\) und \(M_2 = (Z_2, \Sigma , \delta _2, z_{02}, E_2)\) mit \(T(M_1) = L_1\) und \(T(M_2) = L_2\) den <em><span class="dashuline" >Kreuzproduktautomaten</span></em> \(M :=
(Z_1 \times Z_2, \Sigma , \delta , (z_{01}, z_{02}), E_1 \times E_2)\) mit \(\delta ((z, z’), a) := (\delta _1(z, a), \delta _2(z’, a))\) betrachten, fu&#x0308;r den \(T(M) = L_1 \cap L_2\) gilt.)
</p>

<p>
Abschluss unter Produkt: Sind \(L_1\) und \(L_2\) regula&#x0308;r, dann gibt es regula&#x0308;re Ausdru&#x0308;cke \(\alpha _1\) und \(\alpha _2\) mit \(L(\alpha _1) = L_1\) und \(L(\alpha _2) = L_2\). Es gilt
\(L(\alpha _1 \alpha _2) = L_1 L_2\), d.&#x202f;h. \(L_1 L_2\) ist regula&#x0308;r.
</p>

<p>
Abschluss unter Stern: Ist \(L\) regula&#x0308;r, dann gibt es einen regula&#x0308;ren Ausdruck \(\alpha \) mit \(L(\alpha ) = L\). Es gilt \(L(\alpha ^\ast ) = L^\ast \), d.&#x202f;h. \(L^\ast \) ist regula&#x0308;r.
&#x2003;&#x2003;
</p>



<h2 id="entscheidbarkeit">Entscheidbarkeit</h2>

</p>


<p>
<em>Bemerkung</em>: In diesem Abschnitt wird untersucht, welche Probleme in Bezug auf regula&#x0308;re Sprachen entscheidbar sind.
</p>

<p>
<em>Bemerkung</em>: Das <em><span class="dashuline" >Wortproblem</span></em> besteht darin, bei gegebener Sprache \(L\) und einem Wort \(x\) zu entscheiden, ob \(x \in L\) gilt. Das Wortproblem ist fu&#x0308;r
regula&#x0308;re Sprachen entscheidbar (sogar schon fu&#x0308;r Typ-1-Sprachen).<br />
Ist ein DEA \(M\) mit \(T(M) = L\) gegeben, dann ist die Entscheidung in Linearzeit mo&#x0308;glich: Zeichen fu&#x0308;r Zeichen kann man die Zustandsu&#x0308;berga&#x0308;nge im Automaten verfolgen, die durch die
Eingabe eines Wortes \(x \in \Sigma ^\ast \) hervorgerufen werden. Falls ein Endzustand erreicht wird, ist \(x \in L\). Man spricht von <em><span class="dashuline" >Echtzeit</span></em>, da man vorhersehen kann, wie
lange die Lo&#x0308;sung des Wortproblems mit einem DEA dauern wird.<br />
Dies geht nicht so effizient, wenn \(L\) durch einen NEA gegeben ist (mehrere Mo&#x0308;glichkeiten).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<em>Bemerkung</em>: Das <em><span class="dashuline" >Leerheitsproblem</span></em> besteht darin, bei gegebener Sprache \(L\) zu entscheiden, ob \(L = \emptyset \) gilt. Das Leerheitsproblem ist fu&#x0308;r
regula&#x0308;re Sprachen entscheidbar.<br />
In einem DEA kann man z.&#x202f;B. pru&#x0308;fen, ob es einen Weg vom Startzustand zu einem Endzustand gibt. Dies gilt genau dann, wenn \(L \not = \emptyset \).<br />
Alternativ kann man (bei algorithmisch nicht akzeptablem Zeitaufwand) das Pumping-Lemma anwenden. Es gilt \(L \not = \emptyset \iff \exists _{w \in L}\; |w| &lt; n\), wobei \(n\) das \(n\) aus dem
Pumping-Lemma ist. Man pru&#x0308;ft also alle Wo&#x0308;rter der La&#x0308;nge \(&lt; n\) auf Mitgliedschaft in \(L\) (Wortproblem).
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<em>Bemerkung</em>: Das <em><span class="dashuline" >Endlichkeitsproblem</span></em> besteht darin, bei gegebener Sprache \(L\) zu entscheiden, ob \(|L| &lt; \infty \) gilt. Das Endlichkeitsproblem ist fu&#x0308;r
regula&#x0308;re Sprachen entscheidbar.<br />
In einem DEA kann man z.&#x202f;B. pru&#x0308;fen, ob es einen Zyklus gibt, der vom Startzustand erreichbar ist und von dem aus ein Endzustand erreichbar ist. Dies gilt genau dann, wenn \(|L| = \infty \).<br />
Alternativ kann man (bei algorithmisch nicht akzeptablem Zeitaufwand) das Pumping-Lemma anwenden. Es gilt \(|L| = \infty \iff \exists _{w \in L}\; n \le |w| &lt; 2n\), wobei \(n\) das \(n\) aus dem
Pumping-Lemma ist. Man pru&#x0308;ft also alle Wo&#x0308;rter der La&#x0308;nge \(\ge n\) und \(&lt; 2n\) auf Mitgliedschaft in \(L\) (Wortproblem).
</p>

<p>
<b>Beweis</b>: „\(\Leftarrow \)“: Sei \(x \in L\) mit \(n \le |x| &lt; 2n\). Dann gilt aufgrund des Pumping-Lemmas \(x = uvw\), d.&#x202f;h. \(uv^i w \in L\) fu&#x0308;r alle \(i \in \natural _0\). Somit ist
\(L\) unendlich.
</p>

<p>
„\(\Rightarrow \)“: Sei \(|L| = \infty \) und entgegen der Behauptung habe das ku&#x0308;rzeste Wort \(x \in L\) mit \(|x| \ge n\) eine La&#x0308;nge \(\ge 2n\). Aufgrund des Pumping-Lemmas gilt \(x = uvw\) mit
\(uv^0 w = uw \in L\). Wegen \(|v| \le |uv| \le n\) gilt \(|uw| \ge n\). Damit ist aber \(x\) nicht minimal gewesen, ein Widerspruch. &#x2003;&#x2003;
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<em>Bemerkung</em>: Das <em><span class="dashuline" >A&#x0308;quivalenzproblem</span></em> besteht darin, bei gegebenen Sprachen \(L_1\) und \(L_2\) zu entscheiden, ob \(L_1 = L_2\) gilt. Das
A&#x0308;quivalenzproblem ist fu&#x0308;r regula&#x0308;re Sprachen entscheidbar.<br />
Die Klasse \(\REG \) der regula&#x0308;ren Sprachen ist effektiv abgeschlossen unter booleschen Operationen. Man kann also \(L_1 \vartriangle L_2\) bilden und auf Leerheit pru&#x0308;fen (Lo&#x0308;sung des
Leerheitsproblems).<br />
Alternativ kann man die Minimalautomaten bilden und vergleichen.
</p>

<p>
<span
    class="textcolor"
    style="color:#808080"
>
</span>
</p>

<p>
<em>Bemerkung</em>: Das <em><span class="dashuline" >Schnittproblem</span></em> besteht darin, bei gegebenen Sprachen \(L_1\) und \(L_2\) zu entscheiden, ob \(L_1 \cap L_2 = \emptyset \) gilt. Das Schnittproblem
ist fu&#x0308;r regula&#x0308;re Sprachen entscheidbar.<br />
Die Klasse \(\REG \) der regula&#x0308;ren Sprachen ist effektiv abgeschlossen unter booleschen Operationen (d.&#x202f;h. die Ergebnisse dieser Operationen ko&#x0308;nnen algorithmisch in endlicher Zeit bestimmt werden).
Man kann also \(L_1 \cap L_2\) bilden und auf Leerheit pru&#x0308;fen (Lo&#x0308;sung des Leerheitsproblems).
</p>

{% endraw %}
</div>
{:/nomarkdown}
